window.spb = function(modules) {
    var installedModules = {};
    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            i: moduleId,
            l: !1,
            exports: {}
        };
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.l = !0;
        return module.exports;
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.d = function(exports, name, getter) {
        __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
            enumerable: !0,
            get: getter
        });
    };
    __webpack_require__.r = function(exports) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
            value: "Module"
        });
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
    };
    __webpack_require__.t = function(value, mode) {
        1 & mode && (value = __webpack_require__(value));
        if (8 & mode) return value;
        if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
        var ns = Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", {
            enumerable: !0,
            value: value
        });
        if (2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, function(key) {
            return value[key];
        }.bind(null, key));
        return ns;
    };
    __webpack_require__.n = function(module) {
        var getter = module && module.__esModule ? function() {
            return module.default;
        } : function() {
            return module;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
    };
    __webpack_require__.o = function(object, property) {
        return {}.hasOwnProperty.call(object, property);
    };
    __webpack_require__.p = "";
    return __webpack_require__(__webpack_require__.s = "./src/button/index.js");
}({
    "./node_modules/@babel/runtime/helpers/esm/extends.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "default", (function() {
            return _extends;
        }));
        function _extends() {
            return (_extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) ({}).hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }).apply(this, arguments);
        }
    },
    "./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "default", (function() {
            return _objectDestructuringEmpty;
        }));
        function _objectDestructuringEmpty(obj) {
            if (null == obj) throw new TypeError("Cannot destructure undefined");
        }
    },
    "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "default", (function() {
            return _objectWithoutPropertiesLoose;
        }));
        function _objectWithoutPropertiesLoose(source, excluded) {
            if (null == source) return {};
            var target = {};
            var sourceKeys = Object.keys(source);
            var key, i;
            for (i = 0; i < sourceKeys.length; i++) excluded.indexOf(key = sourceKeys[i]) >= 0 || (target[key] = source[key]);
            return target;
        }
    },
    "./node_modules/@krakenjs/beaver-logger/src/index.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "Logger", (function() {
            return Logger;
        }));
        __webpack_require__.d(__webpack_exports__, "LOG_LEVEL", (function() {
            return LOG_LEVEL;
        }));
        __webpack_require__.d(__webpack_exports__, "PROTOCOL", (function() {
            return PROTOCOL;
        }));
        __webpack_require__.d(__webpack_exports__, "canUseSendBeacon", (function() {
            return canUseSendBeacon;
        }));
        __webpack_require__.d(__webpack_exports__, "extendIfDefined", (function() {
            return extendIfDefined;
        }));
        __webpack_require__.d(__webpack_exports__, "sendBeacon", (function() {
            return sendBeacon;
        }));
        __webpack_require__.d(__webpack_exports__, "getHTTPTransport", (function() {
            return getHTTPTransport;
        }));
        var esm_extends = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/extends.js");
        var src = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var belter_src = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        var LOG_LEVEL = {
            DEBUG: "debug",
            INFO: "info",
            WARN: "warn",
            ERROR: "error"
        };
        var PROTOCOL = {
            FILE: "file:"
        };
        var AUTO_FLUSH_LEVEL = [ LOG_LEVEL.WARN, LOG_LEVEL.ERROR ];
        var LOG_LEVEL_PRIORITY = [ LOG_LEVEL.ERROR, LOG_LEVEL.WARN, LOG_LEVEL.INFO, LOG_LEVEL.DEBUG ];
        var DEFAULT_LOG_LEVEL = LOG_LEVEL.DEBUG;
        var canUseSendBeacon = function(_ref) {
            var headers = _ref.headers, enableSendBeacon = _ref.enableSendBeacon;
            var hasHeaders = headers && Object.keys(headers).length;
            return !!(window && window.navigator.sendBeacon && !hasHeaders && enableSendBeacon && window.Blob);
        };
        var sendBeacon = function(_ref2) {
            var _ref2$win = _ref2.win, win = void 0 === _ref2$win ? window : _ref2$win, url = _ref2.url, data = _ref2.data, _ref2$useBlob = _ref2.useBlob, useBlob = void 0 === _ref2$useBlob || _ref2$useBlob;
            try {
                var json = JSON.stringify(data);
                if (!win.navigator.sendBeacon) throw new Error("No sendBeacon available");
                if (useBlob) {
                    var blob = new Blob([ json ], {
                        type: "application/json"
                    });
                    return win.navigator.sendBeacon(url, blob);
                }
                return win.navigator.sendBeacon(url, json);
            } catch (e) {
                return !1;
            }
        };
        var extendIfDefined = function(target, source) {
            for (var key in source) source.hasOwnProperty(key) && (target[key] = source[key]);
        };
        var cross_domain_utils_src = __webpack_require__("./node_modules/@krakenjs/cross-domain-utils/src/index.js");
        function getHTTPTransport(httpWin) {
            return function(_ref) {
                var url = _ref.url, method = _ref.method, headers = _ref.headers, json = _ref.json, _ref$enableSendBeacon = _ref.enableSendBeacon, enableSendBeacon = void 0 !== _ref$enableSendBeacon && _ref$enableSendBeacon;
                return src.ZalgoPromise.try((function() {
                    var httpWindow = httpWin || window;
                    var win = Object(cross_domain_utils_src.isSameDomain)(httpWindow) ? Object(cross_domain_utils_src.assertSameDomain)(httpWindow) : window;
                    var beaconResult = !1;
                    canUseSendBeacon({
                        headers: headers,
                        enableSendBeacon: enableSendBeacon
                    }) && (beaconResult = sendBeacon({
                        win: win,
                        url: url,
                        data: json,
                        useBlob: !0
                    }));
                    return beaconResult || Object(belter_src.request)({
                        win: win,
                        url: url,
                        method: method,
                        headers: headers,
                        json: json
                    });
                })).then(belter_src.noop);
            };
        }
        function Logger(_ref) {
            var url = _ref.url, prefix = _ref.prefix, _ref$logLevel = _ref.logLevel, logLevel = void 0 === _ref$logLevel ? DEFAULT_LOG_LEVEL : _ref$logLevel, _ref$transport = _ref.transport, transport = void 0 === _ref$transport ? getHTTPTransport() : _ref$transport, _ref$flushInterval = _ref.flushInterval, flushInterval = void 0 === _ref$flushInterval ? 6e4 : _ref$flushInterval, _ref$enableSendBeacon = _ref.enableSendBeacon, enableSendBeacon = void 0 !== _ref$enableSendBeacon && _ref$enableSendBeacon;
            var events = [];
            var tracking = [];
            var metrics = [];
            var payloadBuilders = [];
            var metaBuilders = [];
            var trackingBuilders = [];
            var headerBuilders = [];
            function print(level, event, payload) {
                if (Object(belter_src.isBrowser)() && window.console && window.console.log && !(LOG_LEVEL_PRIORITY.indexOf(level) > LOG_LEVEL_PRIORITY.indexOf(logLevel))) {
                    var args = [ event ];
                    args.push(payload);
                    (payload.error || payload.warning) && args.push("\n\n", payload.error || payload.warning);
                    try {
                        window.console[level] && window.console[level].apply ? window.console[level].apply(window.console, args) : window.console.log && window.console.log.apply && window.console.log.apply(window.console, args);
                    } catch (err) {}
                }
            }
            function immediateFlush() {
                return src.ZalgoPromise.try((function() {
                    if (Object(belter_src.isBrowser)() && window.location.protocol !== PROTOCOL.FILE && (events.length || tracking.length || metrics.length)) {
                        var meta = {};
                        for (var _i2 = 0; _i2 < metaBuilders.length; _i2++) extendIfDefined(meta, (0, metaBuilders[_i2])(meta));
                        var headers = {};
                        for (var _i4 = 0; _i4 < headerBuilders.length; _i4++) extendIfDefined(headers, (0, 
                        headerBuilders[_i4])(headers));
                        var res;
                        url && (res = transport({
                            method: "POST",
                            url: url,
                            headers: headers,
                            json: {
                                events: events,
                                meta: meta,
                                tracking: tracking,
                                metrics: metrics
                            },
                            enableSendBeacon: enableSendBeacon
                        }).catch(belter_src.noop));
                        events = [];
                        tracking = [];
                        metrics = [];
                        return src.ZalgoPromise.resolve(res).then(belter_src.noop);
                    }
                }));
            }
            var flush = Object(belter_src.promiseDebounce)(immediateFlush);
            function log(level, event, payload) {
                void 0 === payload && (payload = {});
                if (!Object(belter_src.isBrowser)()) return logger;
                prefix && (event = prefix + "_" + event);
                var logPayload = Object(esm_extends.default)({}, Object(belter_src.objFilter)(payload), {
                    timestamp: Date.now().toString()
                });
                for (var _i6 = 0; _i6 < payloadBuilders.length; _i6++) extendIfDefined(logPayload, (0, 
                payloadBuilders[_i6])(logPayload));
                !function(level, event, payload) {
                    events.push({
                        level: level,
                        event: event,
                        payload: payload
                    });
                    -1 !== AUTO_FLUSH_LEVEL.indexOf(level) && flush();
                }(level, event, logPayload);
                print(level, event, logPayload);
                return logger;
            }
            function addBuilder(builders, builder) {
                builders.push(builder);
                return logger;
            }
            Object(belter_src.isBrowser)() && Object(belter_src.safeInterval)(flush, flushInterval);
            if ("object" == typeof window) {
                window.addEventListener("beforeunload", (function() {
                    immediateFlush();
                }));
                window.addEventListener("unload", (function() {
                    immediateFlush();
                }));
                window.addEventListener("pagehide", (function() {
                    immediateFlush();
                }));
            }
            var logger = {
                debug: function(event, payload) {
                    return log(LOG_LEVEL.DEBUG, event, payload);
                },
                info: function(event, payload) {
                    return log(LOG_LEVEL.INFO, event, payload);
                },
                warn: function(event, payload) {
                    return log(LOG_LEVEL.WARN, event, payload);
                },
                error: function(event, payload) {
                    return log(LOG_LEVEL.ERROR, event, payload);
                },
                track: function(payload) {
                    void 0 === payload && (payload = {});
                    if (!Object(belter_src.isBrowser)()) return logger;
                    var trackingPayload = Object(belter_src.objFilter)(payload);
                    for (var _i8 = 0; _i8 < trackingBuilders.length; _i8++) extendIfDefined(trackingPayload, (0, 
                    trackingBuilders[_i8])(trackingPayload));
                    print(LOG_LEVEL.DEBUG, "track", trackingPayload);
                    tracking.push(trackingPayload);
                    return logger;
                },
                metric: function(metricPayload) {
                    if (!Object(belter_src.isBrowser)()) return logger;
                    print(LOG_LEVEL.DEBUG, "metric." + metricPayload.metricNamespace, metricPayload.dimensions || {});
                    metrics.push(metricPayload);
                    return logger;
                },
                flush: flush,
                immediateFlush: immediateFlush,
                addPayloadBuilder: function(builder) {
                    return addBuilder(payloadBuilders, builder);
                },
                addMetaBuilder: function(builder) {
                    return addBuilder(metaBuilders, builder);
                },
                addTrackingBuilder: function(builder) {
                    return addBuilder(trackingBuilders, builder);
                },
                addHeaderBuilder: function(builder) {
                    return addBuilder(headerBuilders, builder);
                },
                setTransport: function(newTransport) {
                    transport = newTransport;
                    return logger;
                },
                configure: function(opts) {
                    opts.url && (url = opts.url);
                    opts.prefix && (prefix = opts.prefix);
                    opts.logLevel && (logLevel = opts.logLevel);
                    opts.transport && (transport = opts.transport);
                    opts.flushInterval && (flushInterval = opts.flushInterval);
                    opts.enableSendBeacon && (enableSendBeacon = opts.enableSendBeacon);
                    return logger;
                },
                __buffer__: {
                    get events() {
                        return events;
                    },
                    get tracking() {
                        return tracking;
                    },
                    get metrics() {
                        return metrics;
                    }
                }
            };
            Object.defineProperty(logger, "__buffer__", {
                writable: !1
            });
            return logger;
        }
    },
    "./node_modules/@krakenjs/belter/dist/belter.js": function(module, exports, __webpack_require__) {
        "undefined" != typeof self && self, module.exports = function(modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
                if (installedModules[moduleId]) return installedModules[moduleId].exports;
                var module = installedModules[moduleId] = {
                    i: moduleId,
                    l: !1,
                    exports: {}
                };
                modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                module.l = !0;
                return module.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.d = function(exports, name, getter) {
                __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
                    enumerable: !0,
                    get: getter
                });
            };
            __webpack_require__.r = function(exports) {
                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
                    value: "Module"
                });
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
            };
            __webpack_require__.t = function(value, mode) {
                1 & mode && (value = __webpack_require__(value));
                if (8 & mode) return value;
                if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
                var ns = Object.create(null);
                __webpack_require__.r(ns);
                Object.defineProperty(ns, "default", {
                    enumerable: !0,
                    value: value
                });
                if (2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, function(key) {
                    return value[key];
                }.bind(null, key));
                return ns;
            };
            __webpack_require__.n = function(module) {
                var getter = module && module.__esModule ? function() {
                    return module.default;
                } : function() {
                    return module;
                };
                __webpack_require__.d(getter, "a", getter);
                return getter;
            };
            __webpack_require__.o = function(object, property) {
                return {}.hasOwnProperty.call(object, property);
            };
            __webpack_require__.p = "";
            return __webpack_require__(__webpack_require__.s = 0);
        }([ function(module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            __webpack_require__.d(__webpack_exports__, "getUserAgent", (function() {
                return getUserAgent;
            }));
            __webpack_require__.d(__webpack_exports__, "isDevice", (function() {
                return isDevice;
            }));
            __webpack_require__.d(__webpack_exports__, "isTablet", (function() {
                return isTablet;
            }));
            __webpack_require__.d(__webpack_exports__, "isWebView", (function() {
                return isWebView;
            }));
            __webpack_require__.d(__webpack_exports__, "isStandAlone", (function() {
                return isStandAlone;
            }));
            __webpack_require__.d(__webpack_exports__, "isFacebookWebView", (function() {
                return isFacebookWebView;
            }));
            __webpack_require__.d(__webpack_exports__, "isFirefox", (function() {
                return isFirefox;
            }));
            __webpack_require__.d(__webpack_exports__, "isFirefoxIOS", (function() {
                return isFirefoxIOS;
            }));
            __webpack_require__.d(__webpack_exports__, "isEdgeIOS", (function() {
                return isEdgeIOS;
            }));
            __webpack_require__.d(__webpack_exports__, "isOperaMini", (function() {
                return isOperaMini;
            }));
            __webpack_require__.d(__webpack_exports__, "isAndroid", (function() {
                return isAndroid;
            }));
            __webpack_require__.d(__webpack_exports__, "isIos", (function() {
                return isIos;
            }));
            __webpack_require__.d(__webpack_exports__, "isIOS14", (function() {
                return isIOS14;
            }));
            __webpack_require__.d(__webpack_exports__, "isGoogleSearchApp", (function() {
                return isGoogleSearchApp;
            }));
            __webpack_require__.d(__webpack_exports__, "isQQBrowser", (function() {
                return isQQBrowser;
            }));
            __webpack_require__.d(__webpack_exports__, "isIosWebview", (function() {
                return isIosWebview;
            }));
            __webpack_require__.d(__webpack_exports__, "isSFVC", (function() {
                return isSFVC;
            }));
            __webpack_require__.d(__webpack_exports__, "isSFVCorSafari", (function() {
                return isSFVCorSafari;
            }));
            __webpack_require__.d(__webpack_exports__, "isAndroidWebview", (function() {
                return isAndroidWebview;
            }));
            __webpack_require__.d(__webpack_exports__, "isIE", (function() {
                return device_isIE;
            }));
            __webpack_require__.d(__webpack_exports__, "isIECompHeader", (function() {
                return isIECompHeader;
            }));
            __webpack_require__.d(__webpack_exports__, "isElectron", (function() {
                return isElectron;
            }));
            __webpack_require__.d(__webpack_exports__, "isIEIntranet", (function() {
                return isIEIntranet;
            }));
            __webpack_require__.d(__webpack_exports__, "isMacOsCna", (function() {
                return isMacOsCna;
            }));
            __webpack_require__.d(__webpack_exports__, "supportsPopups", (function() {
                return supportsPopups;
            }));
            __webpack_require__.d(__webpack_exports__, "isChrome", (function() {
                return isChrome;
            }));
            __webpack_require__.d(__webpack_exports__, "isSafari", (function() {
                return isSafari;
            }));
            __webpack_require__.d(__webpack_exports__, "isApplePaySupported", (function() {
                return isApplePaySupported;
            }));
            __webpack_require__.d(__webpack_exports__, "isCrossSiteTrackingEnabled", (function() {
                return isCrossSiteTrackingEnabled;
            }));
            __webpack_require__.d(__webpack_exports__, "getBody", (function() {
                return getBody;
            }));
            __webpack_require__.d(__webpack_exports__, "isDocumentReady", (function() {
                return isDocumentReady;
            }));
            __webpack_require__.d(__webpack_exports__, "isDocumentInteractive", (function() {
                return isDocumentInteractive;
            }));
            __webpack_require__.d(__webpack_exports__, "urlEncode", (function() {
                return urlEncode;
            }));
            __webpack_require__.d(__webpack_exports__, "waitForWindowReady", (function() {
                return waitForWindowReady;
            }));
            __webpack_require__.d(__webpack_exports__, "waitForDocumentReady", (function() {
                return waitForDocumentReady;
            }));
            __webpack_require__.d(__webpack_exports__, "waitForDocumentBody", (function() {
                return waitForDocumentBody;
            }));
            __webpack_require__.d(__webpack_exports__, "parseQuery", (function() {
                return parseQuery;
            }));
            __webpack_require__.d(__webpack_exports__, "getQueryParam", (function() {
                return getQueryParam;
            }));
            __webpack_require__.d(__webpack_exports__, "urlWillRedirectPage", (function() {
                return urlWillRedirectPage;
            }));
            __webpack_require__.d(__webpack_exports__, "formatQuery", (function() {
                return formatQuery;
            }));
            __webpack_require__.d(__webpack_exports__, "extendQuery", (function() {
                return extendQuery;
            }));
            __webpack_require__.d(__webpack_exports__, "extendUrl", (function() {
                return extendUrl;
            }));
            __webpack_require__.d(__webpack_exports__, "redirect", (function() {
                return redirect;
            }));
            __webpack_require__.d(__webpack_exports__, "hasMetaViewPort", (function() {
                return hasMetaViewPort;
            }));
            __webpack_require__.d(__webpack_exports__, "isElementVisible", (function() {
                return isElementVisible;
            }));
            __webpack_require__.d(__webpack_exports__, "getPerformance", (function() {
                return getPerformance;
            }));
            __webpack_require__.d(__webpack_exports__, "enablePerformance", (function() {
                return enablePerformance;
            }));
            __webpack_require__.d(__webpack_exports__, "getPageRenderTime", (function() {
                return getPageRenderTime;
            }));
            __webpack_require__.d(__webpack_exports__, "htmlEncode", (function() {
                return htmlEncode;
            }));
            __webpack_require__.d(__webpack_exports__, "isBrowser", (function() {
                return dom_isBrowser;
            }));
            __webpack_require__.d(__webpack_exports__, "querySelectorAll", (function() {
                return querySelectorAll;
            }));
            __webpack_require__.d(__webpack_exports__, "onClick", (function() {
                return onClick;
            }));
            __webpack_require__.d(__webpack_exports__, "getScript", (function() {
                return getScript;
            }));
            __webpack_require__.d(__webpack_exports__, "isLocalStorageEnabled", (function() {
                return isLocalStorageEnabled;
            }));
            __webpack_require__.d(__webpack_exports__, "getBrowserLocales", (function() {
                return getBrowserLocales;
            }));
            __webpack_require__.d(__webpack_exports__, "appendChild", (function() {
                return appendChild;
            }));
            __webpack_require__.d(__webpack_exports__, "getElementSafe", (function() {
                return getElementSafe;
            }));
            __webpack_require__.d(__webpack_exports__, "getElement", (function() {
                return getElement;
            }));
            __webpack_require__.d(__webpack_exports__, "elementReady", (function() {
                return elementReady;
            }));
            __webpack_require__.d(__webpack_exports__, "PopupOpenError", (function() {
                return dom_PopupOpenError;
            }));
            __webpack_require__.d(__webpack_exports__, "popup", (function() {
                return popup;
            }));
            __webpack_require__.d(__webpack_exports__, "writeToWindow", (function() {
                return writeToWindow;
            }));
            __webpack_require__.d(__webpack_exports__, "writeElementToWindow", (function() {
                return writeElementToWindow;
            }));
            __webpack_require__.d(__webpack_exports__, "setStyle", (function() {
                return setStyle;
            }));
            __webpack_require__.d(__webpack_exports__, "awaitFrameLoad", (function() {
                return awaitFrameLoad;
            }));
            __webpack_require__.d(__webpack_exports__, "awaitFrameWindow", (function() {
                return awaitFrameWindow;
            }));
            __webpack_require__.d(__webpack_exports__, "createElement", (function() {
                return createElement;
            }));
            __webpack_require__.d(__webpack_exports__, "iframe", (function() {
                return iframe;
            }));
            __webpack_require__.d(__webpack_exports__, "addEventListener", (function() {
                return addEventListener;
            }));
            __webpack_require__.d(__webpack_exports__, "bindEvents", (function() {
                return bindEvents;
            }));
            __webpack_require__.d(__webpack_exports__, "setVendorCSS", (function() {
                return setVendorCSS;
            }));
            __webpack_require__.d(__webpack_exports__, "animate", (function() {
                return animate;
            }));
            __webpack_require__.d(__webpack_exports__, "makeElementVisible", (function() {
                return makeElementVisible;
            }));
            __webpack_require__.d(__webpack_exports__, "makeElementInvisible", (function() {
                return makeElementInvisible;
            }));
            __webpack_require__.d(__webpack_exports__, "showElement", (function() {
                return showElement;
            }));
            __webpack_require__.d(__webpack_exports__, "hideElement", (function() {
                return hideElement;
            }));
            __webpack_require__.d(__webpack_exports__, "destroyElement", (function() {
                return destroyElement;
            }));
            __webpack_require__.d(__webpack_exports__, "showAndAnimate", (function() {
                return showAndAnimate;
            }));
            __webpack_require__.d(__webpack_exports__, "animateAndHide", (function() {
                return animateAndHide;
            }));
            __webpack_require__.d(__webpack_exports__, "addClass", (function() {
                return addClass;
            }));
            __webpack_require__.d(__webpack_exports__, "removeClass", (function() {
                return removeClass;
            }));
            __webpack_require__.d(__webpack_exports__, "isElementClosed", (function() {
                return isElementClosed;
            }));
            __webpack_require__.d(__webpack_exports__, "watchElementForClose", (function() {
                return watchElementForClose;
            }));
            __webpack_require__.d(__webpack_exports__, "fixScripts", (function() {
                return fixScripts;
            }));
            __webpack_require__.d(__webpack_exports__, "onResize", (function() {
                return onResize;
            }));
            __webpack_require__.d(__webpack_exports__, "getResourceLoadTime", (function() {
                return getResourceLoadTime;
            }));
            __webpack_require__.d(__webpack_exports__, "isShadowElement", (function() {
                return isShadowElement;
            }));
            __webpack_require__.d(__webpack_exports__, "getShadowRoot", (function() {
                return getShadowRoot;
            }));
            __webpack_require__.d(__webpack_exports__, "getShadowHost", (function() {
                return getShadowHost;
            }));
            __webpack_require__.d(__webpack_exports__, "insertShadowSlot", (function() {
                return insertShadowSlot;
            }));
            __webpack_require__.d(__webpack_exports__, "preventClickFocus", (function() {
                return preventClickFocus;
            }));
            __webpack_require__.d(__webpack_exports__, "getStackTrace", (function() {
                return getStackTrace;
            }));
            __webpack_require__.d(__webpack_exports__, "getCurrentScript", (function() {
                return getCurrentScript;
            }));
            __webpack_require__.d(__webpack_exports__, "getCurrentScriptUID", (function() {
                return getCurrentScriptUID;
            }));
            __webpack_require__.d(__webpack_exports__, "submitForm", (function() {
                return submitForm;
            }));
            __webpack_require__.d(__webpack_exports__, "experiment", (function() {
                return experiment;
            }));
            __webpack_require__.d(__webpack_exports__, "getGlobalNameSpace", (function() {
                return getGlobalNameSpace;
            }));
            __webpack_require__.d(__webpack_exports__, "getStorage", (function() {
                return getStorage;
            }));
            __webpack_require__.d(__webpack_exports__, "isElement", (function() {
                return isElement;
            }));
            __webpack_require__.d(__webpack_exports__, "getFunctionName", (function() {
                return getFunctionName;
            }));
            __webpack_require__.d(__webpack_exports__, "setFunctionName", (function() {
                return setFunctionName;
            }));
            __webpack_require__.d(__webpack_exports__, "base64encode", (function() {
                return base64encode;
            }));
            __webpack_require__.d(__webpack_exports__, "base64decode", (function() {
                return base64decode;
            }));
            __webpack_require__.d(__webpack_exports__, "uniqueID", (function() {
                return uniqueID;
            }));
            __webpack_require__.d(__webpack_exports__, "getGlobal", (function() {
                return getGlobal;
            }));
            __webpack_require__.d(__webpack_exports__, "getObjectID", (function() {
                return getObjectID;
            }));
            __webpack_require__.d(__webpack_exports__, "getEmptyObject", (function() {
                return getEmptyObject;
            }));
            __webpack_require__.d(__webpack_exports__, "memoize", (function() {
                return memoize;
            }));
            __webpack_require__.d(__webpack_exports__, "promiseIdentity", (function() {
                return promiseIdentity;
            }));
            __webpack_require__.d(__webpack_exports__, "memoizePromise", (function() {
                return memoizePromise;
            }));
            __webpack_require__.d(__webpack_exports__, "promisify", (function() {
                return promisify;
            }));
            __webpack_require__.d(__webpack_exports__, "inlineMemoize", (function() {
                return inlineMemoize;
            }));
            __webpack_require__.d(__webpack_exports__, "noop", (function() {
                return src_util_noop;
            }));
            __webpack_require__.d(__webpack_exports__, "once", (function() {
                return once;
            }));
            __webpack_require__.d(__webpack_exports__, "hashStr", (function() {
                return hashStr;
            }));
            __webpack_require__.d(__webpack_exports__, "strHashStr", (function() {
                return strHashStr;
            }));
            __webpack_require__.d(__webpack_exports__, "match", (function() {
                return match;
            }));
            __webpack_require__.d(__webpack_exports__, "awaitKey", (function() {
                return awaitKey;
            }));
            __webpack_require__.d(__webpack_exports__, "stringifyError", (function() {
                return stringifyError;
            }));
            __webpack_require__.d(__webpack_exports__, "stringifyErrorMessage", (function() {
                return stringifyErrorMessage;
            }));
            __webpack_require__.d(__webpack_exports__, "stringify", (function() {
                return stringify;
            }));
            __webpack_require__.d(__webpack_exports__, "domainMatches", (function() {
                return domainMatches;
            }));
            __webpack_require__.d(__webpack_exports__, "patchMethod", (function() {
                return patchMethod;
            }));
            __webpack_require__.d(__webpack_exports__, "extend", (function() {
                return extend;
            }));
            __webpack_require__.d(__webpack_exports__, "values", (function() {
                return util_values;
            }));
            __webpack_require__.d(__webpack_exports__, "memoizedValues", (function() {
                return memoizedValues;
            }));
            __webpack_require__.d(__webpack_exports__, "perc", (function() {
                return perc;
            }));
            __webpack_require__.d(__webpack_exports__, "min", (function() {
                return min;
            }));
            __webpack_require__.d(__webpack_exports__, "max", (function() {
                return max;
            }));
            __webpack_require__.d(__webpack_exports__, "roundUp", (function() {
                return roundUp;
            }));
            __webpack_require__.d(__webpack_exports__, "regexMap", (function() {
                return regexMap;
            }));
            __webpack_require__.d(__webpack_exports__, "svgToBase64", (function() {
                return svgToBase64;
            }));
            __webpack_require__.d(__webpack_exports__, "objFilter", (function() {
                return objFilter;
            }));
            __webpack_require__.d(__webpack_exports__, "identity", (function() {
                return identity;
            }));
            __webpack_require__.d(__webpack_exports__, "regexTokenize", (function() {
                return regexTokenize;
            }));
            __webpack_require__.d(__webpack_exports__, "promiseDebounce", (function() {
                return promiseDebounce;
            }));
            __webpack_require__.d(__webpack_exports__, "safeInterval", (function() {
                return safeInterval;
            }));
            __webpack_require__.d(__webpack_exports__, "isInteger", (function() {
                return isInteger;
            }));
            __webpack_require__.d(__webpack_exports__, "isFloat", (function() {
                return isFloat;
            }));
            __webpack_require__.d(__webpack_exports__, "serializePrimitive", (function() {
                return serializePrimitive;
            }));
            __webpack_require__.d(__webpack_exports__, "deserializePrimitive", (function() {
                return deserializePrimitive;
            }));
            __webpack_require__.d(__webpack_exports__, "dotify", (function() {
                return dotify;
            }));
            __webpack_require__.d(__webpack_exports__, "undotify", (function() {
                return undotify;
            }));
            __webpack_require__.d(__webpack_exports__, "eventEmitter", (function() {
                return eventEmitter;
            }));
            __webpack_require__.d(__webpack_exports__, "camelToDasherize", (function() {
                return camelToDasherize;
            }));
            __webpack_require__.d(__webpack_exports__, "dasherizeToCamel", (function() {
                return dasherizeToCamel;
            }));
            __webpack_require__.d(__webpack_exports__, "capitalizeFirstLetter", (function() {
                return capitalizeFirstLetter;
            }));
            __webpack_require__.d(__webpack_exports__, "get", (function() {
                return util_get;
            }));
            __webpack_require__.d(__webpack_exports__, "safeTimeout", (function() {
                return safeTimeout;
            }));
            __webpack_require__.d(__webpack_exports__, "defineLazyProp", (function() {
                return defineLazyProp;
            }));
            __webpack_require__.d(__webpack_exports__, "arrayFrom", (function() {
                return arrayFrom;
            }));
            __webpack_require__.d(__webpack_exports__, "isObject", (function() {
                return isObject;
            }));
            __webpack_require__.d(__webpack_exports__, "isObjectObject", (function() {
                return isObjectObject;
            }));
            __webpack_require__.d(__webpack_exports__, "isPlainObject", (function() {
                return isPlainObject;
            }));
            __webpack_require__.d(__webpack_exports__, "replaceObject", (function() {
                return replaceObject;
            }));
            __webpack_require__.d(__webpack_exports__, "copyProp", (function() {
                return copyProp;
            }));
            __webpack_require__.d(__webpack_exports__, "regex", (function() {
                return regex;
            }));
            __webpack_require__.d(__webpack_exports__, "regexAll", (function() {
                return regexAll;
            }));
            __webpack_require__.d(__webpack_exports__, "isDefined", (function() {
                return isDefined;
            }));
            __webpack_require__.d(__webpack_exports__, "cycle", (function() {
                return cycle;
            }));
            __webpack_require__.d(__webpack_exports__, "debounce", (function() {
                return debounce;
            }));
            __webpack_require__.d(__webpack_exports__, "isRegex", (function() {
                return util_isRegex;
            }));
            __webpack_require__.d(__webpack_exports__, "weakMapMemoize", (function() {
                return util_weakMapMemoize;
            }));
            __webpack_require__.d(__webpack_exports__, "weakMapMemoizePromise", (function() {
                return util_weakMapMemoizePromise;
            }));
            __webpack_require__.d(__webpack_exports__, "getOrSet", (function() {
                return getOrSet;
            }));
            __webpack_require__.d(__webpack_exports__, "cleanup", (function() {
                return cleanup;
            }));
            __webpack_require__.d(__webpack_exports__, "tryCatch", (function() {
                return tryCatch;
            }));
            __webpack_require__.d(__webpack_exports__, "removeFromArray", (function() {
                return removeFromArray;
            }));
            __webpack_require__.d(__webpack_exports__, "assertExists", (function() {
                return assertExists;
            }));
            __webpack_require__.d(__webpack_exports__, "unique", (function() {
                return unique;
            }));
            __webpack_require__.d(__webpack_exports__, "constHas", (function() {
                return constHas;
            }));
            __webpack_require__.d(__webpack_exports__, "dedupeErrors", (function() {
                return dedupeErrors;
            }));
            __webpack_require__.d(__webpack_exports__, "ExtendableError", (function() {
                return util_ExtendableError;
            }));
            __webpack_require__.d(__webpack_exports__, "sanitizeUrl", (function() {
                return sanitizeUrl;
            }));
            __webpack_require__.d(__webpack_exports__, "request", (function() {
                return request;
            }));
            __webpack_require__.d(__webpack_exports__, "addHeaderBuilder", (function() {
                return addHeaderBuilder;
            }));
            __webpack_require__.d(__webpack_exports__, "TYPES", (function() {
                return types_TYPES;
            }));
            __webpack_require__.d(__webpack_exports__, "memoized", (function() {
                return memoized;
            }));
            __webpack_require__.d(__webpack_exports__, "promise", (function() {
                return decorators_promise;
            }));
            __webpack_require__.d(__webpack_exports__, "isPerc", (function() {
                return isPerc;
            }));
            __webpack_require__.d(__webpack_exports__, "isPx", (function() {
                return isPx;
            }));
            __webpack_require__.d(__webpack_exports__, "toNum", (function() {
                return toNum;
            }));
            __webpack_require__.d(__webpack_exports__, "toPx", (function() {
                return toPx;
            }));
            __webpack_require__.d(__webpack_exports__, "toCSS", (function() {
                return toCSS;
            }));
            __webpack_require__.d(__webpack_exports__, "percOf", (function() {
                return percOf;
            }));
            __webpack_require__.d(__webpack_exports__, "normalizeDimension", (function() {
                return normalizeDimension;
            }));
            __webpack_require__.d(__webpack_exports__, "wrapPromise", (function() {
                return wrapPromise;
            }));
            __webpack_require__.d(__webpack_exports__, "KEY_CODES", (function() {
                return KEY_CODES;
            }));
            __webpack_require__.d(__webpack_exports__, "ATTRIBUTES", (function() {
                return ATTRIBUTES;
            }));
            __webpack_require__.d(__webpack_exports__, "UID_HASH_LENGTH", (function() {
                return UID_HASH_LENGTH;
            }));
            __webpack_require__.d(__webpack_exports__, "invalidProtocolRegex", (function() {
                return invalidProtocolRegex;
            }));
            __webpack_require__.d(__webpack_exports__, "htmlEntitiesRegex", (function() {
                return htmlEntitiesRegex;
            }));
            __webpack_require__.d(__webpack_exports__, "htmlCtrlEntityRegex", (function() {
                return htmlCtrlEntityRegex;
            }));
            __webpack_require__.d(__webpack_exports__, "ctrlCharactersRegex", (function() {
                return ctrlCharactersRegex;
            }));
            __webpack_require__.d(__webpack_exports__, "urlSchemeRegex", (function() {
                return urlSchemeRegex;
            }));
            __webpack_require__.d(__webpack_exports__, "relativeFirstCharacters", (function() {
                return relativeFirstCharacters;
            }));
            __webpack_require__.d(__webpack_exports__, "BLANK_URL", (function() {
                return BLANK_URL;
            }));
            __webpack_require__.d(__webpack_exports__, "sfvcScreens", (function() {
                return sfvcScreens;
            }));
            var sfvcScreens = {
                932: {
                    textSizeHeights: [ 746, 742, 738 ],
                    textSizeHeightsNoTabs: [ 854, 852, 850, 848 ],
                    zoomHeight: {
                        1.15: [ 746, 742, 738 ],
                        1.25: [ 746, 743 ],
                        1.5: [ 746, 743 ],
                        1.75: [ 746, 742, 739 ],
                        2: [ 746, 742 ],
                        2.5: [ 745, 743 ],
                        3: [ 749 ],
                        3.01: [ 749 ]
                    },
                    maybeSafari: {
                        1: [ 732 ],
                        1.15: [ 733 ],
                        1.25: [ 738, 733 ],
                        1.5: [ 738, 732 ],
                        1.75: [ 732 ],
                        2: [ 738, 732 ],
                        2.5: [ 738, 733 ],
                        3: [ 743, 740, 734 ],
                        3.01: [ 743, 740, 734 ]
                    }
                },
                926: {
                    textSizeHeights: [ 752, 748, 744, 738 ],
                    textSizeHeightsNoTabs: [ 860, 858, 856, 854 ],
                    zoomHeight: {
                        1.15: [ 752, 747, 744, 738 ],
                        1.25: [ 753, 748, 744, 738 ],
                        1.5: [ 752, 749, 744, 738 ],
                        1.75: [ 753, 747, 744, 739 ],
                        2: [ 752, 748, 744 ],
                        2.5: [ 753, 748 ],
                        3: [ 753, 744 ]
                    },
                    maybeSafari: {
                        2: [ 738 ],
                        2.5: [ 745, 738 ],
                        3: [ 747, 738 ]
                    }
                },
                896: {
                    textSizeHeights: [ 721, 717, 713, 707 ],
                    textSizeHeightsNoTabs: [ 829, 827, 825, 823 ],
                    zoomHeight: {
                        1.15: [ 721, 716, 713, 707 ],
                        1.25: [ 721, 718, 713, 708 ],
                        1.5: [ 722, 717, 713 ],
                        1.75: [ 721, 718, 712, 707 ],
                        2: [ 722, 718, 714, 708 ],
                        2.5: [ 720, 718, 713, 708 ],
                        3: [ 720, 717, 708 ]
                    },
                    maybeSafari: {
                        1.5: [ 707 ],
                        3: [ 714 ]
                    }
                },
                852: {
                    textSizeHeights: [ 666, 662, 658 ],
                    textSizeHeightsNoTabs: [ 774, 772, 770, 768 ],
                    zoomHeight: {
                        1.15: [ 666, 662, 658 ],
                        1.25: [ 665, 661, 658 ],
                        1.5: [ 666, 662, 659 ],
                        1.75: [ 667, 662 ],
                        1.99: [ 663, 659 ],
                        2: [ 663, 659 ],
                        2.5: [ 665, 663 ],
                        3: [ 666, 663 ]
                    },
                    maybeSafari: {
                        1: [ 652 ],
                        1.15: [ 652 ],
                        1.25: [ 651 ],
                        1.5: [ 653 ],
                        1.75: [ 658, 653 ],
                        1.99: [ 655, 649 ],
                        2: [ 655, 649 ],
                        2.5: [ 658, 653 ],
                        3: [ 657, 651 ]
                    }
                },
                844: {
                    textSizeHeights: [ 670, 666, 662, 656 ],
                    textSizeHeightsNoTabs: [ 778, 776, 774, 772 ],
                    zoomHeight: {
                        1.15: [ 670, 666, 662 ],
                        1.25: [ 670, 666, 663, 656 ],
                        1.5: [ 671, 666, 662 ],
                        1.75: [ 670, 667, 662, 656 ],
                        2: [ 670, 666, 662 ],
                        2.5: [ 670, 663 ],
                        3: [ 669, 666, 663, 657 ]
                    },
                    maybeSafari: {
                        1.15: [ 656 ],
                        1.5: [ 656 ],
                        2: [ 656 ],
                        2.5: [ 665, 655 ],
                        3: [ 663 ]
                    }
                },
                812: {
                    textSizeHeights: [ 641, 637, 633, 627 ],
                    textSizeHeightsNoTabs: [ 749, 747, 745, 743 ],
                    zoomHeight: {
                        1.15: [ 641, 637, 633, 627 ],
                        1.25: [ 641, 638, 633, 628 ],
                        1.5: [ 641, 638, 633, 627 ],
                        1.75: [ 641, 637, 634 ],
                        2: [ 642, 638, 634, 628 ],
                        2.5: [ 640, 638, 633, 628 ],
                        3: [ 642, 633 ]
                    },
                    maybeSafari: {
                        1.75: [ 627 ],
                        3: [ 636, 627 ]
                    }
                },
                736: {
                    textSizeHeights: [ 628, 624, 620, 614 ],
                    textSizeHeightsNoTabs: [ 736, 734, 732, 730 ],
                    zoomHeight: {
                        1.15: [ 628, 624, 620, 614 ],
                        1.25: [ 628, 624, 620, 614 ],
                        1.5: [ 629, 624, 620 ],
                        1.75: [ 628, 625, 620, 614 ],
                        2: [ 628, 624, 620 ],
                        2.5: [ 628, 625, 620, 615 ],
                        3: [ 627, 624, 615 ]
                    },
                    maybeSafari: {
                        1.5: [ 614 ],
                        2: [ 614 ],
                        3: [ 621 ]
                    }
                },
                667: {
                    textSizeHeights: [ 559, 555, 551, 545 ],
                    textSizeHeightsNoTabs: [ 667, 665, 663, 661 ],
                    zoomHeight: {
                        1.15: [ 559, 555, 551, 545 ],
                        1.25: [ 559, 555, 551, 545 ],
                        1.5: [ 560, 555, 551 ],
                        1.75: [ 558, 555, 551 ],
                        2: [ 560, 556, 552, 546 ],
                        2.5: [ 560, 555, 550 ],
                        3: [ 558, 555, 546 ]
                    },
                    maybeSafari: {
                        1.5: [ 545 ],
                        1.75: [ 544 ],
                        2.5: [ 545 ],
                        3: [ 552 ]
                    }
                }
            };
            function getUserAgent() {
                return window.navigator.mockUserAgent || window.navigator.userAgent;
            }
            var TABLET_PATTERN = /ip(a|ro)d|silk|xoom|playbook|tablet|kindle|Nexus 7|GT-P10|SC-01C|SHW-M180S|SM-T320|SGH-T849|SCH-I800|SHW-M180L|SPH-P100|SGH-I987|zt180|HTC( Flyer|_Flyer)|Sprint ATP51|ViewPad7|pandigital(sprnova|nova)|Ideos S7|Dell Streak 7|Advent Vega|A101IT|A70BHT|MID7015|Next2|nook|FOLIO|MB511.*RUTEM|Mac OS.*Silk/i;
            function isDevice(userAgent) {
                void 0 === userAgent && (userAgent = getUserAgent());
                return !!userAgent.match(/Android|webOS|iPhone|iPad|iPod|bada|Symbian|Palm|CriOS|BlackBerry|IEMobile|WindowsMobile|Opera Mini/i);
            }
            function isTablet(userAgent) {
                void 0 === userAgent && (userAgent = getUserAgent());
                return TABLET_PATTERN.test(userAgent);
            }
            function isWebView(ua) {
                void 0 === ua && (ua = getUserAgent());
                return /(iPhone|iPod|iPad|Macintosh).*AppleWebKit(?!.*Safari)|.*WKWebView/i.test(ua) || /\bwv\b/.test(ua) || /Android.*Version\/(\d)\.(\d)/i.test(ua);
            }
            function isStandAlone() {
                return !0 === window.navigator.standalone || window.matchMedia("(display-mode: standalone)").matches;
            }
            function isFacebookWebView(ua) {
                void 0 === ua && (ua = getUserAgent());
                return /FBAN/.test(ua) || /FBAV/.test(ua);
            }
            function isFirefox(ua) {
                void 0 === ua && (ua = getUserAgent());
                return /Firefox/i.test(ua);
            }
            function isFirefoxIOS(ua) {
                void 0 === ua && (ua = getUserAgent());
                return /FxiOS/i.test(ua);
            }
            function isEdgeIOS(ua) {
                void 0 === ua && (ua = getUserAgent());
                return /EdgiOS/i.test(ua);
            }
            function isOperaMini(ua) {
                void 0 === ua && (ua = getUserAgent());
                return /Opera Mini/i.test(ua);
            }
            function isAndroid(ua) {
                void 0 === ua && (ua = getUserAgent());
                return /Android/.test(ua);
            }
            function isIos(ua) {
                void 0 === ua && (ua = getUserAgent());
                return /iPhone|iPod|iPad/.test(ua);
            }
            function isIOS14(ua) {
                void 0 === ua && (ua = getUserAgent());
                return /iPhone.*OS.*(1)?(?:(1)[0-4]| [0-9])_/.test(ua);
            }
            function isGoogleSearchApp(ua) {
                void 0 === ua && (ua = getUserAgent());
                return /\bGSA\b/.test(ua);
            }
            function isQQBrowser(ua) {
                void 0 === ua && (ua = getUserAgent());
                return /QQBrowser/.test(ua);
            }
            function isIosWebview(ua) {
                void 0 === ua && (ua = getUserAgent());
                return !!isIos(ua) && (!!isGoogleSearchApp(ua) || /.+AppleWebKit(?!.*Safari)|.*WKWebView/.test(ua));
            }
            function isSFVC(ua) {
                void 0 === ua && (ua = getUserAgent());
                if (isIos(ua)) {
                    var height = window.innerHeight;
                    var scale = Math.round(window.screen.width / window.innerWidth * 100) / 100;
                    var computedHeight = Math.round(height * scale);
                    var device = null;
                    if (isIOS14(ua)) device = sfvcScreens[window.outerHeight]; else {
                        if (1 !== scale) return !0;
                        device = sfvcScreens[window.outerHeight];
                    }
                    return !device || (scale > 1 && device.zoomHeight && device.zoomHeight[scale] ? -1 !== device.zoomHeight[scale].indexOf(computedHeight) : -1 !== device.textSizeHeights.indexOf(computedHeight) || -1 !== device.textSizeHeightsNoTabs.indexOf(computedHeight));
                }
                return !1;
            }
            function isSFVCorSafari(ua) {
                void 0 === ua && (ua = getUserAgent());
                if (isIos(ua)) {
                    var sfvc = isSFVC(ua);
                    var device = isIOS14(ua) ? sfvcScreens[window.outerHeight] : null;
                    if (!device) return !1;
                    var height = window.innerHeight;
                    var scale = Math.round(window.screen.width / window.innerWidth * 100) / 100;
                    var computedHeight = Math.round(height * scale);
                    var possibleSafariSizes = device.maybeSafari;
                    var maybeSafari = !1;
                    scale > 1 && possibleSafariSizes[scale] && -1 !== possibleSafariSizes[scale].indexOf(computedHeight) && (maybeSafari = !0);
                    return sfvc || maybeSafari;
                }
                return !1;
            }
            function isAndroidWebview(ua) {
                void 0 === ua && (ua = getUserAgent());
                return !!isAndroid(ua) && /Version\/[\d.]+/.test(ua) && !isOperaMini(ua);
            }
            function device_isIE() {
                return !!window.document.documentMode || Boolean(window.navigator && window.navigator.userAgent && /Edge|MSIE|rv:11/i.test(window.navigator.userAgent));
            }
            function isIECompHeader() {
                var mHttp = window.document.querySelector('meta[http-equiv="X-UA-Compatible"]');
                var mContent = window.document.querySelector('meta[content="IE=edge"]');
                return !(!mHttp || !mContent);
            }
            function isElectron() {
                return !("undefined" == typeof process || !process.versions || !process.versions.electron);
            }
            function isIEIntranet() {
                if (window.document.documentMode) try {
                    var status = window.status;
                    window.status = "testIntranetMode";
                    if ("testIntranetMode" === window.status) {
                        window.status = status;
                        return !0;
                    }
                    return !1;
                } catch (err) {
                    return !1;
                }
                return !1;
            }
            function isMacOsCna() {
                var userAgent = getUserAgent();
                return /Macintosh.*AppleWebKit(?!.*Safari)/i.test(userAgent);
            }
            function supportsPopups(ua) {
                void 0 === ua && (ua = getUserAgent());
                return !(isWebView(ua) || isIosWebview(ua) || isAndroidWebview(ua) || isOperaMini(ua) || isFirefoxIOS(ua) || isEdgeIOS(ua) || isFacebookWebView(ua) || isQQBrowser(ua) || isElectron() || isMacOsCna() || isStandAlone());
            }
            function isChrome(ua) {
                void 0 === ua && (ua = getUserAgent());
                return /Chrome|Chromium|CriOS/.test(ua) && !/SamsungBrowser|Silk|EdgA/.test(ua);
            }
            function isSafari(ua) {
                void 0 === ua && (ua = getUserAgent());
                return /Safari/.test(ua) && !isChrome(ua) && !/Silk|FxiOS|EdgiOS/.test(ua);
            }
            function isApplePaySupported() {
                try {
                    if (window.ApplePaySession && window.ApplePaySession.supportsVersion(3) && window.ApplePaySession.canMakePayments()) return !0;
                } catch (e) {
                    return !1;
                }
                return !1;
            }
            function isCrossSiteTrackingEnabled(expectedCookieKey) {
                return -1 === window.document.cookie.indexOf(expectedCookieKey);
            }
            function _setPrototypeOf(o, p) {
                return (_setPrototypeOf = Object.setPrototypeOf || function(o, p) {
                    o.__proto__ = p;
                    return o;
                })(o, p);
            }
            function _inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                _setPrototypeOf(subClass, superClass);
            }
            function _extends() {
                return (_extends = Object.assign || function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];
                        for (var key in source) ({}).hasOwnProperty.call(source, key) && (target[key] = source[key]);
                    }
                    return target;
                }).apply(this, arguments);
            }
            function utils_isPromise(item) {
                try {
                    if (!item) return !1;
                    if ("undefined" != typeof Promise && item instanceof Promise) return !0;
                    if ("undefined" != typeof window && "function" == typeof window.Window && item instanceof window.Window) return !1;
                    if ("undefined" != typeof window && "function" == typeof window.constructor && item instanceof window.constructor) return !1;
                    var _toString = {}.toString;
                    if (_toString) {
                        var name = _toString.call(item);
                        if ("[object Window]" === name || "[object global]" === name || "[object DOMWindow]" === name) return !1;
                    }
                    if ("function" == typeof item.then) return !0;
                } catch (err) {
                    return !1;
                }
                return !1;
            }
            var dispatchedErrors = [];
            var possiblyUnhandledPromiseHandlers = [];
            var activeCount = 0;
            var flushPromise;
            function flushActive() {
                if (!activeCount && flushPromise) {
                    var promise = flushPromise;
                    flushPromise = null;
                    promise.resolve();
                }
            }
            function startActive() {
                activeCount += 1;
            }
            function endActive() {
                activeCount -= 1;
                flushActive();
            }
            var promise_ZalgoPromise = function() {
                function ZalgoPromise(handler) {
                    var _this = this;
                    this.resolved = void 0;
                    this.rejected = void 0;
                    this.errorHandled = void 0;
                    this.value = void 0;
                    this.error = void 0;
                    this.handlers = void 0;
                    this.dispatching = void 0;
                    this.stack = void 0;
                    this.resolved = !1;
                    this.rejected = !1;
                    this.errorHandled = !1;
                    this.handlers = [];
                    if (handler) {
                        var _result;
                        var _error;
                        var resolved = !1;
                        var rejected = !1;
                        var isAsync = !1;
                        startActive();
                        try {
                            handler((function(res) {
                                if (isAsync) _this.resolve(res); else {
                                    resolved = !0;
                                    _result = res;
                                }
                            }), (function(err) {
                                if (isAsync) _this.reject(err); else {
                                    rejected = !0;
                                    _error = err;
                                }
                            }));
                        } catch (err) {
                            endActive();
                            this.reject(err);
                            return;
                        }
                        endActive();
                        isAsync = !0;
                        resolved ? this.resolve(_result) : rejected && this.reject(_error);
                    }
                }
                var _proto = ZalgoPromise.prototype;
                _proto.resolve = function(result) {
                    if (this.resolved || this.rejected) return this;
                    if (utils_isPromise(result)) throw new Error("Can not resolve promise with another promise");
                    this.resolved = !0;
                    this.value = result;
                    this.dispatch();
                    return this;
                };
                _proto.reject = function(error) {
                    var _this2 = this;
                    if (this.resolved || this.rejected) return this;
                    if (utils_isPromise(error)) throw new Error("Can not reject promise with another promise");
                    if (!error) {
                        var _err = error && "function" == typeof error.toString ? error.toString() : {}.toString.call(error);
                        error = new Error("Expected reject to be called with Error, got " + _err);
                    }
                    this.rejected = !0;
                    this.error = error;
                    this.errorHandled || setTimeout((function() {
                        _this2.errorHandled || function(err, promise) {
                            if (-1 === dispatchedErrors.indexOf(err)) {
                                dispatchedErrors.push(err);
                                setTimeout((function() {
                                    throw err;
                                }), 1);
                                for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);
                            }
                        }(error, _this2);
                    }), 1);
                    this.dispatch();
                    return this;
                };
                _proto.asyncReject = function(error) {
                    this.errorHandled = !0;
                    this.reject(error);
                    return this;
                };
                _proto.dispatch = function() {
                    var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;
                    if (!this.dispatching && (resolved || rejected)) {
                        this.dispatching = !0;
                        startActive();
                        var chain = function(firstPromise, secondPromise) {
                            return firstPromise.then((function(res) {
                                secondPromise.resolve(res);
                            }), (function(err) {
                                secondPromise.reject(err);
                            }));
                        };
                        for (var i = 0; i < handlers.length; i++) {
                            var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;
                            var _result2 = void 0;
                            if (resolved) try {
                                _result2 = onSuccess ? onSuccess(this.value) : this.value;
                            } catch (err) {
                                promise.reject(err);
                                continue;
                            } else if (rejected) {
                                if (!onError) {
                                    promise.reject(this.error);
                                    continue;
                                }
                                try {
                                    _result2 = onError(this.error);
                                } catch (err) {
                                    promise.reject(err);
                                    continue;
                                }
                            }
                            if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {
                                var promiseResult = _result2;
                                promiseResult.resolved ? promise.resolve(promiseResult.value) : promise.reject(promiseResult.error);
                                promiseResult.errorHandled = !0;
                            } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);
                        }
                        handlers.length = 0;
                        this.dispatching = !1;
                        endActive();
                    }
                };
                _proto.then = function(onSuccess, onError) {
                    if (onSuccess && "function" != typeof onSuccess && !onSuccess.call) throw new Error("Promise.then expected a function for success handler");
                    if (onError && "function" != typeof onError && !onError.call) throw new Error("Promise.then expected a function for error handler");
                    var promise = new ZalgoPromise;
                    this.handlers.push({
                        promise: promise,
                        onSuccess: onSuccess,
                        onError: onError
                    });
                    this.errorHandled = !0;
                    this.dispatch();
                    return promise;
                };
                _proto.catch = function(onError) {
                    return this.then(void 0, onError);
                };
                _proto.finally = function(onFinally) {
                    if (onFinally && "function" != typeof onFinally && !onFinally.call) throw new Error("Promise.finally expected a function");
                    return this.then((function(result) {
                        return ZalgoPromise.try(onFinally).then((function() {
                            return result;
                        }));
                    }), (function(err) {
                        return ZalgoPromise.try(onFinally).then((function() {
                            throw err;
                        }));
                    }));
                };
                _proto.timeout = function(time, err) {
                    var _this3 = this;
                    if (this.resolved || this.rejected) return this;
                    var timeout = setTimeout((function() {
                        _this3.resolved || _this3.rejected || _this3.reject(err || new Error("Promise timed out after " + time + "ms"));
                    }), time);
                    return this.then((function(result) {
                        clearTimeout(timeout);
                        return result;
                    }));
                };
                _proto.toPromise = function() {
                    if ("undefined" == typeof Promise) throw new TypeError("Could not find Promise");
                    return Promise.resolve(this);
                };
                _proto.lazy = function() {
                    this.errorHandled = !0;
                    return this;
                };
                ZalgoPromise.resolve = function(value) {
                    return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise((function(resolve, reject) {
                        return value.then(resolve, reject);
                    })) : (new ZalgoPromise).resolve(value);
                };
                ZalgoPromise.reject = function(error) {
                    return (new ZalgoPromise).reject(error);
                };
                ZalgoPromise.asyncReject = function(error) {
                    return (new ZalgoPromise).asyncReject(error);
                };
                ZalgoPromise.all = function(promises) {
                    var promise = new ZalgoPromise;
                    var count = promises.length;
                    var results = [].slice();
                    if (!count) {
                        promise.resolve(results);
                        return promise;
                    }
                    var chain = function(i, firstPromise, secondPromise) {
                        return firstPromise.then((function(res) {
                            results[i] = res;
                            0 == (count -= 1) && promise.resolve(results);
                        }), (function(err) {
                            secondPromise.reject(err);
                        }));
                    };
                    for (var i = 0; i < promises.length; i++) {
                        var prom = promises[i];
                        if (prom instanceof ZalgoPromise) {
                            if (prom.resolved) {
                                results[i] = prom.value;
                                count -= 1;
                                continue;
                            }
                        } else if (!utils_isPromise(prom)) {
                            results[i] = prom;
                            count -= 1;
                            continue;
                        }
                        chain(i, ZalgoPromise.resolve(prom), promise);
                    }
                    0 === count && promise.resolve(results);
                    return promise;
                };
                ZalgoPromise.hash = function(promises) {
                    var result = {};
                    var awaitPromises = [];
                    var _loop = function(key) {
                        if (promises.hasOwnProperty(key)) {
                            var value = promises[key];
                            utils_isPromise(value) ? awaitPromises.push(value.then((function(res) {
                                result[key] = res;
                            }))) : result[key] = value;
                        }
                    };
                    for (var key in promises) _loop(key);
                    return ZalgoPromise.all(awaitPromises).then((function() {
                        return result;
                    }));
                };
                ZalgoPromise.map = function(items, method) {
                    return ZalgoPromise.all(items.map(method));
                };
                ZalgoPromise.onPossiblyUnhandledException = function(handler) {
                    return function(handler) {
                        possiblyUnhandledPromiseHandlers.push(handler);
                        return {
                            cancel: function() {
                                possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);
                            }
                        };
                    }(handler);
                };
                ZalgoPromise.try = function(method, context, args) {
                    if (method && "function" != typeof method && !method.call) throw new Error("Promise.try expected a function");
                    var result;
                    startActive();
                    try {
                        result = method.apply(context, args || []);
                    } catch (err) {
                        endActive();
                        return ZalgoPromise.reject(err);
                    }
                    endActive();
                    return ZalgoPromise.resolve(result);
                };
                ZalgoPromise.delay = function(_delay) {
                    return new ZalgoPromise((function(resolve) {
                        setTimeout(resolve, _delay);
                    }));
                };
                ZalgoPromise.isPromise = function(value) {
                    return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);
                };
                ZalgoPromise.flush = function() {
                    return function(Zalgo) {
                        var promise = flushPromise = flushPromise || new Zalgo;
                        flushActive();
                        return promise;
                    }(ZalgoPromise);
                };
                return ZalgoPromise;
            }();
            var IE_WIN_ACCESS_ERROR = "Call was rejected by callee.\r\n";
            function getActualProtocol(win) {
                void 0 === win && (win = window);
                return win.location.protocol;
            }
            function getProtocol(win) {
                void 0 === win && (win = window);
                if (win.mockDomain) {
                    var protocol = win.mockDomain.split("//")[0];
                    if (protocol) return protocol;
                }
                return getActualProtocol(win);
            }
            function isAboutProtocol(win) {
                void 0 === win && (win = window);
                return "about:" === getProtocol(win);
            }
            function canReadFromWindow(win) {
                try {
                    return !0;
                } catch (err) {}
                return !1;
            }
            function getActualDomain(win) {
                void 0 === win && (win = window);
                var location = win.location;
                if (!location) throw new Error("Can not read window location");
                var protocol = getActualProtocol(win);
                if (!protocol) throw new Error("Can not read window protocol");
                if ("file:" === protocol) return "file://";
                if ("about:" === protocol) {
                    var parent = function(win) {
                        void 0 === win && (win = window);
                        if (win) try {
                            if (win.parent && win.parent !== win) return win.parent;
                        } catch (err) {}
                    }(win);
                    return parent && canReadFromWindow() ? getActualDomain(parent) : "about://";
                }
                var host = location.host;
                if (!host) throw new Error("Can not read window host");
                return protocol + "//" + host;
            }
            function getDomain(win) {
                void 0 === win && (win = window);
                var domain = getActualDomain(win);
                return domain && win.mockDomain && 0 === win.mockDomain.indexOf("mock:") ? win.mockDomain : domain;
            }
            function isSameDomain(win) {
                if (!function(win) {
                    try {
                        if (win === window) return !0;
                    } catch (err) {}
                    try {
                        var desc = Object.getOwnPropertyDescriptor(win, "location");
                        if (desc && !1 === desc.enumerable) return !1;
                    } catch (err) {}
                    try {
                        if (isAboutProtocol(win) && canReadFromWindow()) return !0;
                    } catch (err) {}
                    try {
                        if (function(win) {
                            void 0 === win && (win = window);
                            return "mock:" === getProtocol(win);
                        }(win) && canReadFromWindow()) return !0;
                    } catch (err) {}
                    try {
                        if (getActualDomain(win) === getActualDomain(window)) return !0;
                    } catch (err) {}
                    return !1;
                }(win)) return !1;
                try {
                    if (win === window) return !0;
                    if (isAboutProtocol(win) && canReadFromWindow()) return !0;
                    if (getDomain(window) === getDomain(win)) return !0;
                } catch (err) {}
                return !1;
            }
            var iframeWindows = [];
            var iframeFrames = [];
            function isWindowClosed(win, allowMock) {
                void 0 === allowMock && (allowMock = !0);
                try {
                    if (win === window) return !1;
                } catch (err) {
                    return !0;
                }
                try {
                    if (!win) return !0;
                } catch (err) {
                    return !0;
                }
                try {
                    if (win.closed) return !0;
                } catch (err) {
                    return !err || err.message !== IE_WIN_ACCESS_ERROR;
                }
                if (allowMock && isSameDomain(win)) try {
                    if (win.mockclosed) return !0;
                } catch (err) {}
                try {
                    if (!win.parent || !win.top) return !0;
                } catch (err) {}
                var iframeIndex = function(collection, item) {
                    for (var i = 0; i < collection.length; i++) try {
                        if (collection[i] === item) return i;
                    } catch (err) {}
                    return -1;
                }(iframeWindows, win);
                if (-1 !== iframeIndex) {
                    var frame = iframeFrames[iframeIndex];
                    if (frame && function(frame) {
                        if (!frame.contentWindow) return !0;
                        if (!frame.parentNode) return !0;
                        var doc = frame.ownerDocument;
                        if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {
                            var parent = frame;
                            for (;parent.parentNode && parent.parentNode !== parent; ) parent = parent.parentNode;
                            if (!parent.host || !doc.documentElement.contains(parent.host)) return !0;
                        }
                        return !1;
                    }(frame)) return !0;
                }
                return !1;
            }
            function isWindow(obj) {
                try {
                    if (obj === window) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if ("[object Window]" === {}.toString.call(obj)) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if (window.Window && obj instanceof window.Window) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if (obj && obj.self === obj) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if (obj && obj.parent === obj) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if (obj && obj.top === obj) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if (obj && "__unlikely_value__" === obj.__cross_domain_utils_window_check__) return !1;
                } catch (err) {
                    return !0;
                }
                try {
                    if ("postMessage" in obj && "self" in obj && "location" in obj) return !0;
                } catch (err) {}
                return !1;
            }
            function util_safeIndexOf(collection, item) {
                for (var i = 0; i < collection.length; i++) try {
                    if (collection[i] === item) return i;
                } catch (err) {}
                return -1;
            }
            var weakmap_CrossDomainSafeWeakMap = function() {
                function CrossDomainSafeWeakMap() {
                    this.name = void 0;
                    this.weakmap = void 0;
                    this.keys = void 0;
                    this.values = void 0;
                    this.name = "__weakmap_" + (1e9 * Math.random() >>> 0) + "__";
                    if (function() {
                        if ("undefined" == typeof WeakMap) return !1;
                        if (void 0 === Object.freeze) return !1;
                        try {
                            var testWeakMap = new WeakMap;
                            var testKey = {};
                            Object.freeze(testKey);
                            testWeakMap.set(testKey, "__testvalue__");
                            return "__testvalue__" === testWeakMap.get(testKey);
                        } catch (err) {
                            return !1;
                        }
                    }()) try {
                        this.weakmap = new WeakMap;
                    } catch (err) {}
                    this.keys = [];
                    this.values = [];
                }
                var _proto = CrossDomainSafeWeakMap.prototype;
                _proto._cleanupClosedWindows = function() {
                    var weakmap = this.weakmap;
                    var keys = this.keys;
                    for (var i = 0; i < keys.length; i++) {
                        var value = keys[i];
                        if (isWindow(value) && isWindowClosed(value)) {
                            if (weakmap) try {
                                weakmap.delete(value);
                            } catch (err) {}
                            keys.splice(i, 1);
                            this.values.splice(i, 1);
                            i -= 1;
                        }
                    }
                };
                _proto.isSafeToReadWrite = function(key) {
                    return !isWindow(key);
                };
                _proto.set = function(key, value) {
                    if (!key) throw new Error("WeakMap expected key");
                    var weakmap = this.weakmap;
                    if (weakmap) try {
                        weakmap.set(key, value);
                    } catch (err) {
                        delete this.weakmap;
                    }
                    if (this.isSafeToReadWrite(key)) try {
                        var name = this.name;
                        var entry = key[name];
                        entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {
                            value: [ key, value ],
                            writable: !0
                        });
                        return;
                    } catch (err) {}
                    this._cleanupClosedWindows();
                    var keys = this.keys;
                    var values = this.values;
                    var index = util_safeIndexOf(keys, key);
                    if (-1 === index) {
                        keys.push(key);
                        values.push(value);
                    } else values[index] = value;
                };
                _proto.get = function(key) {
                    if (!key) throw new Error("WeakMap expected key");
                    var weakmap = this.weakmap;
                    if (weakmap) try {
                        if (weakmap.has(key)) return weakmap.get(key);
                    } catch (err) {
                        delete this.weakmap;
                    }
                    if (this.isSafeToReadWrite(key)) try {
                        var entry = key[this.name];
                        return entry && entry[0] === key ? entry[1] : void 0;
                    } catch (err) {}
                    this._cleanupClosedWindows();
                    var index = util_safeIndexOf(this.keys, key);
                    if (-1 !== index) return this.values[index];
                };
                _proto.delete = function(key) {
                    if (!key) throw new Error("WeakMap expected key");
                    var weakmap = this.weakmap;
                    if (weakmap) try {
                        weakmap.delete(key);
                    } catch (err) {
                        delete this.weakmap;
                    }
                    if (this.isSafeToReadWrite(key)) try {
                        var entry = key[this.name];
                        entry && entry[0] === key && (entry[0] = entry[1] = void 0);
                    } catch (err) {}
                    this._cleanupClosedWindows();
                    var keys = this.keys;
                    var index = util_safeIndexOf(keys, key);
                    if (-1 !== index) {
                        keys.splice(index, 1);
                        this.values.splice(index, 1);
                    }
                };
                _proto.has = function(key) {
                    if (!key) throw new Error("WeakMap expected key");
                    var weakmap = this.weakmap;
                    if (weakmap) try {
                        if (weakmap.has(key)) return !0;
                    } catch (err) {
                        delete this.weakmap;
                    }
                    if (this.isSafeToReadWrite(key)) try {
                        var entry = key[this.name];
                        return !(!entry || entry[0] !== key);
                    } catch (err) {}
                    this._cleanupClosedWindows();
                    return -1 !== util_safeIndexOf(this.keys, key);
                };
                _proto.getOrSet = function(key, getter) {
                    if (this.has(key)) return this.get(key);
                    var value = getter();
                    this.set(key, value);
                    return value;
                };
                return CrossDomainSafeWeakMap;
            }();
            function _getPrototypeOf(o) {
                return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                    return o.__proto__ || Object.getPrototypeOf(o);
                })(o);
            }
            function _isNativeReflectConstruct() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    Date.prototype.toString.call(Reflect.construct(Date, [], (function() {})));
                    return !0;
                } catch (e) {
                    return !1;
                }
            }
            function construct_construct(Parent, args, Class) {
                return (construct_construct = _isNativeReflectConstruct() ? Reflect.construct : function(Parent, args, Class) {
                    var a = [ null ];
                    a.push.apply(a, args);
                    var instance = new (Function.bind.apply(Parent, a));
                    Class && _setPrototypeOf(instance, Class.prototype);
                    return instance;
                }).apply(null, arguments);
            }
            function wrapNativeSuper_wrapNativeSuper(Class) {
                var _cache = "function" == typeof Map ? new Map : void 0;
                return (wrapNativeSuper_wrapNativeSuper = function(Class) {
                    if (null === Class || !(fn = Class, -1 !== Function.toString.call(fn).indexOf("[native code]"))) return Class;
                    var fn;
                    if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                    if (void 0 !== _cache) {
                        if (_cache.has(Class)) return _cache.get(Class);
                        _cache.set(Class, Wrapper);
                    }
                    function Wrapper() {
                        return construct_construct(Class, arguments, _getPrototypeOf(this).constructor);
                    }
                    Wrapper.prototype = Object.create(Class.prototype, {
                        constructor: {
                            value: Wrapper,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    });
                    return _setPrototypeOf(Wrapper, Class);
                })(Class);
            }
            var KEY_CODES = {
                ENTER: 13,
                SPACE: 32
            };
            var ATTRIBUTES = {
                UID: "data-uid"
            };
            var UID_HASH_LENGTH = 30;
            var invalidProtocolRegex = /([^\w]*)(javascript|data|vbscript)/im;
            var htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
            var htmlCtrlEntityRegex = /&(newline|tab);/gi;
            var ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
            var urlSchemeRegex = /^.+(:|&colon;)/gim;
            var relativeFirstCharacters = [ ".", "/" ];
            var BLANK_URL = "about:blank";
            function isElement(element) {
                var passed = !1;
                try {
                    (element instanceof window.Element || null !== element && "object" == typeof element && 1 === element.nodeType && "object" == typeof element.style && "object" == typeof element.ownerDocument) && (passed = !0);
                } catch (_) {}
                return passed;
            }
            function getFunctionName(fn) {
                return fn.name || fn.__name__ || fn.displayName || "anonymous";
            }
            function setFunctionName(fn, name) {
                try {
                    delete fn.name;
                    fn.name = name;
                } catch (err) {}
                fn.__name__ = fn.displayName = name;
                return fn;
            }
            function base64encode(str) {
                if ("function" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (function(m, p1) {
                    return String.fromCharCode(parseInt(p1, 16));
                }))).replace(/[=]/g, "");
                if ("undefined" != typeof Buffer) return Buffer.from(str, "utf8").toString("base64").replace(/[=]/g, "");
                throw new Error("Can not find window.btoa or Buffer");
            }
            function base64decode(str) {
                if ("function" == typeof atob) return decodeURIComponent([].map.call(atob(str), (function(c) {
                    return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
                })).join(""));
                if ("undefined" != typeof Buffer) return Buffer.from(str, "base64").toString("utf8");
                throw new Error("Can not find window.atob or Buffer");
            }
            function uniqueID() {
                var chars = "0123456789abcdef";
                return "uid_" + "xxxxxxxxxx".replace(/./g, (function() {
                    return chars.charAt(Math.floor(Math.random() * chars.length));
                })) + "_" + base64encode((new Date).toISOString().slice(11, 19).replace("T", ".")).replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
            }
            function getGlobal() {
                if ("undefined" != typeof window) return window;
                if ("undefined" != typeof window) return window;
                if ("undefined" != typeof window) return window;
                throw new Error("No global found");
            }
            var objectIDs;
            function getObjectID(obj) {
                objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap;
                if (null == obj || "object" != typeof obj && "function" != typeof obj) throw new Error("Invalid object");
                var uid = objectIDs.get(obj);
                if (!uid) {
                    uid = typeof obj + ":" + uniqueID();
                    objectIDs.set(obj, uid);
                }
                return uid;
            }
            function serializeArgs(args) {
                try {
                    return JSON.stringify([].slice.call(args), (function(subkey, val) {
                        return "function" == typeof val ? "memoize[" + getObjectID(val) + "]" : isElement(val) ? {} : val;
                    }));
                } catch (err) {
                    throw new Error("Arguments not serializable -- can not be used to memoize");
                }
            }
            function getEmptyObject() {
                return {};
            }
            var memoizeGlobalIndex = 0;
            var memoizeGlobalIndexValidFrom = 0;
            function memoize(method, options) {
                void 0 === options && (options = {});
                var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;
                var simpleCache;
                var thisCache;
                var memoizeIndex = memoizeGlobalIndex;
                memoizeGlobalIndex += 1;
                var memoizedFunction = function() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    if (memoizeIndex < memoizeGlobalIndexValidFrom) {
                        simpleCache = null;
                        thisCache = null;
                        memoizeIndex = memoizeGlobalIndex;
                        memoizeGlobalIndex += 1;
                    }
                    var cache;
                    cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};
                    var cacheKey;
                    try {
                        cacheKey = serializeArgs(args);
                    } catch (_unused) {
                        return method.apply(this, arguments);
                    }
                    var cacheResult = cache[cacheKey];
                    if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {
                        delete cache[cacheKey];
                        cacheResult = null;
                    }
                    if (cacheResult) return cacheResult.value;
                    var time = Date.now();
                    var value = method.apply(this, arguments);
                    cache[cacheKey] = {
                        time: time,
                        value: value
                    };
                    return value;
                };
                memoizedFunction.reset = function() {
                    simpleCache = null;
                    thisCache = null;
                };
                return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + "::memoized");
            }
            memoize.clear = function() {
                memoizeGlobalIndexValidFrom = memoizeGlobalIndex;
            };
            function promiseIdentity(item) {
                return promise_ZalgoPromise.resolve(item);
            }
            function memoizePromise(method) {
                var cache = {};
                function memoizedPromiseFunction() {
                    var _arguments = arguments, _this = this;
                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                    var key = serializeArgs(args);
                    if (cache.hasOwnProperty(key)) return cache[key];
                    cache[key] = promise_ZalgoPromise.try((function() {
                        return method.apply(_this, _arguments);
                    })).finally((function() {
                        delete cache[key];
                    }));
                    return cache[key];
                }
                memoizedPromiseFunction.reset = function() {
                    cache = {};
                };
                return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + "::promiseMemoized");
            }
            function promisify(method, options) {
                void 0 === options && (options = {});
                function promisifiedFunction() {
                    return promise_ZalgoPromise.try(method, this, arguments);
                }
                options.name && (promisifiedFunction.displayName = options.name + ":promisified");
                return setFunctionName(promisifiedFunction, getFunctionName(method) + "::promisified");
            }
            function inlineMemoize(method, logic, args) {
                void 0 === args && (args = []);
                var cache = method.__inline_memoize_cache__ = method.__inline_memoize_cache__ || {};
                var key = serializeArgs(args);
                return cache.hasOwnProperty(key) ? cache[key] : cache[key] = logic.apply(void 0, args);
            }
            function src_util_noop() {}
            function once(method) {
                var called = !1;
                return setFunctionName((function() {
                    if (!called) {
                        called = !0;
                        return method.apply(this, arguments);
                    }
                }), getFunctionName(method) + "::once");
            }
            function hashStr(str) {
                var hash = 0;
                for (var i = 0; i < str.length; i++) hash += str[i].charCodeAt(0) * Math.pow(i % 10 + 1, 5);
                return Math.floor(Math.pow(Math.sqrt(hash), 5));
            }
            function strHashStr(str) {
                var hash = "";
                for (var i = 0; i < str.length; i++) {
                    var total = str[i].charCodeAt(0) * i;
                    str[i + 1] && (total += str[i + 1].charCodeAt(0) * (i - 1));
                    hash += String.fromCharCode(97 + Math.abs(total) % 26);
                }
                return hash;
            }
            function match(str, pattern) {
                var regmatch = str.match(pattern);
                if (regmatch) return regmatch[1];
            }
            function awaitKey(obj, key) {
                return new promise_ZalgoPromise((function(resolve) {
                    var value = obj[key];
                    if (value) return resolve(value);
                    delete obj[key];
                    Object.defineProperty(obj, key, {
                        configurable: !0,
                        set: function(item) {
                            (value = item) && resolve(value);
                        },
                        get: function() {
                            return value;
                        }
                    });
                }));
            }
            function stringifyError(err, level) {
                void 0 === level && (level = 1);
                if (level >= 3) return "stringifyError stack overflow";
                try {
                    if (!err) return "<unknown error: " + {}.toString.call(err) + ">";
                    if ("string" == typeof err) return err;
                    if (err instanceof Error) {
                        var stack = err && err.stack;
                        var message = err && err.message;
                        if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + "\n" + stack;
                        if (stack) return stack;
                        if (message) return message;
                    }
                    return err && err.toString && "function" == typeof err.toString ? err.toString() : {}.toString.call(err);
                } catch (newErr) {
                    return "Error while stringifying error: " + stringifyError(newErr, level + 1);
                }
            }
            function stringifyErrorMessage(err) {
                var defaultMessage = "<unknown error: " + {}.toString.call(err) + ">";
                return err ? err instanceof Error ? err.message || defaultMessage : "string" == typeof err.message && err.message || defaultMessage : defaultMessage;
            }
            function stringify(item) {
                return "string" == typeof item ? item : item && item.toString && "function" == typeof item.toString ? item.toString() : {}.toString.call(item);
            }
            function domainMatches(hostname, domain) {
                var index = (hostname = hostname.split("://")[1]).indexOf(domain);
                return -1 !== index && hostname.slice(index) === domain;
            }
            function patchMethod(obj, name, handler) {
                var original = obj[name];
                obj[name] = function() {
                    var _arguments2 = arguments, _this2 = this;
                    return handler({
                        context: this,
                        args: [].slice.call(arguments),
                        original: original,
                        callOriginal: function() {
                            return original.apply(_this2, _arguments2);
                        }
                    });
                };
            }
            function extend(obj, source) {
                if (!source) return obj;
                if (Object.assign) return Object.assign(obj, source);
                for (var key in source) source.hasOwnProperty(key) && (obj[key] = source[key]);
                return obj;
            }
            function util_values(obj) {
                if (Object.values) return Object.values(obj);
                var result = [];
                for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);
                return result;
            }
            var memoizedValues = memoize(util_values);
            function perc(pixels, percentage) {
                return Math.round(pixels * percentage / 100);
            }
            function min() {
                return Math.min.apply(Math, arguments);
            }
            function max() {
                return Math.max.apply(Math, arguments);
            }
            function roundUp(num, nearest) {
                var remainder = num % nearest;
                return remainder ? num - remainder + nearest : num;
            }
            function regexMap(str, regexp, handler) {
                var results = [];
                str.replace(regexp, (function(item) {
                    results.push(handler ? handler.apply(null, arguments) : item);
                }));
                return results;
            }
            function svgToBase64(svg) {
                return "data:image/svg+xml;base64," + base64encode(svg);
            }
            function objFilter(obj, filter) {
                void 0 === filter && (filter = Boolean);
                var result = {};
                for (var key in obj) obj.hasOwnProperty(key) && filter(obj[key], key) && (result[key] = obj[key]);
                return result;
            }
            function identity(item) {
                return item;
            }
            function regexTokenize(text, regexp) {
                var result = [];
                text.replace(regexp, (function(token) {
                    result.push(token);
                    return "";
                }));
                return result;
            }
            function promiseDebounce(method, delay) {
                void 0 === delay && (delay = 50);
                var promise;
                var timeout;
                return setFunctionName((function() {
                    timeout && clearTimeout(timeout);
                    var localPromise = promise = promise || new promise_ZalgoPromise;
                    timeout = setTimeout((function() {
                        promise = null;
                        timeout = null;
                        promise_ZalgoPromise.try(method).then((function(result) {
                            localPromise.resolve(result);
                        }), (function(err) {
                            localPromise.reject(err);
                        }));
                    }), delay);
                    return localPromise;
                }), getFunctionName(method) + "::promiseDebounced");
            }
            function safeInterval(method, time) {
                var timeout;
                !function loop() {
                    timeout = setTimeout((function() {
                        method();
                        loop();
                    }), time);
                }();
                return {
                    cancel: function() {
                        clearTimeout(timeout);
                    }
                };
            }
            function isInteger(str) {
                return Boolean(str.match(/^[0-9]+$/));
            }
            function isFloat(str) {
                return Boolean(str.match(/^[0-9]+\.[0-9]+$/));
            }
            function serializePrimitive(value) {
                return value.toString();
            }
            function deserializePrimitive(value) {
                return "true" === value || "false" !== value && (isInteger(value) ? parseInt(value, 10) : isFloat(value) ? parseFloat(value) : value);
            }
            function dotify(obj, prefix, newobj) {
                void 0 === prefix && (prefix = "");
                void 0 === newobj && (newobj = {});
                prefix = prefix ? prefix + "." : prefix;
                for (var key in obj) obj.hasOwnProperty(key) && null != obj[key] && "function" != typeof obj[key] && (obj[key] && Array.isArray(obj[key]) && obj[key].length && obj[key].every((function(val) {
                    return "object" != typeof val;
                })) ? newobj["" + prefix + key + "[]"] = obj[key].join(",") : obj[key] && "object" == typeof obj[key] ? newobj = dotify(obj[key], "" + prefix + key, newobj) : newobj["" + prefix + key] = serializePrimitive(obj[key]));
                return newobj;
            }
            function undotify(obj) {
                var result = {};
                for (var key in obj) if (obj.hasOwnProperty(key) && "string" == typeof obj[key]) {
                    var value = obj[key];
                    if (key.match(/^.+\[\]$/)) {
                        key = key.slice(0, -2);
                        value = value.split(",").map(deserializePrimitive);
                    } else value = deserializePrimitive(value);
                    var keyResult = result;
                    var parts = key.split(".");
                    for (var i = 0; i < parts.length; i++) {
                        var part = parts[i];
                        var isLast = i + 1 === parts.length;
                        var isIndex = !isLast && isInteger(parts[i + 1]);
                        if ("constructor" === part || "prototype" === part || "__proto__" === part) throw new Error("Disallowed key: " + part);
                        isLast ? keyResult[part] = value : keyResult = keyResult[part] = keyResult[part] || (isIndex ? [] : {});
                    }
                }
                return result;
            }
            function eventEmitter() {
                var triggered = {};
                var handlers = {};
                var emitter = {
                    on: function(eventName, handler) {
                        var handlerList = handlers[eventName] = handlers[eventName] || [];
                        handlerList.push(handler);
                        var cancelled = !1;
                        return {
                            cancel: function() {
                                if (!cancelled) {
                                    cancelled = !0;
                                    handlerList.splice(handlerList.indexOf(handler), 1);
                                }
                            }
                        };
                    },
                    once: function(eventName, handler) {
                        var listener = emitter.on(eventName, (function() {
                            listener.cancel();
                            handler();
                        }));
                        return listener;
                    },
                    trigger: function(eventName) {
                        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) args[_key3 - 1] = arguments[_key3];
                        var handlerList = handlers[eventName];
                        var promises = [];
                        if (handlerList) {
                            var _loop = function() {
                                var handler = handlerList[_i2];
                                promises.push(promise_ZalgoPromise.try((function() {
                                    return handler.apply(void 0, args);
                                })));
                            };
                            for (var _i2 = 0; _i2 < handlerList.length; _i2++) _loop();
                        }
                        return promise_ZalgoPromise.all(promises).then(src_util_noop);
                    },
                    triggerOnce: function(eventName) {
                        if (triggered[eventName]) return promise_ZalgoPromise.resolve();
                        triggered[eventName] = !0;
                        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) args[_key4 - 1] = arguments[_key4];
                        return emitter.trigger.apply(emitter, [ eventName ].concat(args));
                    },
                    reset: function() {
                        handlers = {};
                    }
                };
                return emitter;
            }
            function camelToDasherize(string) {
                return string.replace(/([A-Z])/g, (function(g) {
                    return "-" + g.toLowerCase();
                }));
            }
            function dasherizeToCamel(string) {
                return string.replace(/-([a-z])/g, (function(g) {
                    return g[1].toUpperCase();
                }));
            }
            function capitalizeFirstLetter(string) {
                return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
            }
            function util_get(item, path, def) {
                if (!path) return def;
                var pathParts = path.split(".");
                for (var i = 0; i < pathParts.length; i++) {
                    if ("object" != typeof item || null === item) return def;
                    item = item[pathParts[i]];
                }
                return void 0 === item ? def : item;
            }
            function safeTimeout(method, time) {
                var interval = safeInterval((function() {
                    if ((time -= 100) <= 0) {
                        interval.cancel();
                        method();
                    }
                }), 100);
            }
            function defineLazyProp(obj, key, getter) {
                if (Array.isArray(obj)) {
                    if ("number" != typeof key) throw new TypeError("Array key must be number");
                } else if ("object" == typeof obj && null !== obj && "string" != typeof key) throw new TypeError("Object key must be string");
                Object.defineProperty(obj, key, {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        delete obj[key];
                        var value = getter();
                        obj[key] = value;
                        return value;
                    },
                    set: function(value) {
                        delete obj[key];
                        obj[key] = value;
                    }
                });
            }
            function arrayFrom(item) {
                return [].slice.call(item);
            }
            function isObject(item) {
                return "object" == typeof item && null !== item;
            }
            function isObjectObject(obj) {
                return isObject(obj) && "[object Object]" === {}.toString.call(obj);
            }
            function isPlainObject(obj) {
                if (!isObjectObject(obj)) return !1;
                var constructor = obj.constructor;
                if ("function" != typeof constructor) return !1;
                var prototype = constructor.prototype;
                return !!isObjectObject(prototype) && !!prototype.hasOwnProperty("isPrototypeOf");
            }
            function replaceObject(item, replacer, fullKey) {
                void 0 === fullKey && (fullKey = "");
                if (Array.isArray(item)) {
                    var length = item.length;
                    var result = [];
                    var _loop2 = function(i) {
                        defineLazyProp(result, i, (function() {
                            var itemKey = fullKey ? fullKey + "." + i : "" + i;
                            var child = replacer(item[i], i, itemKey);
                            (isPlainObject(child) || Array.isArray(child)) && (child = replaceObject(child, replacer, itemKey));
                            return child;
                        }));
                    };
                    for (var i = 0; i < length; i++) _loop2(i);
                    return result;
                }
                if (isPlainObject(item)) {
                    var _result = {};
                    var _loop3 = function(key) {
                        if (!item.hasOwnProperty(key)) return 1;
                        defineLazyProp(_result, key, (function() {
                            var itemKey = fullKey ? fullKey + "." + key : "" + key;
                            var child = replacer(item[key], key, itemKey);
                            (isPlainObject(child) || Array.isArray(child)) && (child = replaceObject(child, replacer, itemKey));
                            return child;
                        }));
                    };
                    for (var key in item) _loop3(key);
                    return _result;
                }
                throw new Error("Pass an object or array");
            }
            function copyProp(source, target, name, def) {
                if (source.hasOwnProperty(name)) {
                    var descriptor = Object.getOwnPropertyDescriptor(source, name);
                    Object.defineProperty(target, name, descriptor);
                } else target[name] = def;
            }
            function regex(pattern, string, start) {
                void 0 === start && (start = 0);
                "string" == typeof pattern && (pattern = new RegExp(pattern));
                var result = string.slice(start).match(pattern);
                if (result) {
                    var index = result.index;
                    var regmatch = result[0];
                    return {
                        text: regmatch,
                        groups: result.slice(1),
                        start: start + index,
                        end: start + index + regmatch.length,
                        length: regmatch.length,
                        replace: function(text) {
                            return regmatch ? "" + regmatch.slice(0, start + index) + text + regmatch.slice(index + regmatch.length) : "";
                        }
                    };
                }
            }
            function regexAll(pattern, string) {
                var matches = [];
                var start = 0;
                for (;;) {
                    var regmatch = regex(pattern, string, start);
                    if (!regmatch) break;
                    matches.push(regmatch);
                    start = match.end;
                }
                return matches;
            }
            function isDefined(value) {
                return null != value;
            }
            function cycle(method) {
                return promise_ZalgoPromise.try(method).then((function() {
                    return cycle(method);
                }));
            }
            function debounce(method, time) {
                void 0 === time && (time = 100);
                var timeout;
                return setFunctionName((function() {
                    var _arguments3 = arguments, _this3 = this;
                    clearTimeout(timeout);
                    timeout = setTimeout((function() {
                        return method.apply(_this3, _arguments3);
                    }), time);
                }), getFunctionName(method) + "::debounced");
            }
            function util_isRegex(item) {
                return "[object RegExp]" === {}.toString.call(item);
            }
            var util_weakMapMemoize = function(method) {
                var weakmap = new weakmap_CrossDomainSafeWeakMap;
                return function(arg) {
                    var _this4 = this;
                    return weakmap.getOrSet(arg, (function() {
                        return method.call(_this4, arg);
                    }));
                };
            };
            var util_weakMapMemoizePromise = function(method) {
                var weakmap = new weakmap_CrossDomainSafeWeakMap;
                return function(arg) {
                    var _this5 = this;
                    return weakmap.getOrSet(arg, (function() {
                        return method.call(_this5, arg).finally((function() {
                            weakmap.delete(arg);
                        }));
                    }));
                };
            };
            function getOrSet(obj, key, getter) {
                if (obj.hasOwnProperty(key)) return obj[key];
                var val = getter();
                obj[key] = val;
                return val;
            }
            function cleanup(obj) {
                var tasks = [];
                var cleaned = !1;
                var cleanErr;
                var cleaner = {
                    set: function(name, item) {
                        if (!cleaned) {
                            obj[name] = item;
                            cleaner.register((function() {
                                delete obj[name];
                            }));
                        }
                        return item;
                    },
                    register: function(method) {
                        var task = once((function() {
                            return method(cleanErr);
                        }));
                        cleaned ? method(cleanErr) : tasks.push(task);
                        return {
                            cancel: function() {
                                var index = tasks.indexOf(task);
                                -1 !== index && tasks.splice(index, 1);
                            }
                        };
                    },
                    all: function(err) {
                        cleanErr = err;
                        var results = [];
                        cleaned = !0;
                        for (;tasks.length; ) {
                            var task = tasks.shift();
                            results.push(task());
                        }
                        return promise_ZalgoPromise.all(results).then(src_util_noop);
                    }
                };
                return cleaner;
            }
            function tryCatch(fn) {
                var result;
                var error;
                try {
                    result = fn();
                } catch (err) {
                    error = err;
                }
                return {
                    result: result,
                    error: error
                };
            }
            function removeFromArray(arr, item) {
                var index = arr.indexOf(item);
                -1 !== index && arr.splice(index, 1);
            }
            function assertExists(name, thing) {
                if (null == thing) throw new Error("Expected " + name + " to be present");
                return thing;
            }
            function unique(arr) {
                var result = {};
                for (var _i4 = 0; _i4 < arr.length; _i4++) result[arr[_i4]] = !0;
                return Object.keys(result);
            }
            var constHas = function(constant, value) {
                return -1 !== memoizedValues(constant).indexOf(value);
            };
            function dedupeErrors(handler) {
                var seenErrors = [];
                var seenStringifiedErrors = {};
                return function(err) {
                    if (-1 === seenErrors.indexOf(err)) {
                        seenErrors.push(err);
                        var stringifiedError = stringifyError(err);
                        if (!seenStringifiedErrors[stringifiedError]) {
                            seenStringifiedErrors[stringifiedError] = !0;
                            return handler(err);
                        }
                    }
                };
            }
            var util_ExtendableError = function(_Error) {
                _inheritsLoose(ExtendableError, _Error);
                function ExtendableError(message) {
                    var _this6;
                    (_this6 = _Error.call(this, message) || this).name = _this6.constructor.name;
                    "function" == typeof Error.captureStackTrace ? Error.captureStackTrace(function(self) {
                        if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return self;
                    }(_this6), _this6.constructor) : _this6.stack = new Error(message).stack;
                    return _this6;
                }
                return ExtendableError;
            }(wrapNativeSuper_wrapNativeSuper(Error));
            function sanitizeUrl(url) {
                if (!url) return BLANK_URL;
                var sanitizedUrl = (str = url, str.replace(ctrlCharactersRegex, "").replace(htmlEntitiesRegex, (function(matchRegex, dec) {
                    return String.fromCharCode(dec);
                }))).replace(htmlCtrlEntityRegex, "").replace(ctrlCharactersRegex, "").trim();
                var str;
                if (!sanitizedUrl) return BLANK_URL;
                if (function(url) {
                    return relativeFirstCharacters.indexOf(url[0]) > -1;
                }(sanitizedUrl)) return sanitizedUrl;
                var urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);
                return urlSchemeParseResults && invalidProtocolRegex.test(urlSchemeParseResults[0]) ? BLANK_URL : sanitizedUrl;
            }
            function getBody() {
                var body = document.body;
                if (!body) throw new Error("Body element not found");
                return body;
            }
            function isDocumentReady() {
                return Boolean(document.body) && "complete" === document.readyState;
            }
            function isDocumentInteractive() {
                return Boolean(document.body) && "interactive" === document.readyState;
            }
            function urlEncode(str) {
                return encodeURIComponent(str);
            }
            function waitForWindowReady() {
                return inlineMemoize(waitForWindowReady, (function() {
                    return new promise_ZalgoPromise((function(resolve) {
                        isDocumentReady() && resolve();
                        window.addEventListener("load", (function() {
                            return resolve();
                        }));
                    }));
                }));
            }
            var waitForDocumentReady = memoize((function() {
                return new promise_ZalgoPromise((function(resolve) {
                    if (isDocumentReady() || isDocumentInteractive()) return resolve();
                    var interval = setInterval((function() {
                        if (isDocumentReady() || isDocumentInteractive()) {
                            clearInterval(interval);
                            return resolve();
                        }
                    }), 10);
                }));
            }));
            function waitForDocumentBody() {
                return promise_ZalgoPromise.try((function() {
                    return document.body ? document.body : waitForDocumentReady().then((function() {
                        if (document.body) return document.body;
                        throw new Error("Document ready but document.body not present");
                    }));
                }));
            }
            function parseQuery(queryString) {
                return inlineMemoize(parseQuery, (function() {
                    var params = {};
                    if (!queryString) return params;
                    if (-1 === queryString.indexOf("=")) return params;
                    for (var _i2 = 0, _queryString$split2 = queryString.split("&"); _i2 < _queryString$split2.length; _i2++) {
                        var pair = _queryString$split2[_i2];
                        (pair = pair.split("="))[0] && pair[1] && (params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]));
                    }
                    return params;
                }), [ queryString ]);
            }
            function getQueryParam(name) {
                return parseQuery(window.location.search.slice(1))[name];
            }
            function urlWillRedirectPage(url) {
                return -1 === url.indexOf("#") || 0 !== url.indexOf("#") && url.split("#")[0] !== window.location.href.split("#")[0];
            }
            function formatQuery(obj) {
                void 0 === obj && (obj = {});
                return Object.keys(obj).filter((function(key) {
                    return "string" == typeof obj[key] || "boolean" == typeof obj[key];
                })).map((function(key) {
                    var val = obj[key];
                    if ("string" != typeof val && "boolean" != typeof val) throw new TypeError("Invalid type for query");
                    return urlEncode(key) + "=" + urlEncode(val.toString());
                })).join("&");
            }
            function extendQuery(originalQuery, props) {
                void 0 === props && (props = {});
                return props && Object.keys(props).length ? formatQuery(_extends({}, parseQuery(originalQuery), props)) : originalQuery;
            }
            function extendUrl(url, options) {
                var query = options.query || {};
                var hash = options.hash || {};
                var originalUrl;
                var originalHash;
                var _url$split = url.split("#");
                originalHash = _url$split[1];
                var _originalUrl$split = (originalUrl = _url$split[0]).split("?");
                originalUrl = _originalUrl$split[0];
                var queryString = extendQuery(_originalUrl$split[1], query);
                var hashString = extendQuery(originalHash, hash);
                queryString && (originalUrl = originalUrl + "?" + queryString);
                hashString && (originalUrl = originalUrl + "#" + hashString);
                return originalUrl;
            }
            function redirect(url, win) {
                void 0 === win && (win = window);
                return new promise_ZalgoPromise((function(resolve) {
                    win.location = url;
                    urlWillRedirectPage(url) || resolve();
                }));
            }
            function hasMetaViewPort() {
                var meta = document.querySelector("meta[name=viewport]");
                return !(isDevice() && window.screen.width < 660 && !meta);
            }
            function isElementVisible(el) {
                return Boolean(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
            }
            function getPerformance() {
                return inlineMemoize(getPerformance, (function() {
                    var performance = window.performance;
                    if (performance && performance.now && performance.timing && performance.timing.connectEnd && performance.timing.navigationStart && Math.abs(performance.now() - Date.now()) > 1e3 && performance.now() - (performance.timing.connectEnd - performance.timing.navigationStart) > 0) return performance;
                }));
            }
            function enablePerformance() {
                return Boolean(getPerformance());
            }
            function getPageRenderTime() {
                return waitForDocumentReady().then((function() {
                    var performance = getPerformance();
                    if (performance) {
                        var timing = performance.timing;
                        return timing.connectEnd && timing.domInteractive ? timing.domInteractive - timing.connectEnd : void 0;
                    }
                }));
            }
            function htmlEncode(html) {
                void 0 === html && (html = "");
                return html.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/\//g, "&#x2F;");
            }
            function dom_isBrowser() {
                return "undefined" != typeof window && void 0 !== window.location;
            }
            function querySelectorAll(selector, doc) {
                void 0 === doc && (doc = window.document);
                return [].slice.call(doc.querySelectorAll(selector));
            }
            function onClick(element, handler) {
                element.addEventListener("touchstart", src_util_noop, {
                    passive: !0
                });
                element.addEventListener("click", handler);
                element.addEventListener("keypress", (function(event) {
                    if (event.keyCode === KEY_CODES.ENTER || event.keyCode === KEY_CODES.SPACE) return handler(event);
                }));
            }
            function getScript(_ref) {
                var _ref$host = _ref.host, host = void 0 === _ref$host ? window.location.host : _ref$host, path = _ref.path, _ref$reverse = _ref.reverse, reverse = void 0 !== _ref$reverse && _ref$reverse;
                return inlineMemoize(getScript, (function() {
                    var url = "" + host + path;
                    var scripts = [].slice.call(document.getElementsByTagName("script"));
                    reverse && scripts.reverse();
                    for (var _i4 = 0; _i4 < scripts.length; _i4++) {
                        var script = scripts[_i4];
                        if (script.src && script.src.replace(/^https?:\/\//, "").split("?")[0] === url) return script;
                    }
                }), [ path ]);
            }
            function isLocalStorageEnabled() {
                return inlineMemoize(isLocalStorageEnabled, (function() {
                    try {
                        if ("undefined" == typeof window) return !1;
                        if (window.localStorage) {
                            var value = Math.random().toString();
                            window.localStorage.setItem("__test__localStorage__", value);
                            var result = window.localStorage.getItem("__test__localStorage__");
                            window.localStorage.removeItem("__test__localStorage__");
                            if (value === result) return !0;
                        }
                    } catch (err) {}
                    return !1;
                }));
            }
            function getBrowserLocales() {
                var nav = window.navigator;
                var locales = nav.languages ? [].concat(nav.languages) : [];
                nav.language && locales.push(nav.language);
                nav.userLanguage && locales.push(nav.userLanguage);
                return locales.map((function(locale) {
                    if (locale && locale.match(/^[a-z]{2}[-_][A-Z]{2}$/)) {
                        var _locale$split = locale.split(/[-_]/);
                        return {
                            country: _locale$split[1],
                            lang: _locale$split[0]
                        };
                    }
                    return locale && locale.match(/^[a-z]{2}$/) ? {
                        lang: locale
                    } : null;
                })).filter(Boolean);
            }
            function appendChild(container, child) {
                container.appendChild(child);
            }
            function getElementSafe(id, doc) {
                void 0 === doc && (doc = document);
                return isElement(id) ? id : "string" == typeof id ? doc.querySelector(id) : void 0;
            }
            function getElement(id, doc) {
                void 0 === doc && (doc = document);
                var element = getElementSafe(id, doc);
                if (element) return element;
                throw new Error("Can not find element: " + stringify(id));
            }
            function elementReady(id) {
                return new promise_ZalgoPromise((function(resolve, reject) {
                    var name = stringify(id);
                    var el = getElementSafe(id);
                    if (el) return resolve(el);
                    if (isDocumentReady()) return reject(new Error("Document is ready and element " + name + " does not exist"));
                    var interval = setInterval((function() {
                        if (el = getElementSafe(id)) {
                            resolve(el);
                            clearInterval(interval);
                        } else if (isDocumentReady()) {
                            clearInterval(interval);
                            return reject(new Error("Document is ready and element " + name + " does not exist"));
                        }
                    }), 10);
                }));
            }
            var dom_PopupOpenError = function(_ExtendableError) {
                _inheritsLoose(PopupOpenError, _ExtendableError);
                function PopupOpenError() {
                    return _ExtendableError.apply(this, arguments) || this;
                }
                return PopupOpenError;
            }(util_ExtendableError);
            function popup(url, options) {
                var _options$closeOnUnloa = (options = options || {}).closeOnUnload, closeOnUnload = void 0 === _options$closeOnUnloa ? 1 : _options$closeOnUnloa, _options$name = options.name, name = void 0 === _options$name ? "" : _options$name, width = options.width, height = options.height;
                var top = 0;
                var left = 0;
                width && (window.outerWidth ? left = Math.round((window.outerWidth - width) / 2) + window.screenX : window.screen.width && (left = Math.round((window.screen.width - width) / 2)));
                height && (window.outerHeight ? top = Math.round((window.outerHeight - height) / 2) + window.screenY : window.screen.height && (top = Math.round((window.screen.height - height) / 2)));
                delete options.closeOnUnload;
                delete options.name;
                width && height && (options = _extends({
                    top: top,
                    left: left,
                    width: width,
                    height: height,
                    status: 1,
                    toolbar: 0,
                    menubar: 0,
                    resizable: 1,
                    scrollbars: 1
                }, options));
                var params = Object.keys(options).map((function(key) {
                    if (null != options[key]) return key + "=" + stringify(options[key]);
                })).filter(Boolean).join(",");
                var win;
                try {
                    win = window.open(url, name, params);
                } catch (err) {
                    throw new dom_PopupOpenError("Can not open popup window - " + (err.stack || err.message));
                }
                if (isWindowClosed(win)) {
                    var err;
                    throw new dom_PopupOpenError("Can not open popup window - blocked");
                }
                closeOnUnload && window.addEventListener("unload", (function() {
                    return win.close();
                }));
                return win;
            }
            function writeToWindow(win, html) {
                try {
                    win.document.open();
                    win.document.write(html);
                    win.document.close();
                } catch (err) {
                    try {
                        win.location = "javascript: document.open(); document.write(" + JSON.stringify(html) + "); document.close();";
                    } catch (err2) {}
                }
            }
            function writeElementToWindow(win, el) {
                var tag = el.tagName.toLowerCase();
                if ("html" !== tag) throw new Error("Expected element to be html, got " + tag);
                var documentElement = win.document.documentElement;
                for (var _i6 = 0, _arrayFrom2 = arrayFrom(documentElement.children); _i6 < _arrayFrom2.length; _i6++) documentElement.removeChild(_arrayFrom2[_i6]);
                for (var _i8 = 0, _arrayFrom4 = arrayFrom(el.children); _i8 < _arrayFrom4.length; _i8++) documentElement.appendChild(_arrayFrom4[_i8]);
            }
            function setStyle(el, styleText, doc) {
                void 0 === doc && (doc = window.document);
                el.styleSheet ? el.styleSheet.cssText = styleText : el.appendChild(doc.createTextNode(styleText));
            }
            var awaitFrameLoadPromises;
            function awaitFrameLoad(frame) {
                if ((awaitFrameLoadPromises = awaitFrameLoadPromises || new weakmap_CrossDomainSafeWeakMap).has(frame)) {
                    var _promise = awaitFrameLoadPromises.get(frame);
                    if (_promise) return _promise;
                }
                var promise = new promise_ZalgoPromise((function(resolve, reject) {
                    frame.addEventListener("load", (function() {
                        !function(frame) {
                            !function() {
                                for (var i = 0; i < iframeWindows.length; i++) {
                                    var closed = !1;
                                    try {
                                        closed = iframeWindows[i].closed;
                                    } catch (err) {}
                                    if (closed) {
                                        iframeFrames.splice(i, 1);
                                        iframeWindows.splice(i, 1);
                                    }
                                }
                            }();
                            if (frame && frame.contentWindow) try {
                                iframeWindows.push(frame.contentWindow);
                                iframeFrames.push(frame);
                            } catch (err) {}
                        }(frame);
                        resolve(frame);
                    }));
                    frame.addEventListener("error", (function(err) {
                        frame.contentWindow ? resolve(frame) : reject(err);
                    }));
                }));
                awaitFrameLoadPromises.set(frame, promise);
                return promise;
            }
            function awaitFrameWindow(frame) {
                return awaitFrameLoad(frame).then((function(loadedFrame) {
                    if (!loadedFrame.contentWindow) throw new Error("Could not find window in iframe");
                    return loadedFrame.contentWindow;
                }));
            }
            function createElement(tag, options, container) {
                void 0 === tag && (tag = "div");
                void 0 === options && (options = {});
                tag = tag.toLowerCase();
                var element = document.createElement(tag);
                options.style && extend(element.style, options.style);
                options.class && (element.className = options.class.join(" "));
                options.id && element.setAttribute("id", options.id);
                if (options.attributes) for (var _i10 = 0, _Object$keys2 = Object.keys(options.attributes); _i10 < _Object$keys2.length; _i10++) {
                    var key = _Object$keys2[_i10];
                    element.setAttribute(key, options.attributes[key]);
                }
                options.styleSheet && setStyle(element, options.styleSheet);
                container && appendChild(container, element);
                if (options.html) if ("iframe" === tag) {
                    if (!container || !element.contentWindow) throw new Error("Iframe html can not be written unless container provided and iframe in DOM");
                    writeToWindow(element.contentWindow, options.html);
                } else element.innerHTML = options.html;
                return element;
            }
            function iframe(options, container) {
                void 0 === options && (options = {});
                var style = options.style || {};
                var frame = createElement("iframe", {
                    attributes: _extends({
                        allowTransparency: "true"
                    }, options.attributes || {}),
                    style: _extends({
                        backgroundColor: "transparent",
                        border: "none"
                    }, style),
                    html: options.html,
                    class: options.class
                });
                var isIE = window.navigator.userAgent.match(/MSIE|Edge/i);
                frame.hasAttribute("id") || frame.setAttribute("id", uniqueID());
                awaitFrameLoad(frame);
                container && getElement(container).appendChild(frame);
                (options.url || isIE) && frame.setAttribute("src", options.url || "about:blank");
                return frame;
            }
            function addEventListener(obj, event, handler) {
                obj.addEventListener(event, handler);
                return {
                    cancel: function() {
                        obj.removeEventListener(event, handler);
                    }
                };
            }
            function bindEvents(element, eventNames, handler) {
                handler = once(handler);
                for (var _i12 = 0; _i12 < eventNames.length; _i12++) element.addEventListener(eventNames[_i12], handler);
                return {
                    cancel: once((function() {
                        for (var _i14 = 0; _i14 < eventNames.length; _i14++) element.removeEventListener(eventNames[_i14], handler);
                    }))
                };
            }
            var VENDOR_PREFIXES = [ "webkit", "moz", "ms", "o" ];
            function setVendorCSS(element, name, value) {
                element.style[name] = value;
                var capitalizedName = capitalizeFirstLetter(name);
                for (var _i16 = 0; _i16 < VENDOR_PREFIXES.length; _i16++) element.style["" + VENDOR_PREFIXES[_i16] + capitalizedName] = value;
            }
            var ANIMATION_START_EVENTS = [ "animationstart", "webkitAnimationStart", "oAnimationStart", "MSAnimationStart" ];
            var ANIMATION_END_EVENTS = [ "animationend", "webkitAnimationEnd", "oAnimationEnd", "MSAnimationEnd" ];
            function animate(element, name, clean, timeout) {
                void 0 === timeout && (timeout = 1e3);
                return new promise_ZalgoPromise((function(resolve, reject) {
                    var el = getElement(element);
                    if (!el) return resolve();
                    var hasStarted = !1;
                    var startTimeout;
                    var endTimeout;
                    var startEvent;
                    var endEvent;
                    function cleanUp() {
                        clearTimeout(startTimeout);
                        clearTimeout(endTimeout);
                        startEvent.cancel();
                        endEvent.cancel();
                    }
                    startEvent = bindEvents(el, ANIMATION_START_EVENTS, (function(event) {
                        if (event.target === el && event.animationName === name) {
                            clearTimeout(startTimeout);
                            event.stopPropagation();
                            startEvent.cancel();
                            hasStarted = !0;
                            endTimeout = setTimeout((function() {
                                cleanUp();
                                resolve();
                            }), timeout);
                        }
                    }));
                    endEvent = bindEvents(el, ANIMATION_END_EVENTS, (function(event) {
                        if (event.target === el && event.animationName === name) {
                            cleanUp();
                            return "string" == typeof event.animationName && event.animationName !== name ? reject("Expected animation name to be " + name + ", found " + event.animationName) : resolve();
                        }
                    }));
                    setVendorCSS(el, "animationName", name);
                    startTimeout = setTimeout((function() {
                        if (!hasStarted) {
                            cleanUp();
                            return resolve();
                        }
                    }), 200);
                    clean && clean(cleanUp);
                }));
            }
            function makeElementVisible(element) {
                element.style.setProperty("visibility", "");
            }
            function makeElementInvisible(element) {
                element.style.setProperty("visibility", "hidden", "important");
            }
            function showElement(element) {
                element.style.setProperty("display", "");
            }
            function hideElement(element) {
                element.style.setProperty("display", "none", "important");
            }
            function destroyElement(element) {
                element && element.parentNode && element.parentNode.removeChild(element);
            }
            function showAndAnimate(element, name, clean) {
                var animation = animate(element, name, clean);
                showElement(element);
                return animation;
            }
            function animateAndHide(element, name, clean) {
                return animate(element, name, clean).then((function() {
                    hideElement(element);
                }));
            }
            function addClass(element, name) {
                element.classList.add(name);
            }
            function removeClass(element, name) {
                element.classList.remove(name);
            }
            function isElementClosed(el) {
                return !(el && el.parentNode && el.ownerDocument && el.ownerDocument.documentElement && el.ownerDocument.documentElement.contains(el));
            }
            function watchElementForClose(element, handler) {
                handler = once(handler);
                var cancelled = !1;
                var mutationObservers = [];
                var interval;
                var sacrificialFrame;
                var sacrificialFrameWin;
                var cancel = function() {
                    cancelled = !0;
                    for (var _i18 = 0; _i18 < mutationObservers.length; _i18++) mutationObservers[_i18].disconnect();
                    interval && interval.cancel();
                    sacrificialFrameWin && sacrificialFrameWin.removeEventListener("unload", elementClosed);
                    sacrificialFrame && destroyElement(sacrificialFrame);
                };
                var elementClosed = function() {
                    if (!cancelled) {
                        handler();
                        cancel();
                    }
                };
                if (isElementClosed(element)) {
                    elementClosed();
                    return {
                        cancel: cancel
                    };
                }
                if (window.MutationObserver) {
                    var mutationElement = element.parentElement;
                    for (;mutationElement; ) {
                        var mutationObserver = new window.MutationObserver((function() {
                            isElementClosed(element) && elementClosed();
                        }));
                        mutationObserver.observe(mutationElement, {
                            childList: !0
                        });
                        mutationObservers.push(mutationObserver);
                        mutationElement = mutationElement.parentElement;
                    }
                }
                (sacrificialFrame = document.createElement("iframe")).setAttribute("name", "__detect_close_" + uniqueID() + "__");
                sacrificialFrame.style.display = "none";
                awaitFrameWindow(sacrificialFrame).then((function(frameWin) {
                    (sacrificialFrameWin = function(win) {
                        if (!isSameDomain(win)) throw new Error("Expected window to be same domain");
                        return win;
                    }(frameWin)).addEventListener("unload", elementClosed);
                }));
                element.appendChild(sacrificialFrame);
                interval = safeInterval((function() {
                    isElementClosed(element) && elementClosed();
                }), 1e3);
                return {
                    cancel: cancel
                };
            }
            function fixScripts(el, doc) {
                void 0 === doc && (doc = window.document);
                for (var _i20 = 0, _querySelectorAll2 = querySelectorAll("script", el); _i20 < _querySelectorAll2.length; _i20++) {
                    var script = _querySelectorAll2[_i20];
                    var parentNode = script.parentNode;
                    if (parentNode) {
                        var newScript = doc.createElement("script");
                        newScript.text = script.textContent;
                        parentNode.replaceChild(newScript, script);
                    }
                }
            }
            function onResize(el, handler, _temp) {
                var _ref2 = void 0 === _temp ? {} : _temp, _ref2$width = _ref2.width, width = void 0 === _ref2$width || _ref2$width, _ref2$height = _ref2.height, height = void 0 === _ref2$height || _ref2$height, _ref2$interval = _ref2.interval, interval = void 0 === _ref2$interval ? 100 : _ref2$interval, _ref2$win = _ref2.win, win = void 0 === _ref2$win ? window : _ref2$win;
                var currentWidth = el.offsetWidth;
                var currentHeight = el.offsetHeight;
                var canceled = !1;
                handler({
                    width: currentWidth,
                    height: currentHeight
                });
                var check = function() {
                    if (!canceled && isElementVisible(el)) {
                        var newWidth = el.offsetWidth;
                        var newHeight = el.offsetHeight;
                        (width && newWidth !== currentWidth || height && newHeight !== currentHeight) && handler({
                            width: newWidth,
                            height: newHeight
                        });
                        currentWidth = newWidth;
                        currentHeight = newHeight;
                    }
                };
                var observer;
                var timeout;
                win.addEventListener("resize", check);
                if (void 0 !== win.ResizeObserver) {
                    (observer = new win.ResizeObserver(check)).observe(el);
                    timeout = safeInterval(check, 10 * interval);
                } else if (void 0 !== win.MutationObserver) {
                    (observer = new win.MutationObserver(check)).observe(el, {
                        attributes: !0,
                        childList: !0,
                        subtree: !0,
                        characterData: !1
                    });
                    timeout = safeInterval(check, 10 * interval);
                } else timeout = safeInterval(check, interval);
                return {
                    cancel: function() {
                        canceled = !0;
                        observer.disconnect();
                        window.removeEventListener("resize", check);
                        timeout.cancel();
                    }
                };
            }
            function getResourceLoadTime(url) {
                var performance = getPerformance();
                if (performance && "function" == typeof performance.getEntries) {
                    var entries = performance.getEntries();
                    for (var i = 0; i < entries.length; i++) {
                        var entry = entries[i];
                        if (entry && entry.name && 0 === entry.name.indexOf(url) && "number" == typeof entry.duration) return Math.floor(entry.duration);
                    }
                }
            }
            function isShadowElement(element) {
                for (;element.parentNode; ) element = element.parentNode;
                return "[object ShadowRoot]" === element.toString();
            }
            function getShadowRoot(element) {
                for (;element.parentNode; ) element = element.parentNode;
                if (isShadowElement(element)) return element;
            }
            function getShadowHost(element) {
                var shadowRoot = getShadowRoot(element);
                if (shadowRoot && shadowRoot.host) return shadowRoot.host;
            }
            function insertShadowSlot(element) {
                var shadowHost = getShadowHost(element);
                if (!shadowHost) throw new Error("Element is not in shadow dom");
                var slotName = "shadow-slot-" + uniqueID();
                var slot = document.createElement("slot");
                slot.setAttribute("name", slotName);
                element.appendChild(slot);
                var slotProvider = document.createElement("div");
                slotProvider.setAttribute("slot", slotName);
                shadowHost.appendChild(slotProvider);
                return isShadowElement(shadowHost) ? insertShadowSlot(slotProvider) : slotProvider;
            }
            function preventClickFocus(el) {
                var onFocus = function onFocus(event) {
                    el.removeEventListener("focus", onFocus);
                    event.preventDefault();
                    el.blur();
                    return !1;
                };
                el.addEventListener("mousedown", (function() {
                    el.addEventListener("focus", onFocus);
                    setTimeout((function() {
                        el.removeEventListener("focus", onFocus);
                    }), 1);
                }));
            }
            function getStackTrace() {
                try {
                    throw new Error("_");
                } catch (err) {
                    return err.stack || "";
                }
            }
            var currentScript = "undefined" != typeof document ? document.currentScript : null;
            var getCurrentScript = memoize((function() {
                if (currentScript) return currentScript;
                if (currentScript = function() {
                    try {
                        var stack = getStackTrace();
                        var stackDetails = /.*at [^(]*\((.*):(.+):(.+)\)$/gi.exec(stack);
                        var scriptLocation = stackDetails && stackDetails[1];
                        if (!scriptLocation) return;
                        for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName("script")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {
                            var script = _Array$prototype$slic2[_i22];
                            if (script.src && script.src === scriptLocation) return script;
                        }
                    } catch (err) {}
                }()) return currentScript;
                throw new Error("Can not determine current script");
            }));
            var currentUID = uniqueID();
            var getCurrentScriptUID = memoize((function() {
                var script;
                try {
                    script = getCurrentScript();
                } catch (err) {
                    return currentUID;
                }
                var uid = script.getAttribute(ATTRIBUTES.UID);
                if (uid && "string" == typeof uid) return uid;
                if ((uid = script.getAttribute(ATTRIBUTES.UID + "-auto")) && "string" == typeof uid) return uid;
                if (script.src) {
                    var hashedString = strHashStr(JSON.stringify({
                        src: script.src,
                        dataset: script.dataset
                    }));
                    uid = "uid_" + hashedString.slice(hashedString.length - UID_HASH_LENGTH);
                } else uid = uniqueID();
                script.setAttribute(ATTRIBUTES.UID + "-auto", uid);
                return uid;
            }));
            function submitForm(_ref3) {
                var url = _ref3.url, target = _ref3.target, body = _ref3.body, _ref3$method = _ref3.method, method = void 0 === _ref3$method ? "post" : _ref3$method;
                var form = document.createElement("form");
                form.setAttribute("target", target);
                form.setAttribute("method", method);
                form.setAttribute("action", url);
                form.style.display = "none";
                if (body) for (var _i24 = 0, _Object$keys4 = Object.keys(body); _i24 < _Object$keys4.length; _i24++) {
                    var _body$key;
                    var key = _Object$keys4[_i24];
                    var input = document.createElement("input");
                    input.setAttribute("name", key);
                    input.setAttribute("value", null == (_body$key = body[key]) ? void 0 : _body$key.toString());
                    form.appendChild(input);
                }
                getBody().appendChild(form);
                form.submit();
                getBody().removeChild(form);
            }
            function getStorage(_ref) {
                var name = _ref.name, _ref$lifetime = _ref.lifetime, lifetime = void 0 === _ref$lifetime ? 12e5 : _ref$lifetime;
                return inlineMemoize(getStorage, (function() {
                    var STORAGE_KEY = "__" + name + "_storage__";
                    var newStateID = uniqueID();
                    var accessedStorage;
                    function getState(handler) {
                        var localStorageEnabled = isLocalStorageEnabled();
                        var storage;
                        accessedStorage && (storage = accessedStorage);
                        if (!storage && localStorageEnabled) {
                            var rawStorage = window.localStorage.getItem(STORAGE_KEY);
                            rawStorage && (storage = JSON.parse(rawStorage));
                        }
                        storage || (storage = getGlobal()[STORAGE_KEY]);
                        storage || (storage = {
                            id: newStateID
                        });
                        storage.id || (storage.id = newStateID);
                        accessedStorage = storage;
                        var result = handler(storage);
                        localStorageEnabled ? window.localStorage.setItem(STORAGE_KEY, JSON.stringify(storage)) : getGlobal()[STORAGE_KEY] = storage;
                        accessedStorage = null;
                        return result;
                    }
                    function getID() {
                        return getState((function(storage) {
                            return storage.id;
                        }));
                    }
                    function getSession(handler) {
                        return getState((function(storage) {
                            var session = storage.__session__;
                            var now = Date.now();
                            session && now - session.created > lifetime && (session = null);
                            session || (session = {
                                guid: uniqueID(),
                                created: now
                            });
                            storage.__session__ = session;
                            return handler(session);
                        }));
                    }
                    return {
                        getState: getState,
                        getID: getID,
                        isStateFresh: function() {
                            return getID() === newStateID;
                        },
                        getSessionState: function(handler) {
                            return getSession((function(session) {
                                session.state = session.state || {};
                                return handler(session.state);
                            }));
                        },
                        getSessionID: function() {
                            return getSession((function(session) {
                                return session.guid;
                            }));
                        }
                    };
                }), [ {
                    name: name,
                    lifetime: lifetime
                } ]);
            }
            function getBelterExperimentStorage() {
                return getStorage({
                    name: "belter_experiment"
                });
            }
            function isEventUnique(name) {
                return getBelterExperimentStorage().getSessionState((function(state) {
                    state.loggedBeacons = state.loggedBeacons || [];
                    if (-1 === state.loggedBeacons.indexOf(name)) {
                        state.loggedBeacons.push(name);
                        return !0;
                    }
                    return !1;
                }));
            }
            function getRandomInteger(range) {
                return Math.floor(Math.random() * range);
            }
            function experiment(_ref) {
                var name = _ref.name, _ref$sample = _ref.sample, sample = void 0 === _ref$sample ? 50 : _ref$sample, _ref$logTreatment = _ref.logTreatment, logTreatment = void 0 === _ref$logTreatment ? src_util_noop : _ref$logTreatment, _ref$logCheckpoint = _ref.logCheckpoint, logCheckpoint = void 0 === _ref$logCheckpoint ? src_util_noop : _ref$logCheckpoint, _ref$sticky = _ref.sticky;
                var throttle = void 0 === _ref$sticky || _ref$sticky ? function(name) {
                    return getBelterExperimentStorage().getState((function(state) {
                        state.throttlePercentiles = state.throttlePercentiles || {};
                        state.throttlePercentiles[name] = state.throttlePercentiles[name] || getRandomInteger(100);
                        return state.throttlePercentiles[name];
                    }));
                }(name) : getRandomInteger(100);
                var group;
                var treatment = name + "_" + (group = throttle < sample ? "test" : sample >= 50 || sample <= throttle && throttle < 2 * sample ? "control" : "throttle");
                var started = !1;
                var forced = !1;
                try {
                    window.localStorage && window.localStorage.getItem(name) && (forced = !0);
                } catch (err) {}
                var exp = {
                    isEnabled: function() {
                        return "test" === group || forced;
                    },
                    isDisabled: function() {
                        return "test" !== group && !forced;
                    },
                    getTreatment: function() {
                        return treatment;
                    },
                    log: function(checkpoint, payload) {
                        void 0 === payload && (payload = {});
                        if (!started) return exp;
                        isEventUnique(treatment + "_" + JSON.stringify(payload)) && logTreatment({
                            name: name,
                            treatment: treatment,
                            payload: payload,
                            throttle: throttle
                        });
                        isEventUnique(treatment + "_" + checkpoint + "_" + JSON.stringify(payload)) && logCheckpoint({
                            name: name,
                            treatment: treatment,
                            checkpoint: checkpoint,
                            payload: payload,
                            throttle: throttle
                        });
                        return exp;
                    },
                    logStart: function(payload) {
                        void 0 === payload && (payload = {});
                        started = !0;
                        return exp.log("start", payload);
                    },
                    logComplete: function(payload) {
                        void 0 === payload && (payload = {});
                        return exp.log("complete", payload);
                    }
                };
                return exp;
            }
            function getGlobalNameSpace(_ref) {
                var name = _ref.name, _ref$version = _ref.version, version = void 0 === _ref$version ? "latest" : _ref$version;
                var global = getGlobal();
                var globalKey = "__" + name + "__" + version + "_global__";
                var namespace = global[globalKey] = global[globalKey] || {};
                return {
                    get: function(key, defValue) {
                        defValue = defValue || {};
                        return namespace[key] = namespace[key] || defValue;
                    }
                };
            }
            var headerBuilders = [];
            function request(_ref) {
                var url = _ref.url, _ref$method = _ref.method, method = void 0 === _ref$method ? "get" : _ref$method, _ref$headers = _ref.headers, headers = void 0 === _ref$headers ? {} : _ref$headers, json = _ref.json, data = _ref.data, body = _ref.body, _ref$win = _ref.win, win = void 0 === _ref$win ? window : _ref$win, _ref$timeout = _ref.timeout, timeout = void 0 === _ref$timeout ? 0 : _ref$timeout;
                return new promise_ZalgoPromise((function(resolve, reject) {
                    if (json && data || json && body || data && json) throw new Error("Only options.json or options.data or options.body should be passed");
                    var normalizedHeaders = {};
                    for (var _i4 = 0, _Object$keys2 = Object.keys(headers); _i4 < _Object$keys2.length; _i4++) {
                        var _key2 = _Object$keys2[_i4];
                        normalizedHeaders[_key2.toLowerCase()] = headers[_key2];
                    }
                    json ? normalizedHeaders["content-type"] = normalizedHeaders["content-type"] || "application/json" : (data || body) && (normalizedHeaders["content-type"] = normalizedHeaders["content-type"] || "application/x-www-form-urlencoded; charset=utf-8");
                    normalizedHeaders.accept = normalizedHeaders.accept || "application/json";
                    for (var _i6 = 0; _i6 < headerBuilders.length; _i6++) {
                        var builtHeaders = (0, headerBuilders[_i6])();
                        for (var _i8 = 0, _Object$keys4 = Object.keys(builtHeaders); _i8 < _Object$keys4.length; _i8++) {
                            var _key3 = _Object$keys4[_i8];
                            normalizedHeaders[_key3.toLowerCase()] = builtHeaders[_key3];
                        }
                    }
                    var xhr = new win.XMLHttpRequest;
                    xhr.addEventListener("load", (function() {
                        var responseHeaders = function(rawHeaders) {
                            void 0 === rawHeaders && (rawHeaders = "");
                            var result = {};
                            for (var _i2 = 0, _rawHeaders$trim$spli2 = rawHeaders.trim().split("\n"); _i2 < _rawHeaders$trim$spli2.length; _i2++) {
                                var _line$split = _rawHeaders$trim$spli2[_i2].split(":"), _key = _line$split[0], values = _line$split.slice(1);
                                result[_key.toLowerCase()] = values.join(":").trim();
                            }
                            return result;
                        }(this.getAllResponseHeaders());
                        if (!this.status) return reject(new Error("Request to " + method.toLowerCase() + " " + url + " failed: no response status code."));
                        var contentType = responseHeaders["content-type"];
                        var isJSON = contentType && (0 === contentType.indexOf("application/json") || 0 === contentType.indexOf("text/json"));
                        var responseBody = this.responseText;
                        try {
                            responseBody = JSON.parse(responseBody);
                        } catch (err) {
                            if (isJSON) return reject(new Error("Invalid json: " + this.responseText + "."));
                        }
                        return resolve({
                            status: this.status,
                            headers: responseHeaders,
                            body: responseBody
                        });
                    }), !1);
                    xhr.addEventListener("error", (function(evt) {
                        reject(new Error("Request to " + method.toLowerCase() + " " + url + " failed: " + evt.toString() + "."));
                    }), !1);
                    xhr.open(method, url, !0);
                    for (var _key4 in normalizedHeaders) normalizedHeaders.hasOwnProperty(_key4) && xhr.setRequestHeader(_key4, normalizedHeaders[_key4]);
                    json ? body = JSON.stringify(json) : data && (body = Object.keys(data).map((function(key) {
                        return encodeURIComponent(key) + "=" + (data ? encodeURIComponent(data[key]) : "");
                    })).join("&"));
                    xhr.timeout = timeout;
                    xhr.ontimeout = function() {
                        reject(new Error("Request to " + method.toLowerCase() + " " + url + " has timed out"));
                    };
                    xhr.send(body);
                }));
            }
            function addHeaderBuilder(method) {
                headerBuilders.push(method);
            }
            var types_TYPES = !0;
            function memoized(target, name, descriptor) {
                descriptor.value = memoize(descriptor.value, {
                    name: name,
                    thisNamespace: !0
                });
            }
            function decorators_promise(target, name, descriptor) {
                descriptor.value = promisify(descriptor.value, {
                    name: name
                });
            }
            function isPerc(str) {
                return "string" == typeof str && /^[0-9]+%$/.test(str);
            }
            function isPx(str) {
                return "string" == typeof str && /^[0-9]+px$/.test(str);
            }
            function toNum(val) {
                if ("number" == typeof val) return val;
                var match = val.match(/^([0-9]+)(px|%)$/);
                if (!match) throw new Error("Could not match css value from " + val);
                return parseInt(match[1], 10);
            }
            function toPx(val) {
                return toNum(val) + "px";
            }
            function toCSS(val) {
                return "number" == typeof val ? toPx(val) : isPerc(val) ? val : toPx(val);
            }
            function percOf(num, perc) {
                return parseInt(num * toNum(perc) / 100, 10);
            }
            function normalizeDimension(dim, max) {
                if ("number" == typeof dim) return dim;
                if (isPerc(dim)) return percOf(max, dim);
                if (isPx(dim)) return toNum(dim);
                throw new Error("Can not normalize dimension: " + dim);
            }
            function wrapPromise(method, _temp) {
                var _ref$timeout = (void 0 === _temp ? {} : _temp).timeout, timeout = void 0 === _ref$timeout ? 5e3 : _ref$timeout;
                var expected = [];
                var promises = [];
                return new promise_ZalgoPromise((function(resolve, reject) {
                    var timer = setTimeout((function() {
                        expected.length && reject(new Error("Expected " + expected[0].name + " to be called in " + timeout + "ms"));
                        promises.length && reject(new Error("Expected " + promises[0].name + " promise to complete in " + timeout + "ms"));
                    }), timeout);
                    var expect = function(name, handler) {
                        void 0 === handler && (handler = src_util_noop);
                        var exp = {
                            name: name,
                            handler: handler
                        };
                        expected.push(exp);
                        return function() {
                            var _this = this;
                            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                            removeFromArray(expected, exp);
                            var _tryCatch = tryCatch((function() {
                                var _handler;
                                return (_handler = handler).call.apply(_handler, [ _this ].concat(args));
                            })), result = _tryCatch.result, error = _tryCatch.error;
                            if (error) {
                                promises.push({
                                    name: name,
                                    promise: promise_ZalgoPromise.asyncReject(error)
                                });
                                throw error;
                            }
                            promises.push({
                                name: name,
                                promise: promise_ZalgoPromise.resolve(result)
                            });
                            return result;
                        };
                    };
                    var avoid = function(name, fn) {
                        void 0 === fn && (fn = src_util_noop);
                        return function() {
                            var _fn;
                            promises.push({
                                name: name,
                                promise: promise_ZalgoPromise.asyncReject(new Error("Expected " + name + " to not be called"))
                            });
                            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                            return (_fn = fn).call.apply(_fn, [ this ].concat(args));
                        };
                    };
                    var expectError = function(name, handler) {
                        void 0 === handler && (handler = src_util_noop);
                        var exp = {
                            name: name,
                            handler: handler
                        };
                        expected.push(exp);
                        return function() {
                            var _this2 = this;
                            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
                            removeFromArray(expected, exp);
                            var _tryCatch2 = tryCatch((function() {
                                var _handler2;
                                return (_handler2 = handler).call.apply(_handler2, [ _this2 ].concat(args));
                            })), result = _tryCatch2.result, error = _tryCatch2.error;
                            if (error) throw error;
                            promises.push({
                                name: name,
                                promise: promise_ZalgoPromise.resolve(result).then((function() {
                                    throw new Error("Expected " + name + " to throw an error");
                                }), src_util_noop)
                            });
                            return result;
                        };
                    };
                    promises.push({
                        name: "wrapPromise handler",
                        promise: promise_ZalgoPromise.try((function() {
                            return method({
                                expect: expect,
                                avoid: avoid,
                                expectError: expectError,
                                error: avoid,
                                wait: function() {
                                    return promise_ZalgoPromise.resolve();
                                }
                            });
                        }))
                    });
                    (function wait() {
                        return promise_ZalgoPromise.try((function() {
                            if (promises.length) {
                                var prom = promises[0];
                                return prom.promise.finally((function() {
                                    removeFromArray(promises, prom);
                                })).then(wait);
                            }
                        })).then((function() {
                            if (expected.length) return promise_ZalgoPromise.delay(10).then(wait);
                        }));
                    })().finally((function() {
                        clearTimeout(timer);
                    })).then(resolve, reject);
                }));
            }
        } ]);
    },
    "./node_modules/@krakenjs/belter/index.js": function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__("./node_modules/@krakenjs/belter/dist/belter.js");
    },
    "./node_modules/@krakenjs/belter/src/index.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "getUserAgent", (function() {
            return getUserAgent;
        }));
        __webpack_require__.d(__webpack_exports__, "isDevice", (function() {
            return isDevice;
        }));
        __webpack_require__.d(__webpack_exports__, "isTablet", (function() {
            return isTablet;
        }));
        __webpack_require__.d(__webpack_exports__, "isWebView", (function() {
            return isWebView;
        }));
        __webpack_require__.d(__webpack_exports__, "isStandAlone", (function() {
            return isStandAlone;
        }));
        __webpack_require__.d(__webpack_exports__, "isFacebookWebView", (function() {
            return isFacebookWebView;
        }));
        __webpack_require__.d(__webpack_exports__, "isFirefox", (function() {
            return isFirefox;
        }));
        __webpack_require__.d(__webpack_exports__, "isFirefoxIOS", (function() {
            return isFirefoxIOS;
        }));
        __webpack_require__.d(__webpack_exports__, "isEdgeIOS", (function() {
            return isEdgeIOS;
        }));
        __webpack_require__.d(__webpack_exports__, "isOperaMini", (function() {
            return isOperaMini;
        }));
        __webpack_require__.d(__webpack_exports__, "isAndroid", (function() {
            return isAndroid;
        }));
        __webpack_require__.d(__webpack_exports__, "isIos", (function() {
            return isIos;
        }));
        __webpack_require__.d(__webpack_exports__, "isIOS14", (function() {
            return isIOS14;
        }));
        __webpack_require__.d(__webpack_exports__, "isGoogleSearchApp", (function() {
            return isGoogleSearchApp;
        }));
        __webpack_require__.d(__webpack_exports__, "isQQBrowser", (function() {
            return isQQBrowser;
        }));
        __webpack_require__.d(__webpack_exports__, "isIosWebview", (function() {
            return isIosWebview;
        }));
        __webpack_require__.d(__webpack_exports__, "isSFVC", (function() {
            return isSFVC;
        }));
        __webpack_require__.d(__webpack_exports__, "isSFVCorSafari", (function() {
            return isSFVCorSafari;
        }));
        __webpack_require__.d(__webpack_exports__, "isAndroidWebview", (function() {
            return isAndroidWebview;
        }));
        __webpack_require__.d(__webpack_exports__, "isIE", (function() {
            return device_isIE;
        }));
        __webpack_require__.d(__webpack_exports__, "isIECompHeader", (function() {
            return isIECompHeader;
        }));
        __webpack_require__.d(__webpack_exports__, "isElectron", (function() {
            return isElectron;
        }));
        __webpack_require__.d(__webpack_exports__, "isIEIntranet", (function() {
            return isIEIntranet;
        }));
        __webpack_require__.d(__webpack_exports__, "isMacOsCna", (function() {
            return isMacOsCna;
        }));
        __webpack_require__.d(__webpack_exports__, "supportsPopups", (function() {
            return supportsPopups;
        }));
        __webpack_require__.d(__webpack_exports__, "isChrome", (function() {
            return isChrome;
        }));
        __webpack_require__.d(__webpack_exports__, "isSafari", (function() {
            return isSafari;
        }));
        __webpack_require__.d(__webpack_exports__, "isApplePaySupported", (function() {
            return isApplePaySupported;
        }));
        __webpack_require__.d(__webpack_exports__, "isCrossSiteTrackingEnabled", (function() {
            return isCrossSiteTrackingEnabled;
        }));
        __webpack_require__.d(__webpack_exports__, "getBody", (function() {
            return getBody;
        }));
        __webpack_require__.d(__webpack_exports__, "isDocumentReady", (function() {
            return isDocumentReady;
        }));
        __webpack_require__.d(__webpack_exports__, "isDocumentInteractive", (function() {
            return isDocumentInteractive;
        }));
        __webpack_require__.d(__webpack_exports__, "urlEncode", (function() {
            return urlEncode;
        }));
        __webpack_require__.d(__webpack_exports__, "waitForWindowReady", (function() {
            return waitForWindowReady;
        }));
        __webpack_require__.d(__webpack_exports__, "waitForDocumentReady", (function() {
            return waitForDocumentReady;
        }));
        __webpack_require__.d(__webpack_exports__, "waitForDocumentBody", (function() {
            return waitForDocumentBody;
        }));
        __webpack_require__.d(__webpack_exports__, "parseQuery", (function() {
            return parseQuery;
        }));
        __webpack_require__.d(__webpack_exports__, "getQueryParam", (function() {
            return getQueryParam;
        }));
        __webpack_require__.d(__webpack_exports__, "urlWillRedirectPage", (function() {
            return urlWillRedirectPage;
        }));
        __webpack_require__.d(__webpack_exports__, "formatQuery", (function() {
            return formatQuery;
        }));
        __webpack_require__.d(__webpack_exports__, "extendQuery", (function() {
            return extendQuery;
        }));
        __webpack_require__.d(__webpack_exports__, "extendUrl", (function() {
            return extendUrl;
        }));
        __webpack_require__.d(__webpack_exports__, "redirect", (function() {
            return redirect;
        }));
        __webpack_require__.d(__webpack_exports__, "hasMetaViewPort", (function() {
            return hasMetaViewPort;
        }));
        __webpack_require__.d(__webpack_exports__, "isElementVisible", (function() {
            return isElementVisible;
        }));
        __webpack_require__.d(__webpack_exports__, "getPerformance", (function() {
            return getPerformance;
        }));
        __webpack_require__.d(__webpack_exports__, "enablePerformance", (function() {
            return enablePerformance;
        }));
        __webpack_require__.d(__webpack_exports__, "getPageRenderTime", (function() {
            return getPageRenderTime;
        }));
        __webpack_require__.d(__webpack_exports__, "htmlEncode", (function() {
            return htmlEncode;
        }));
        __webpack_require__.d(__webpack_exports__, "isBrowser", (function() {
            return isBrowser;
        }));
        __webpack_require__.d(__webpack_exports__, "querySelectorAll", (function() {
            return querySelectorAll;
        }));
        __webpack_require__.d(__webpack_exports__, "onClick", (function() {
            return onClick;
        }));
        __webpack_require__.d(__webpack_exports__, "getScript", (function() {
            return getScript;
        }));
        __webpack_require__.d(__webpack_exports__, "isLocalStorageEnabled", (function() {
            return isLocalStorageEnabled;
        }));
        __webpack_require__.d(__webpack_exports__, "getBrowserLocales", (function() {
            return getBrowserLocales;
        }));
        __webpack_require__.d(__webpack_exports__, "appendChild", (function() {
            return appendChild;
        }));
        __webpack_require__.d(__webpack_exports__, "getElementSafe", (function() {
            return getElementSafe;
        }));
        __webpack_require__.d(__webpack_exports__, "getElement", (function() {
            return getElement;
        }));
        __webpack_require__.d(__webpack_exports__, "elementReady", (function() {
            return elementReady;
        }));
        __webpack_require__.d(__webpack_exports__, "PopupOpenError", (function() {
            return dom_PopupOpenError;
        }));
        __webpack_require__.d(__webpack_exports__, "popup", (function() {
            return popup;
        }));
        __webpack_require__.d(__webpack_exports__, "writeToWindow", (function() {
            return writeToWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "writeElementToWindow", (function() {
            return writeElementToWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "setStyle", (function() {
            return setStyle;
        }));
        __webpack_require__.d(__webpack_exports__, "awaitFrameLoad", (function() {
            return awaitFrameLoad;
        }));
        __webpack_require__.d(__webpack_exports__, "awaitFrameWindow", (function() {
            return awaitFrameWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "createElement", (function() {
            return createElement;
        }));
        __webpack_require__.d(__webpack_exports__, "iframe", (function() {
            return iframe;
        }));
        __webpack_require__.d(__webpack_exports__, "addEventListener", (function() {
            return addEventListener;
        }));
        __webpack_require__.d(__webpack_exports__, "bindEvents", (function() {
            return bindEvents;
        }));
        __webpack_require__.d(__webpack_exports__, "setVendorCSS", (function() {
            return setVendorCSS;
        }));
        __webpack_require__.d(__webpack_exports__, "animate", (function() {
            return animate;
        }));
        __webpack_require__.d(__webpack_exports__, "makeElementVisible", (function() {
            return makeElementVisible;
        }));
        __webpack_require__.d(__webpack_exports__, "makeElementInvisible", (function() {
            return makeElementInvisible;
        }));
        __webpack_require__.d(__webpack_exports__, "showElement", (function() {
            return showElement;
        }));
        __webpack_require__.d(__webpack_exports__, "hideElement", (function() {
            return hideElement;
        }));
        __webpack_require__.d(__webpack_exports__, "destroyElement", (function() {
            return destroyElement;
        }));
        __webpack_require__.d(__webpack_exports__, "showAndAnimate", (function() {
            return showAndAnimate;
        }));
        __webpack_require__.d(__webpack_exports__, "animateAndHide", (function() {
            return animateAndHide;
        }));
        __webpack_require__.d(__webpack_exports__, "addClass", (function() {
            return addClass;
        }));
        __webpack_require__.d(__webpack_exports__, "removeClass", (function() {
            return removeClass;
        }));
        __webpack_require__.d(__webpack_exports__, "isElementClosed", (function() {
            return isElementClosed;
        }));
        __webpack_require__.d(__webpack_exports__, "watchElementForClose", (function() {
            return watchElementForClose;
        }));
        __webpack_require__.d(__webpack_exports__, "fixScripts", (function() {
            return fixScripts;
        }));
        __webpack_require__.d(__webpack_exports__, "onResize", (function() {
            return onResize;
        }));
        __webpack_require__.d(__webpack_exports__, "getResourceLoadTime", (function() {
            return getResourceLoadTime;
        }));
        __webpack_require__.d(__webpack_exports__, "isShadowElement", (function() {
            return isShadowElement;
        }));
        __webpack_require__.d(__webpack_exports__, "getShadowRoot", (function() {
            return getShadowRoot;
        }));
        __webpack_require__.d(__webpack_exports__, "getShadowHost", (function() {
            return getShadowHost;
        }));
        __webpack_require__.d(__webpack_exports__, "insertShadowSlot", (function() {
            return insertShadowSlot;
        }));
        __webpack_require__.d(__webpack_exports__, "preventClickFocus", (function() {
            return preventClickFocus;
        }));
        __webpack_require__.d(__webpack_exports__, "getStackTrace", (function() {
            return getStackTrace;
        }));
        __webpack_require__.d(__webpack_exports__, "getCurrentScript", (function() {
            return getCurrentScript;
        }));
        __webpack_require__.d(__webpack_exports__, "getCurrentScriptUID", (function() {
            return getCurrentScriptUID;
        }));
        __webpack_require__.d(__webpack_exports__, "submitForm", (function() {
            return submitForm;
        }));
        __webpack_require__.d(__webpack_exports__, "experiment", (function() {
            return experiment;
        }));
        __webpack_require__.d(__webpack_exports__, "getGlobalNameSpace", (function() {
            return getGlobalNameSpace;
        }));
        __webpack_require__.d(__webpack_exports__, "getStorage", (function() {
            return getStorage;
        }));
        __webpack_require__.d(__webpack_exports__, "isElement", (function() {
            return isElement;
        }));
        __webpack_require__.d(__webpack_exports__, "getFunctionName", (function() {
            return getFunctionName;
        }));
        __webpack_require__.d(__webpack_exports__, "setFunctionName", (function() {
            return setFunctionName;
        }));
        __webpack_require__.d(__webpack_exports__, "base64encode", (function() {
            return base64encode;
        }));
        __webpack_require__.d(__webpack_exports__, "base64decode", (function() {
            return base64decode;
        }));
        __webpack_require__.d(__webpack_exports__, "uniqueID", (function() {
            return uniqueID;
        }));
        __webpack_require__.d(__webpack_exports__, "getGlobal", (function() {
            return getGlobal;
        }));
        __webpack_require__.d(__webpack_exports__, "getObjectID", (function() {
            return getObjectID;
        }));
        __webpack_require__.d(__webpack_exports__, "getEmptyObject", (function() {
            return getEmptyObject;
        }));
        __webpack_require__.d(__webpack_exports__, "memoize", (function() {
            return memoize;
        }));
        __webpack_require__.d(__webpack_exports__, "promiseIdentity", (function() {
            return promiseIdentity;
        }));
        __webpack_require__.d(__webpack_exports__, "memoizePromise", (function() {
            return memoizePromise;
        }));
        __webpack_require__.d(__webpack_exports__, "promisify", (function() {
            return promisify;
        }));
        __webpack_require__.d(__webpack_exports__, "inlineMemoize", (function() {
            return inlineMemoize;
        }));
        __webpack_require__.d(__webpack_exports__, "noop", (function() {
            return util_noop;
        }));
        __webpack_require__.d(__webpack_exports__, "once", (function() {
            return once;
        }));
        __webpack_require__.d(__webpack_exports__, "hashStr", (function() {
            return hashStr;
        }));
        __webpack_require__.d(__webpack_exports__, "strHashStr", (function() {
            return strHashStr;
        }));
        __webpack_require__.d(__webpack_exports__, "match", (function() {
            return match;
        }));
        __webpack_require__.d(__webpack_exports__, "awaitKey", (function() {
            return awaitKey;
        }));
        __webpack_require__.d(__webpack_exports__, "stringifyError", (function() {
            return stringifyError;
        }));
        __webpack_require__.d(__webpack_exports__, "stringifyErrorMessage", (function() {
            return stringifyErrorMessage;
        }));
        __webpack_require__.d(__webpack_exports__, "stringify", (function() {
            return stringify;
        }));
        __webpack_require__.d(__webpack_exports__, "domainMatches", (function() {
            return domainMatches;
        }));
        __webpack_require__.d(__webpack_exports__, "patchMethod", (function() {
            return patchMethod;
        }));
        __webpack_require__.d(__webpack_exports__, "extend", (function() {
            return extend;
        }));
        __webpack_require__.d(__webpack_exports__, "values", (function() {
            return util_values;
        }));
        __webpack_require__.d(__webpack_exports__, "memoizedValues", (function() {
            return memoizedValues;
        }));
        __webpack_require__.d(__webpack_exports__, "perc", (function() {
            return perc;
        }));
        __webpack_require__.d(__webpack_exports__, "min", (function() {
            return min;
        }));
        __webpack_require__.d(__webpack_exports__, "max", (function() {
            return max;
        }));
        __webpack_require__.d(__webpack_exports__, "roundUp", (function() {
            return roundUp;
        }));
        __webpack_require__.d(__webpack_exports__, "regexMap", (function() {
            return regexMap;
        }));
        __webpack_require__.d(__webpack_exports__, "svgToBase64", (function() {
            return svgToBase64;
        }));
        __webpack_require__.d(__webpack_exports__, "objFilter", (function() {
            return objFilter;
        }));
        __webpack_require__.d(__webpack_exports__, "identity", (function() {
            return identity;
        }));
        __webpack_require__.d(__webpack_exports__, "regexTokenize", (function() {
            return regexTokenize;
        }));
        __webpack_require__.d(__webpack_exports__, "promiseDebounce", (function() {
            return promiseDebounce;
        }));
        __webpack_require__.d(__webpack_exports__, "safeInterval", (function() {
            return safeInterval;
        }));
        __webpack_require__.d(__webpack_exports__, "isInteger", (function() {
            return isInteger;
        }));
        __webpack_require__.d(__webpack_exports__, "isFloat", (function() {
            return isFloat;
        }));
        __webpack_require__.d(__webpack_exports__, "serializePrimitive", (function() {
            return serializePrimitive;
        }));
        __webpack_require__.d(__webpack_exports__, "deserializePrimitive", (function() {
            return deserializePrimitive;
        }));
        __webpack_require__.d(__webpack_exports__, "dotify", (function() {
            return dotify;
        }));
        __webpack_require__.d(__webpack_exports__, "undotify", (function() {
            return undotify;
        }));
        __webpack_require__.d(__webpack_exports__, "eventEmitter", (function() {
            return eventEmitter;
        }));
        __webpack_require__.d(__webpack_exports__, "camelToDasherize", (function() {
            return camelToDasherize;
        }));
        __webpack_require__.d(__webpack_exports__, "dasherizeToCamel", (function() {
            return dasherizeToCamel;
        }));
        __webpack_require__.d(__webpack_exports__, "capitalizeFirstLetter", (function() {
            return capitalizeFirstLetter;
        }));
        __webpack_require__.d(__webpack_exports__, "get", (function() {
            return util_get;
        }));
        __webpack_require__.d(__webpack_exports__, "safeTimeout", (function() {
            return safeTimeout;
        }));
        __webpack_require__.d(__webpack_exports__, "defineLazyProp", (function() {
            return defineLazyProp;
        }));
        __webpack_require__.d(__webpack_exports__, "arrayFrom", (function() {
            return arrayFrom;
        }));
        __webpack_require__.d(__webpack_exports__, "isObject", (function() {
            return isObject;
        }));
        __webpack_require__.d(__webpack_exports__, "isObjectObject", (function() {
            return isObjectObject;
        }));
        __webpack_require__.d(__webpack_exports__, "isPlainObject", (function() {
            return isPlainObject;
        }));
        __webpack_require__.d(__webpack_exports__, "replaceObject", (function() {
            return replaceObject;
        }));
        __webpack_require__.d(__webpack_exports__, "copyProp", (function() {
            return copyProp;
        }));
        __webpack_require__.d(__webpack_exports__, "regex", (function() {
            return regex;
        }));
        __webpack_require__.d(__webpack_exports__, "regexAll", (function() {
            return regexAll;
        }));
        __webpack_require__.d(__webpack_exports__, "isDefined", (function() {
            return isDefined;
        }));
        __webpack_require__.d(__webpack_exports__, "cycle", (function() {
            return cycle;
        }));
        __webpack_require__.d(__webpack_exports__, "debounce", (function() {
            return debounce;
        }));
        __webpack_require__.d(__webpack_exports__, "isRegex", (function() {
            return isRegex;
        }));
        __webpack_require__.d(__webpack_exports__, "weakMapMemoize", (function() {
            return util_weakMapMemoize;
        }));
        __webpack_require__.d(__webpack_exports__, "weakMapMemoizePromise", (function() {
            return util_weakMapMemoizePromise;
        }));
        __webpack_require__.d(__webpack_exports__, "getOrSet", (function() {
            return getOrSet;
        }));
        __webpack_require__.d(__webpack_exports__, "cleanup", (function() {
            return cleanup;
        }));
        __webpack_require__.d(__webpack_exports__, "tryCatch", (function() {
            return tryCatch;
        }));
        __webpack_require__.d(__webpack_exports__, "removeFromArray", (function() {
            return removeFromArray;
        }));
        __webpack_require__.d(__webpack_exports__, "assertExists", (function() {
            return assertExists;
        }));
        __webpack_require__.d(__webpack_exports__, "unique", (function() {
            return unique;
        }));
        __webpack_require__.d(__webpack_exports__, "constHas", (function() {
            return constHas;
        }));
        __webpack_require__.d(__webpack_exports__, "dedupeErrors", (function() {
            return dedupeErrors;
        }));
        __webpack_require__.d(__webpack_exports__, "ExtendableError", (function() {
            return util_ExtendableError;
        }));
        __webpack_require__.d(__webpack_exports__, "sanitizeUrl", (function() {
            return sanitizeUrl;
        }));
        __webpack_require__.d(__webpack_exports__, "request", (function() {
            return request;
        }));
        __webpack_require__.d(__webpack_exports__, "addHeaderBuilder", (function() {
            return addHeaderBuilder;
        }));
        __webpack_require__.d(__webpack_exports__, "TYPES", (function() {
            return TYPES;
        }));
        __webpack_require__.d(__webpack_exports__, "memoized", (function() {
            return memoized;
        }));
        __webpack_require__.d(__webpack_exports__, "promise", (function() {
            return decorators_promise;
        }));
        __webpack_require__.d(__webpack_exports__, "isPerc", (function() {
            return isPerc;
        }));
        __webpack_require__.d(__webpack_exports__, "isPx", (function() {
            return isPx;
        }));
        __webpack_require__.d(__webpack_exports__, "toNum", (function() {
            return toNum;
        }));
        __webpack_require__.d(__webpack_exports__, "toPx", (function() {
            return toPx;
        }));
        __webpack_require__.d(__webpack_exports__, "toCSS", (function() {
            return toCSS;
        }));
        __webpack_require__.d(__webpack_exports__, "percOf", (function() {
            return percOf;
        }));
        __webpack_require__.d(__webpack_exports__, "normalizeDimension", (function() {
            return normalizeDimension;
        }));
        __webpack_require__.d(__webpack_exports__, "wrapPromise", (function() {
            return wrapPromise;
        }));
        __webpack_require__.d(__webpack_exports__, "KEY_CODES", (function() {
            return KEY_CODES;
        }));
        __webpack_require__.d(__webpack_exports__, "ATTRIBUTES", (function() {
            return ATTRIBUTES;
        }));
        __webpack_require__.d(__webpack_exports__, "UID_HASH_LENGTH", (function() {
            return UID_HASH_LENGTH;
        }));
        __webpack_require__.d(__webpack_exports__, "invalidProtocolRegex", (function() {
            return invalidProtocolRegex;
        }));
        __webpack_require__.d(__webpack_exports__, "htmlEntitiesRegex", (function() {
            return htmlEntitiesRegex;
        }));
        __webpack_require__.d(__webpack_exports__, "htmlCtrlEntityRegex", (function() {
            return htmlCtrlEntityRegex;
        }));
        __webpack_require__.d(__webpack_exports__, "ctrlCharactersRegex", (function() {
            return ctrlCharactersRegex;
        }));
        __webpack_require__.d(__webpack_exports__, "urlSchemeRegex", (function() {
            return urlSchemeRegex;
        }));
        __webpack_require__.d(__webpack_exports__, "relativeFirstCharacters", (function() {
            return relativeFirstCharacters;
        }));
        __webpack_require__.d(__webpack_exports__, "BLANK_URL", (function() {
            return BLANK_URL;
        }));
        __webpack_require__.d(__webpack_exports__, "sfvcScreens", (function() {
            return sfvcScreens;
        }));
        var sfvcScreens = {
            932: {
                textSizeHeights: [ 746, 742, 738 ],
                textSizeHeightsNoTabs: [ 854, 852, 850, 848 ],
                zoomHeight: {
                    1.15: [ 746, 742, 738 ],
                    1.25: [ 746, 743 ],
                    1.5: [ 746, 743 ],
                    1.75: [ 746, 742, 739 ],
                    2: [ 746, 742 ],
                    2.5: [ 745, 743 ],
                    3: [ 749 ],
                    3.01: [ 749 ]
                },
                maybeSafari: {
                    1: [ 732 ],
                    1.15: [ 733 ],
                    1.25: [ 738, 733 ],
                    1.5: [ 738, 732 ],
                    1.75: [ 732 ],
                    2: [ 738, 732 ],
                    2.5: [ 738, 733 ],
                    3: [ 743, 740, 734 ],
                    3.01: [ 743, 740, 734 ]
                }
            },
            926: {
                textSizeHeights: [ 752, 748, 744, 738 ],
                textSizeHeightsNoTabs: [ 860, 858, 856, 854 ],
                zoomHeight: {
                    1.15: [ 752, 747, 744, 738 ],
                    1.25: [ 753, 748, 744, 738 ],
                    1.5: [ 752, 749, 744, 738 ],
                    1.75: [ 753, 747, 744, 739 ],
                    2: [ 752, 748, 744 ],
                    2.5: [ 753, 748 ],
                    3: [ 753, 744 ]
                },
                maybeSafari: {
                    2: [ 738 ],
                    2.5: [ 745, 738 ],
                    3: [ 747, 738 ]
                }
            },
            896: {
                textSizeHeights: [ 721, 717, 713, 707 ],
                textSizeHeightsNoTabs: [ 829, 827, 825, 823 ],
                zoomHeight: {
                    1.15: [ 721, 716, 713, 707 ],
                    1.25: [ 721, 718, 713, 708 ],
                    1.5: [ 722, 717, 713 ],
                    1.75: [ 721, 718, 712, 707 ],
                    2: [ 722, 718, 714, 708 ],
                    2.5: [ 720, 718, 713, 708 ],
                    3: [ 720, 717, 708 ]
                },
                maybeSafari: {
                    1.5: [ 707 ],
                    3: [ 714 ]
                }
            },
            852: {
                textSizeHeights: [ 666, 662, 658 ],
                textSizeHeightsNoTabs: [ 774, 772, 770, 768 ],
                zoomHeight: {
                    1.15: [ 666, 662, 658 ],
                    1.25: [ 665, 661, 658 ],
                    1.5: [ 666, 662, 659 ],
                    1.75: [ 667, 662 ],
                    1.99: [ 663, 659 ],
                    2: [ 663, 659 ],
                    2.5: [ 665, 663 ],
                    3: [ 666, 663 ]
                },
                maybeSafari: {
                    1: [ 652 ],
                    1.15: [ 652 ],
                    1.25: [ 651 ],
                    1.5: [ 653 ],
                    1.75: [ 658, 653 ],
                    1.99: [ 655, 649 ],
                    2: [ 655, 649 ],
                    2.5: [ 658, 653 ],
                    3: [ 657, 651 ]
                }
            },
            844: {
                textSizeHeights: [ 670, 666, 662, 656 ],
                textSizeHeightsNoTabs: [ 778, 776, 774, 772 ],
                zoomHeight: {
                    1.15: [ 670, 666, 662 ],
                    1.25: [ 670, 666, 663, 656 ],
                    1.5: [ 671, 666, 662 ],
                    1.75: [ 670, 667, 662, 656 ],
                    2: [ 670, 666, 662 ],
                    2.5: [ 670, 663 ],
                    3: [ 669, 666, 663, 657 ]
                },
                maybeSafari: {
                    1.15: [ 656 ],
                    1.5: [ 656 ],
                    2: [ 656 ],
                    2.5: [ 665, 655 ],
                    3: [ 663 ]
                }
            },
            812: {
                textSizeHeights: [ 641, 637, 633, 627 ],
                textSizeHeightsNoTabs: [ 749, 747, 745, 743 ],
                zoomHeight: {
                    1.15: [ 641, 637, 633, 627 ],
                    1.25: [ 641, 638, 633, 628 ],
                    1.5: [ 641, 638, 633, 627 ],
                    1.75: [ 641, 637, 634 ],
                    2: [ 642, 638, 634, 628 ],
                    2.5: [ 640, 638, 633, 628 ],
                    3: [ 642, 633 ]
                },
                maybeSafari: {
                    1.75: [ 627 ],
                    3: [ 636, 627 ]
                }
            },
            736: {
                textSizeHeights: [ 628, 624, 620, 614 ],
                textSizeHeightsNoTabs: [ 736, 734, 732, 730 ],
                zoomHeight: {
                    1.15: [ 628, 624, 620, 614 ],
                    1.25: [ 628, 624, 620, 614 ],
                    1.5: [ 629, 624, 620 ],
                    1.75: [ 628, 625, 620, 614 ],
                    2: [ 628, 624, 620 ],
                    2.5: [ 628, 625, 620, 615 ],
                    3: [ 627, 624, 615 ]
                },
                maybeSafari: {
                    1.5: [ 614 ],
                    2: [ 614 ],
                    3: [ 621 ]
                }
            },
            667: {
                textSizeHeights: [ 559, 555, 551, 545 ],
                textSizeHeightsNoTabs: [ 667, 665, 663, 661 ],
                zoomHeight: {
                    1.15: [ 559, 555, 551, 545 ],
                    1.25: [ 559, 555, 551, 545 ],
                    1.5: [ 560, 555, 551 ],
                    1.75: [ 558, 555, 551 ],
                    2: [ 560, 556, 552, 546 ],
                    2.5: [ 560, 555, 550 ],
                    3: [ 558, 555, 546 ]
                },
                maybeSafari: {
                    1.5: [ 545 ],
                    1.75: [ 544 ],
                    2.5: [ 545 ],
                    3: [ 552 ]
                }
            }
        };
        function getUserAgent() {
            return window.navigator.mockUserAgent || window.navigator.userAgent;
        }
        var TABLET_PATTERN = /ip(a|ro)d|silk|xoom|playbook|tablet|kindle|Nexus 7|GT-P10|SC-01C|SHW-M180S|SM-T320|SGH-T849|SCH-I800|SHW-M180L|SPH-P100|SGH-I987|zt180|HTC( Flyer|_Flyer)|Sprint ATP51|ViewPad7|pandigital(sprnova|nova)|Ideos S7|Dell Streak 7|Advent Vega|A101IT|A70BHT|MID7015|Next2|nook|FOLIO|MB511.*RUTEM|Mac OS.*Silk/i;
        function isDevice(userAgent) {
            void 0 === userAgent && (userAgent = getUserAgent());
            return !!userAgent.match(/Android|webOS|iPhone|iPad|iPod|bada|Symbian|Palm|CriOS|BlackBerry|IEMobile|WindowsMobile|Opera Mini/i);
        }
        function isTablet(userAgent) {
            void 0 === userAgent && (userAgent = getUserAgent());
            return TABLET_PATTERN.test(userAgent);
        }
        function isWebView(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /(iPhone|iPod|iPad|Macintosh).*AppleWebKit(?!.*Safari)|.*WKWebView/i.test(ua) || /\bwv\b/.test(ua) || /Android.*Version\/(\d)\.(\d)/i.test(ua);
        }
        function isStandAlone() {
            return !0 === window.navigator.standalone || window.matchMedia("(display-mode: standalone)").matches;
        }
        function isFacebookWebView(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /FBAN/.test(ua) || /FBAV/.test(ua);
        }
        function isFirefox(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /Firefox/i.test(ua);
        }
        function isFirefoxIOS(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /FxiOS/i.test(ua);
        }
        function isEdgeIOS(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /EdgiOS/i.test(ua);
        }
        function isOperaMini(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /Opera Mini/i.test(ua);
        }
        function isAndroid(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /Android/.test(ua);
        }
        function isIos(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /iPhone|iPod|iPad/.test(ua);
        }
        function isIOS14(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /iPhone.*OS.*(1)?(?:(1)[0-4]| [0-9])_/.test(ua);
        }
        function isGoogleSearchApp(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /\bGSA\b/.test(ua);
        }
        function isQQBrowser(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /QQBrowser/.test(ua);
        }
        function isIosWebview(ua) {
            void 0 === ua && (ua = getUserAgent());
            return !!isIos(ua) && (!!isGoogleSearchApp(ua) || /.+AppleWebKit(?!.*Safari)|.*WKWebView/.test(ua));
        }
        function isSFVC(ua) {
            void 0 === ua && (ua = getUserAgent());
            if (isIos(ua)) {
                var height = window.innerHeight;
                var scale = Math.round(window.screen.width / window.innerWidth * 100) / 100;
                var computedHeight = Math.round(height * scale);
                var device = null;
                if (isIOS14(ua)) device = sfvcScreens[window.outerHeight]; else {
                    if (1 !== scale) return !0;
                    device = sfvcScreens[window.outerHeight];
                }
                return !device || (scale > 1 && device.zoomHeight && device.zoomHeight[scale] ? -1 !== device.zoomHeight[scale].indexOf(computedHeight) : -1 !== device.textSizeHeights.indexOf(computedHeight) || -1 !== device.textSizeHeightsNoTabs.indexOf(computedHeight));
            }
            return !1;
        }
        function isSFVCorSafari(ua) {
            void 0 === ua && (ua = getUserAgent());
            if (isIos(ua)) {
                var sfvc = isSFVC(ua);
                var device = isIOS14(ua) ? sfvcScreens[window.outerHeight] : null;
                if (!device) return !1;
                var height = window.innerHeight;
                var scale = Math.round(window.screen.width / window.innerWidth * 100) / 100;
                var computedHeight = Math.round(height * scale);
                var possibleSafariSizes = device.maybeSafari;
                var maybeSafari = !1;
                scale > 1 && possibleSafariSizes[scale] && -1 !== possibleSafariSizes[scale].indexOf(computedHeight) && (maybeSafari = !0);
                return sfvc || maybeSafari;
            }
            return !1;
        }
        function isAndroidWebview(ua) {
            void 0 === ua && (ua = getUserAgent());
            return !!isAndroid(ua) && /Version\/[\d.]+/.test(ua) && !isOperaMini(ua);
        }
        function device_isIE() {
            return !!window.document.documentMode || Boolean(window.navigator && window.navigator.userAgent && /Edge|MSIE|rv:11/i.test(window.navigator.userAgent));
        }
        function isIECompHeader() {
            var mHttp = window.document.querySelector('meta[http-equiv="X-UA-Compatible"]');
            var mContent = window.document.querySelector('meta[content="IE=edge"]');
            return !(!mHttp || !mContent);
        }
        function isElectron() {
            return !("undefined" == typeof process || !process.versions || !process.versions.electron);
        }
        function isIEIntranet() {
            if (window.document.documentMode) try {
                var status = window.status;
                window.status = "testIntranetMode";
                if ("testIntranetMode" === window.status) {
                    window.status = status;
                    return !0;
                }
                return !1;
            } catch (err) {
                return !1;
            }
            return !1;
        }
        function isMacOsCna() {
            var userAgent = getUserAgent();
            return /Macintosh.*AppleWebKit(?!.*Safari)/i.test(userAgent);
        }
        function supportsPopups(ua) {
            void 0 === ua && (ua = getUserAgent());
            return !(isWebView(ua) || isIosWebview(ua) || isAndroidWebview(ua) || isOperaMini(ua) || isFirefoxIOS(ua) || isEdgeIOS(ua) || isFacebookWebView(ua) || isQQBrowser(ua) || isElectron() || isMacOsCna() || isStandAlone());
        }
        function isChrome(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /Chrome|Chromium|CriOS/.test(ua) && !/SamsungBrowser|Silk|EdgA/.test(ua);
        }
        function isSafari(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /Safari/.test(ua) && !isChrome(ua) && !/Silk|FxiOS|EdgiOS/.test(ua);
        }
        function isApplePaySupported() {
            try {
                if (window.ApplePaySession && window.ApplePaySession.supportsVersion(3) && window.ApplePaySession.canMakePayments()) return !0;
            } catch (e) {
                return !1;
            }
            return !1;
        }
        function isCrossSiteTrackingEnabled(expectedCookieKey) {
            return -1 === window.document.cookie.indexOf(expectedCookieKey);
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function(o, p) {
                o.__proto__ = p;
                return o;
            })(o, p);
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            _setPrototypeOf(subClass, superClass);
        }
        var esm_extends = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/extends.js");
        var zalgo_promise_src = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var cross_domain_utils_src = __webpack_require__("./node_modules/@krakenjs/cross-domain-utils/src/index.js");
        function safeIndexOf(collection, item) {
            for (var i = 0; i < collection.length; i++) try {
                if (collection[i] === item) return i;
            } catch (err) {}
            return -1;
        }
        var weakmap_CrossDomainSafeWeakMap = function() {
            function CrossDomainSafeWeakMap() {
                this.name = void 0;
                this.weakmap = void 0;
                this.keys = void 0;
                this.values = void 0;
                this.name = "__weakmap_" + (1e9 * Math.random() >>> 0) + "__";
                if (function() {
                    if ("undefined" == typeof WeakMap) return !1;
                    if (void 0 === Object.freeze) return !1;
                    try {
                        var testWeakMap = new WeakMap;
                        var testKey = {};
                        Object.freeze(testKey);
                        testWeakMap.set(testKey, "__testvalue__");
                        return "__testvalue__" === testWeakMap.get(testKey);
                    } catch (err) {
                        return !1;
                    }
                }()) try {
                    this.weakmap = new WeakMap;
                } catch (err) {}
                this.keys = [];
                this.values = [];
            }
            var _proto = CrossDomainSafeWeakMap.prototype;
            _proto._cleanupClosedWindows = function() {
                var weakmap = this.weakmap;
                var keys = this.keys;
                for (var i = 0; i < keys.length; i++) {
                    var value = keys[i];
                    if (Object(cross_domain_utils_src.isWindow)(value) && Object(cross_domain_utils_src.isWindowClosed)(value)) {
                        if (weakmap) try {
                            weakmap.delete(value);
                        } catch (err) {}
                        keys.splice(i, 1);
                        this.values.splice(i, 1);
                        i -= 1;
                    }
                }
            };
            _proto.isSafeToReadWrite = function(key) {
                return !Object(cross_domain_utils_src.isWindow)(key);
            };
            _proto.set = function(key, value) {
                if (!key) throw new Error("WeakMap expected key");
                var weakmap = this.weakmap;
                if (weakmap) try {
                    weakmap.set(key, value);
                } catch (err) {
                    delete this.weakmap;
                }
                if (this.isSafeToReadWrite(key)) try {
                    var name = this.name;
                    var entry = key[name];
                    entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {
                        value: [ key, value ],
                        writable: !0
                    });
                    return;
                } catch (err) {}
                this._cleanupClosedWindows();
                var keys = this.keys;
                var values = this.values;
                var index = safeIndexOf(keys, key);
                if (-1 === index) {
                    keys.push(key);
                    values.push(value);
                } else values[index] = value;
            };
            _proto.get = function(key) {
                if (!key) throw new Error("WeakMap expected key");
                var weakmap = this.weakmap;
                if (weakmap) try {
                    if (weakmap.has(key)) return weakmap.get(key);
                } catch (err) {
                    delete this.weakmap;
                }
                if (this.isSafeToReadWrite(key)) try {
                    var entry = key[this.name];
                    return entry && entry[0] === key ? entry[1] : void 0;
                } catch (err) {}
                this._cleanupClosedWindows();
                var index = safeIndexOf(this.keys, key);
                if (-1 !== index) return this.values[index];
            };
            _proto.delete = function(key) {
                if (!key) throw new Error("WeakMap expected key");
                var weakmap = this.weakmap;
                if (weakmap) try {
                    weakmap.delete(key);
                } catch (err) {
                    delete this.weakmap;
                }
                if (this.isSafeToReadWrite(key)) try {
                    var entry = key[this.name];
                    entry && entry[0] === key && (entry[0] = entry[1] = void 0);
                } catch (err) {}
                this._cleanupClosedWindows();
                var keys = this.keys;
                var index = safeIndexOf(keys, key);
                if (-1 !== index) {
                    keys.splice(index, 1);
                    this.values.splice(index, 1);
                }
            };
            _proto.has = function(key) {
                if (!key) throw new Error("WeakMap expected key");
                var weakmap = this.weakmap;
                if (weakmap) try {
                    if (weakmap.has(key)) return !0;
                } catch (err) {
                    delete this.weakmap;
                }
                if (this.isSafeToReadWrite(key)) try {
                    var entry = key[this.name];
                    return !(!entry || entry[0] !== key);
                } catch (err) {}
                this._cleanupClosedWindows();
                return -1 !== safeIndexOf(this.keys, key);
            };
            _proto.getOrSet = function(key, getter) {
                if (this.has(key)) return this.get(key);
                var value = getter();
                this.set(key, value);
                return value;
            };
            return CrossDomainSafeWeakMap;
        }();
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        function _isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                Date.prototype.toString.call(Reflect.construct(Date, [], (function() {})));
                return !0;
            } catch (e) {
                return !1;
            }
        }
        function construct_construct(Parent, args, Class) {
            return (construct_construct = _isNativeReflectConstruct() ? Reflect.construct : function(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a));
                Class && _setPrototypeOf(instance, Class.prototype);
                return instance;
            }).apply(null, arguments);
        }
        function wrapNativeSuper_wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map : void 0;
            return (wrapNativeSuper_wrapNativeSuper = function(Class) {
                if (null === Class || !(fn = Class, -1 !== Function.toString.call(fn).indexOf("[native code]"))) return Class;
                var fn;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return construct_construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                });
                return _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        var KEY_CODES = {
            ENTER: 13,
            SPACE: 32
        };
        var ATTRIBUTES = {
            UID: "data-uid"
        };
        var UID_HASH_LENGTH = 30;
        var invalidProtocolRegex = /([^\w]*)(javascript|data|vbscript)/im;
        var htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
        var htmlCtrlEntityRegex = /&(newline|tab);/gi;
        var ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
        var urlSchemeRegex = /^.+(:|&colon;)/gim;
        var relativeFirstCharacters = [ ".", "/" ];
        var BLANK_URL = "about:blank";
        function isElement(element) {
            var passed = !1;
            try {
                (element instanceof window.Element || null !== element && "object" == typeof element && 1 === element.nodeType && "object" == typeof element.style && "object" == typeof element.ownerDocument) && (passed = !0);
            } catch (_) {}
            return passed;
        }
        function getFunctionName(fn) {
            return fn.name || fn.__name__ || fn.displayName || "anonymous";
        }
        function setFunctionName(fn, name) {
            try {
                delete fn.name;
                fn.name = name;
            } catch (err) {}
            fn.__name__ = fn.displayName = name;
            return fn;
        }
        function base64encode(str) {
            if ("function" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (function(m, p1) {
                return String.fromCharCode(parseInt(p1, 16));
            }))).replace(/[=]/g, "");
            if ("undefined" != typeof Buffer) return Buffer.from(str, "utf8").toString("base64").replace(/[=]/g, "");
            throw new Error("Can not find window.btoa or Buffer");
        }
        function base64decode(str) {
            if ("function" == typeof atob) return decodeURIComponent([].map.call(atob(str), (function(c) {
                return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
            })).join(""));
            if ("undefined" != typeof Buffer) return Buffer.from(str, "base64").toString("utf8");
            throw new Error("Can not find window.atob or Buffer");
        }
        function uniqueID() {
            var chars = "0123456789abcdef";
            return "uid_" + "xxxxxxxxxx".replace(/./g, (function() {
                return chars.charAt(Math.floor(Math.random() * chars.length));
            })) + "_" + base64encode((new Date).toISOString().slice(11, 19).replace("T", ".")).replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
        }
        function getGlobal() {
            if ("undefined" != typeof window) return window;
            if ("undefined" != typeof window) return window;
            if ("undefined" != typeof global) return global;
            throw new Error("No global found");
        }
        var objectIDs;
        function getObjectID(obj) {
            objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap;
            if (null == obj || "object" != typeof obj && "function" != typeof obj) throw new Error("Invalid object");
            var uid = objectIDs.get(obj);
            if (!uid) {
                uid = typeof obj + ":" + uniqueID();
                objectIDs.set(obj, uid);
            }
            return uid;
        }
        function serializeArgs(args) {
            try {
                return JSON.stringify([].slice.call(args), (function(subkey, val) {
                    return "function" == typeof val ? "memoize[" + getObjectID(val) + "]" : isElement(val) ? {} : val;
                }));
            } catch (err) {
                throw new Error("Arguments not serializable -- can not be used to memoize");
            }
        }
        function getEmptyObject() {
            return {};
        }
        var memoizeGlobalIndex = 0;
        var memoizeGlobalIndexValidFrom = 0;
        function memoize(method, options) {
            void 0 === options && (options = {});
            var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;
            var simpleCache;
            var thisCache;
            var memoizeIndex = memoizeGlobalIndex;
            memoizeGlobalIndex += 1;
            var memoizedFunction = function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                if (memoizeIndex < memoizeGlobalIndexValidFrom) {
                    simpleCache = null;
                    thisCache = null;
                    memoizeIndex = memoizeGlobalIndex;
                    memoizeGlobalIndex += 1;
                }
                var cache;
                cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};
                var cacheKey;
                try {
                    cacheKey = serializeArgs(args);
                } catch (_unused) {
                    return method.apply(this, arguments);
                }
                var cacheResult = cache[cacheKey];
                if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {
                    delete cache[cacheKey];
                    cacheResult = null;
                }
                if (cacheResult) return cacheResult.value;
                var time = Date.now();
                var value = method.apply(this, arguments);
                cache[cacheKey] = {
                    time: time,
                    value: value
                };
                return value;
            };
            memoizedFunction.reset = function() {
                simpleCache = null;
                thisCache = null;
            };
            return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + "::memoized");
        }
        memoize.clear = function() {
            memoizeGlobalIndexValidFrom = memoizeGlobalIndex;
        };
        function promiseIdentity(item) {
            return zalgo_promise_src.ZalgoPromise.resolve(item);
        }
        function memoizePromise(method) {
            var cache = {};
            function memoizedPromiseFunction() {
                var _arguments = arguments, _this = this;
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                var key = serializeArgs(args);
                if (cache.hasOwnProperty(key)) return cache[key];
                cache[key] = zalgo_promise_src.ZalgoPromise.try((function() {
                    return method.apply(_this, _arguments);
                })).finally((function() {
                    delete cache[key];
                }));
                return cache[key];
            }
            memoizedPromiseFunction.reset = function() {
                cache = {};
            };
            return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + "::promiseMemoized");
        }
        function promisify(method, options) {
            void 0 === options && (options = {});
            function promisifiedFunction() {
                return zalgo_promise_src.ZalgoPromise.try(method, this, arguments);
            }
            options.name && (promisifiedFunction.displayName = options.name + ":promisified");
            return setFunctionName(promisifiedFunction, getFunctionName(method) + "::promisified");
        }
        function inlineMemoize(method, logic, args) {
            void 0 === args && (args = []);
            var cache = method.__inline_memoize_cache__ = method.__inline_memoize_cache__ || {};
            var key = serializeArgs(args);
            return cache.hasOwnProperty(key) ? cache[key] : cache[key] = logic.apply(void 0, args);
        }
        function util_noop() {}
        function once(method) {
            var called = !1;
            return setFunctionName((function() {
                if (!called) {
                    called = !0;
                    return method.apply(this, arguments);
                }
            }), getFunctionName(method) + "::once");
        }
        function hashStr(str) {
            var hash = 0;
            for (var i = 0; i < str.length; i++) hash += str[i].charCodeAt(0) * Math.pow(i % 10 + 1, 5);
            return Math.floor(Math.pow(Math.sqrt(hash), 5));
        }
        function strHashStr(str) {
            var hash = "";
            for (var i = 0; i < str.length; i++) {
                var total = str[i].charCodeAt(0) * i;
                str[i + 1] && (total += str[i + 1].charCodeAt(0) * (i - 1));
                hash += String.fromCharCode(97 + Math.abs(total) % 26);
            }
            return hash;
        }
        function match(str, pattern) {
            var regmatch = str.match(pattern);
            if (regmatch) return regmatch[1];
        }
        function awaitKey(obj, key) {
            return new zalgo_promise_src.ZalgoPromise((function(resolve) {
                var value = obj[key];
                if (value) return resolve(value);
                delete obj[key];
                Object.defineProperty(obj, key, {
                    configurable: !0,
                    set: function(item) {
                        (value = item) && resolve(value);
                    },
                    get: function() {
                        return value;
                    }
                });
            }));
        }
        function stringifyError(err, level) {
            void 0 === level && (level = 1);
            if (level >= 3) return "stringifyError stack overflow";
            try {
                if (!err) return "<unknown error: " + {}.toString.call(err) + ">";
                if ("string" == typeof err) return err;
                if (err instanceof Error) {
                    var stack = err && err.stack;
                    var message = err && err.message;
                    if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + "\n" + stack;
                    if (stack) return stack;
                    if (message) return message;
                }
                return err && err.toString && "function" == typeof err.toString ? err.toString() : {}.toString.call(err);
            } catch (newErr) {
                return "Error while stringifying error: " + stringifyError(newErr, level + 1);
            }
        }
        function stringifyErrorMessage(err) {
            var defaultMessage = "<unknown error: " + {}.toString.call(err) + ">";
            return err ? err instanceof Error ? err.message || defaultMessage : "string" == typeof err.message && err.message || defaultMessage : defaultMessage;
        }
        function stringify(item) {
            return "string" == typeof item ? item : item && item.toString && "function" == typeof item.toString ? item.toString() : {}.toString.call(item);
        }
        function domainMatches(hostname, domain) {
            var index = (hostname = hostname.split("://")[1]).indexOf(domain);
            return -1 !== index && hostname.slice(index) === domain;
        }
        function patchMethod(obj, name, handler) {
            var original = obj[name];
            obj[name] = function() {
                var _arguments2 = arguments, _this2 = this;
                return handler({
                    context: this,
                    args: [].slice.call(arguments),
                    original: original,
                    callOriginal: function() {
                        return original.apply(_this2, _arguments2);
                    }
                });
            };
        }
        function extend(obj, source) {
            if (!source) return obj;
            if (Object.assign) return Object.assign(obj, source);
            for (var key in source) source.hasOwnProperty(key) && (obj[key] = source[key]);
            return obj;
        }
        function util_values(obj) {
            if (Object.values) return Object.values(obj);
            var result = [];
            for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);
            return result;
        }
        var memoizedValues = memoize(util_values);
        function perc(pixels, percentage) {
            return Math.round(pixels * percentage / 100);
        }
        function min() {
            return Math.min.apply(Math, arguments);
        }
        function max() {
            return Math.max.apply(Math, arguments);
        }
        function roundUp(num, nearest) {
            var remainder = num % nearest;
            return remainder ? num - remainder + nearest : num;
        }
        function regexMap(str, regexp, handler) {
            var results = [];
            str.replace(regexp, (function(item) {
                results.push(handler ? handler.apply(null, arguments) : item);
            }));
            return results;
        }
        function svgToBase64(svg) {
            return "data:image/svg+xml;base64," + base64encode(svg);
        }
        function objFilter(obj, filter) {
            void 0 === filter && (filter = Boolean);
            var result = {};
            for (var key in obj) obj.hasOwnProperty(key) && filter(obj[key], key) && (result[key] = obj[key]);
            return result;
        }
        function identity(item) {
            return item;
        }
        function regexTokenize(text, regexp) {
            var result = [];
            text.replace(regexp, (function(token) {
                result.push(token);
                return "";
            }));
            return result;
        }
        function promiseDebounce(method, delay) {
            void 0 === delay && (delay = 50);
            var promise;
            var timeout;
            return setFunctionName((function() {
                timeout && clearTimeout(timeout);
                var localPromise = promise = promise || new zalgo_promise_src.ZalgoPromise;
                timeout = setTimeout((function() {
                    promise = null;
                    timeout = null;
                    zalgo_promise_src.ZalgoPromise.try(method).then((function(result) {
                        localPromise.resolve(result);
                    }), (function(err) {
                        localPromise.reject(err);
                    }));
                }), delay);
                return localPromise;
            }), getFunctionName(method) + "::promiseDebounced");
        }
        function safeInterval(method, time) {
            var timeout;
            !function loop() {
                timeout = setTimeout((function() {
                    method();
                    loop();
                }), time);
            }();
            return {
                cancel: function() {
                    clearTimeout(timeout);
                }
            };
        }
        function isInteger(str) {
            return Boolean(str.match(/^[0-9]+$/));
        }
        function isFloat(str) {
            return Boolean(str.match(/^[0-9]+\.[0-9]+$/));
        }
        function serializePrimitive(value) {
            return value.toString();
        }
        function deserializePrimitive(value) {
            return "true" === value || "false" !== value && (isInteger(value) ? parseInt(value, 10) : isFloat(value) ? parseFloat(value) : value);
        }
        function dotify(obj, prefix, newobj) {
            void 0 === prefix && (prefix = "");
            void 0 === newobj && (newobj = {});
            prefix = prefix ? prefix + "." : prefix;
            for (var key in obj) obj.hasOwnProperty(key) && null != obj[key] && "function" != typeof obj[key] && (obj[key] && Array.isArray(obj[key]) && obj[key].length && obj[key].every((function(val) {
                return "object" != typeof val;
            })) ? newobj["" + prefix + key + "[]"] = obj[key].join(",") : obj[key] && "object" == typeof obj[key] ? newobj = dotify(obj[key], "" + prefix + key, newobj) : newobj["" + prefix + key] = serializePrimitive(obj[key]));
            return newobj;
        }
        function undotify(obj) {
            var result = {};
            for (var key in obj) if (obj.hasOwnProperty(key) && "string" == typeof obj[key]) {
                var value = obj[key];
                if (key.match(/^.+\[\]$/)) {
                    key = key.slice(0, -2);
                    value = value.split(",").map(deserializePrimitive);
                } else value = deserializePrimitive(value);
                var keyResult = result;
                var parts = key.split(".");
                for (var i = 0; i < parts.length; i++) {
                    var part = parts[i];
                    var isLast = i + 1 === parts.length;
                    var isIndex = !isLast && isInteger(parts[i + 1]);
                    if ("constructor" === part || "prototype" === part || "__proto__" === part) throw new Error("Disallowed key: " + part);
                    isLast ? keyResult[part] = value : keyResult = keyResult[part] = keyResult[part] || (isIndex ? [] : {});
                }
            }
            return result;
        }
        function eventEmitter() {
            var triggered = {};
            var handlers = {};
            var emitter = {
                on: function(eventName, handler) {
                    var handlerList = handlers[eventName] = handlers[eventName] || [];
                    handlerList.push(handler);
                    var cancelled = !1;
                    return {
                        cancel: function() {
                            if (!cancelled) {
                                cancelled = !0;
                                handlerList.splice(handlerList.indexOf(handler), 1);
                            }
                        }
                    };
                },
                once: function(eventName, handler) {
                    var listener = emitter.on(eventName, (function() {
                        listener.cancel();
                        handler();
                    }));
                    return listener;
                },
                trigger: function(eventName) {
                    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) args[_key3 - 1] = arguments[_key3];
                    var handlerList = handlers[eventName];
                    var promises = [];
                    if (handlerList) {
                        var _loop = function() {
                            var handler = handlerList[_i2];
                            promises.push(zalgo_promise_src.ZalgoPromise.try((function() {
                                return handler.apply(void 0, args);
                            })));
                        };
                        for (var _i2 = 0; _i2 < handlerList.length; _i2++) _loop();
                    }
                    return zalgo_promise_src.ZalgoPromise.all(promises).then(util_noop);
                },
                triggerOnce: function(eventName) {
                    if (triggered[eventName]) return zalgo_promise_src.ZalgoPromise.resolve();
                    triggered[eventName] = !0;
                    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) args[_key4 - 1] = arguments[_key4];
                    return emitter.trigger.apply(emitter, [ eventName ].concat(args));
                },
                reset: function() {
                    handlers = {};
                }
            };
            return emitter;
        }
        function camelToDasherize(string) {
            return string.replace(/([A-Z])/g, (function(g) {
                return "-" + g.toLowerCase();
            }));
        }
        function dasherizeToCamel(string) {
            return string.replace(/-([a-z])/g, (function(g) {
                return g[1].toUpperCase();
            }));
        }
        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
        }
        function util_get(item, path, def) {
            if (!path) return def;
            var pathParts = path.split(".");
            for (var i = 0; i < pathParts.length; i++) {
                if ("object" != typeof item || null === item) return def;
                item = item[pathParts[i]];
            }
            return void 0 === item ? def : item;
        }
        function safeTimeout(method, time) {
            var interval = safeInterval((function() {
                if ((time -= 100) <= 0) {
                    interval.cancel();
                    method();
                }
            }), 100);
        }
        function defineLazyProp(obj, key, getter) {
            if (Array.isArray(obj)) {
                if ("number" != typeof key) throw new TypeError("Array key must be number");
            } else if ("object" == typeof obj && null !== obj && "string" != typeof key) throw new TypeError("Object key must be string");
            Object.defineProperty(obj, key, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    delete obj[key];
                    var value = getter();
                    obj[key] = value;
                    return value;
                },
                set: function(value) {
                    delete obj[key];
                    obj[key] = value;
                }
            });
        }
        function arrayFrom(item) {
            return [].slice.call(item);
        }
        function isObject(item) {
            return "object" == typeof item && null !== item;
        }
        function isObjectObject(obj) {
            return isObject(obj) && "[object Object]" === {}.toString.call(obj);
        }
        function isPlainObject(obj) {
            if (!isObjectObject(obj)) return !1;
            var constructor = obj.constructor;
            if ("function" != typeof constructor) return !1;
            var prototype = constructor.prototype;
            return !!isObjectObject(prototype) && !!prototype.hasOwnProperty("isPrototypeOf");
        }
        function replaceObject(item, replacer, fullKey) {
            void 0 === fullKey && (fullKey = "");
            if (Array.isArray(item)) {
                var length = item.length;
                var result = [];
                var _loop2 = function(i) {
                    defineLazyProp(result, i, (function() {
                        var itemKey = fullKey ? fullKey + "." + i : "" + i;
                        var child = replacer(item[i], i, itemKey);
                        (isPlainObject(child) || Array.isArray(child)) && (child = replaceObject(child, replacer, itemKey));
                        return child;
                    }));
                };
                for (var i = 0; i < length; i++) _loop2(i);
                return result;
            }
            if (isPlainObject(item)) {
                var _result = {};
                var _loop3 = function(key) {
                    if (!item.hasOwnProperty(key)) return 1;
                    defineLazyProp(_result, key, (function() {
                        var itemKey = fullKey ? fullKey + "." + key : "" + key;
                        var child = replacer(item[key], key, itemKey);
                        (isPlainObject(child) || Array.isArray(child)) && (child = replaceObject(child, replacer, itemKey));
                        return child;
                    }));
                };
                for (var key in item) _loop3(key);
                return _result;
            }
            throw new Error("Pass an object or array");
        }
        function copyProp(source, target, name, def) {
            if (source.hasOwnProperty(name)) {
                var descriptor = Object.getOwnPropertyDescriptor(source, name);
                Object.defineProperty(target, name, descriptor);
            } else target[name] = def;
        }
        function regex(pattern, string, start) {
            void 0 === start && (start = 0);
            "string" == typeof pattern && (pattern = new RegExp(pattern));
            var result = string.slice(start).match(pattern);
            if (result) {
                var index = result.index;
                var regmatch = result[0];
                return {
                    text: regmatch,
                    groups: result.slice(1),
                    start: start + index,
                    end: start + index + regmatch.length,
                    length: regmatch.length,
                    replace: function(text) {
                        return regmatch ? "" + regmatch.slice(0, start + index) + text + regmatch.slice(index + regmatch.length) : "";
                    }
                };
            }
        }
        function regexAll(pattern, string) {
            var matches = [];
            var start = 0;
            for (;;) {
                var regmatch = regex(pattern, string, start);
                if (!regmatch) break;
                matches.push(regmatch);
                start = match.end;
            }
            return matches;
        }
        function isDefined(value) {
            return null != value;
        }
        function cycle(method) {
            return zalgo_promise_src.ZalgoPromise.try(method).then((function() {
                return cycle(method);
            }));
        }
        function debounce(method, time) {
            void 0 === time && (time = 100);
            var timeout;
            return setFunctionName((function() {
                var _arguments3 = arguments, _this3 = this;
                clearTimeout(timeout);
                timeout = setTimeout((function() {
                    return method.apply(_this3, _arguments3);
                }), time);
            }), getFunctionName(method) + "::debounced");
        }
        function isRegex(item) {
            return "[object RegExp]" === {}.toString.call(item);
        }
        var util_weakMapMemoize = function(method) {
            var weakmap = new weakmap_CrossDomainSafeWeakMap;
            return function(arg) {
                var _this4 = this;
                return weakmap.getOrSet(arg, (function() {
                    return method.call(_this4, arg);
                }));
            };
        };
        var util_weakMapMemoizePromise = function(method) {
            var weakmap = new weakmap_CrossDomainSafeWeakMap;
            return function(arg) {
                var _this5 = this;
                return weakmap.getOrSet(arg, (function() {
                    return method.call(_this5, arg).finally((function() {
                        weakmap.delete(arg);
                    }));
                }));
            };
        };
        function getOrSet(obj, key, getter) {
            if (obj.hasOwnProperty(key)) return obj[key];
            var val = getter();
            obj[key] = val;
            return val;
        }
        function cleanup(obj) {
            var tasks = [];
            var cleaned = !1;
            var cleanErr;
            var cleaner = {
                set: function(name, item) {
                    if (!cleaned) {
                        obj[name] = item;
                        cleaner.register((function() {
                            delete obj[name];
                        }));
                    }
                    return item;
                },
                register: function(method) {
                    var task = once((function() {
                        return method(cleanErr);
                    }));
                    cleaned ? method(cleanErr) : tasks.push(task);
                    return {
                        cancel: function() {
                            var index = tasks.indexOf(task);
                            -1 !== index && tasks.splice(index, 1);
                        }
                    };
                },
                all: function(err) {
                    cleanErr = err;
                    var results = [];
                    cleaned = !0;
                    for (;tasks.length; ) {
                        var task = tasks.shift();
                        results.push(task());
                    }
                    return zalgo_promise_src.ZalgoPromise.all(results).then(util_noop);
                }
            };
            return cleaner;
        }
        function tryCatch(fn) {
            var result;
            var error;
            try {
                result = fn();
            } catch (err) {
                error = err;
            }
            return {
                result: result,
                error: error
            };
        }
        function removeFromArray(arr, item) {
            var index = arr.indexOf(item);
            -1 !== index && arr.splice(index, 1);
        }
        function assertExists(name, thing) {
            if (null == thing) throw new Error("Expected " + name + " to be present");
            return thing;
        }
        function unique(arr) {
            var result = {};
            for (var _i4 = 0; _i4 < arr.length; _i4++) result[arr[_i4]] = !0;
            return Object.keys(result);
        }
        var constHas = function(constant, value) {
            return -1 !== memoizedValues(constant).indexOf(value);
        };
        function dedupeErrors(handler) {
            var seenErrors = [];
            var seenStringifiedErrors = {};
            return function(err) {
                if (-1 === seenErrors.indexOf(err)) {
                    seenErrors.push(err);
                    var stringifiedError = stringifyError(err);
                    if (!seenStringifiedErrors[stringifiedError]) {
                        seenStringifiedErrors[stringifiedError] = !0;
                        return handler(err);
                    }
                }
            };
        }
        var util_ExtendableError = function(_Error) {
            _inheritsLoose(ExtendableError, _Error);
            function ExtendableError(message) {
                var _this6;
                (_this6 = _Error.call(this, message) || this).name = _this6.constructor.name;
                "function" == typeof Error.captureStackTrace ? Error.captureStackTrace(function(self) {
                    if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return self;
                }(_this6), _this6.constructor) : _this6.stack = new Error(message).stack;
                return _this6;
            }
            return ExtendableError;
        }(wrapNativeSuper_wrapNativeSuper(Error));
        function sanitizeUrl(url) {
            if (!url) return BLANK_URL;
            var sanitizedUrl = (str = url, str.replace(ctrlCharactersRegex, "").replace(htmlEntitiesRegex, (function(matchRegex, dec) {
                return String.fromCharCode(dec);
            }))).replace(htmlCtrlEntityRegex, "").replace(ctrlCharactersRegex, "").trim();
            var str;
            if (!sanitizedUrl) return BLANK_URL;
            if (function(url) {
                return relativeFirstCharacters.indexOf(url[0]) > -1;
            }(sanitizedUrl)) return sanitizedUrl;
            var urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);
            return urlSchemeParseResults && invalidProtocolRegex.test(urlSchemeParseResults[0]) ? BLANK_URL : sanitizedUrl;
        }
        function getBody() {
            var body = document.body;
            if (!body) throw new Error("Body element not found");
            return body;
        }
        function isDocumentReady() {
            return Boolean(document.body) && "complete" === document.readyState;
        }
        function isDocumentInteractive() {
            return Boolean(document.body) && "interactive" === document.readyState;
        }
        function urlEncode(str) {
            return encodeURIComponent(str);
        }
        function waitForWindowReady() {
            return inlineMemoize(waitForWindowReady, (function() {
                return new zalgo_promise_src.ZalgoPromise((function(resolve) {
                    isDocumentReady() && resolve();
                    window.addEventListener("load", (function() {
                        return resolve();
                    }));
                }));
            }));
        }
        var waitForDocumentReady = memoize((function() {
            return new zalgo_promise_src.ZalgoPromise((function(resolve) {
                if (isDocumentReady() || isDocumentInteractive()) return resolve();
                var interval = setInterval((function() {
                    if (isDocumentReady() || isDocumentInteractive()) {
                        clearInterval(interval);
                        return resolve();
                    }
                }), 10);
            }));
        }));
        function waitForDocumentBody() {
            return zalgo_promise_src.ZalgoPromise.try((function() {
                return document.body ? document.body : waitForDocumentReady().then((function() {
                    if (document.body) return document.body;
                    throw new Error("Document ready but document.body not present");
                }));
            }));
        }
        function parseQuery(queryString) {
            return inlineMemoize(parseQuery, (function() {
                var params = {};
                if (!queryString) return params;
                if (-1 === queryString.indexOf("=")) return params;
                for (var _i2 = 0, _queryString$split2 = queryString.split("&"); _i2 < _queryString$split2.length; _i2++) {
                    var pair = _queryString$split2[_i2];
                    (pair = pair.split("="))[0] && pair[1] && (params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]));
                }
                return params;
            }), [ queryString ]);
        }
        function getQueryParam(name) {
            return parseQuery(window.location.search.slice(1))[name];
        }
        function urlWillRedirectPage(url) {
            return -1 === url.indexOf("#") || 0 !== url.indexOf("#") && url.split("#")[0] !== window.location.href.split("#")[0];
        }
        function formatQuery(obj) {
            void 0 === obj && (obj = {});
            return Object.keys(obj).filter((function(key) {
                return "string" == typeof obj[key] || "boolean" == typeof obj[key];
            })).map((function(key) {
                var val = obj[key];
                if ("string" != typeof val && "boolean" != typeof val) throw new TypeError("Invalid type for query");
                return urlEncode(key) + "=" + urlEncode(val.toString());
            })).join("&");
        }
        function extendQuery(originalQuery, props) {
            void 0 === props && (props = {});
            return props && Object.keys(props).length ? formatQuery(Object(esm_extends.default)({}, parseQuery(originalQuery), props)) : originalQuery;
        }
        function extendUrl(url, options) {
            var query = options.query || {};
            var hash = options.hash || {};
            var originalUrl;
            var originalHash;
            var _url$split = url.split("#");
            originalHash = _url$split[1];
            var _originalUrl$split = (originalUrl = _url$split[0]).split("?");
            originalUrl = _originalUrl$split[0];
            var queryString = extendQuery(_originalUrl$split[1], query);
            var hashString = extendQuery(originalHash, hash);
            queryString && (originalUrl = originalUrl + "?" + queryString);
            hashString && (originalUrl = originalUrl + "#" + hashString);
            return originalUrl;
        }
        function redirect(url, win) {
            void 0 === win && (win = window);
            return new zalgo_promise_src.ZalgoPromise((function(resolve) {
                win.location = url;
                urlWillRedirectPage(url) || resolve();
            }));
        }
        function hasMetaViewPort() {
            var meta = document.querySelector("meta[name=viewport]");
            return !(isDevice() && window.screen.width < 660 && !meta);
        }
        function isElementVisible(el) {
            return Boolean(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
        }
        function getPerformance() {
            return inlineMemoize(getPerformance, (function() {
                var performance = window.performance;
                if (performance && performance.now && performance.timing && performance.timing.connectEnd && performance.timing.navigationStart && Math.abs(performance.now() - Date.now()) > 1e3 && performance.now() - (performance.timing.connectEnd - performance.timing.navigationStart) > 0) return performance;
            }));
        }
        function enablePerformance() {
            return Boolean(getPerformance());
        }
        function getPageRenderTime() {
            return waitForDocumentReady().then((function() {
                var performance = getPerformance();
                if (performance) {
                    var timing = performance.timing;
                    return timing.connectEnd && timing.domInteractive ? timing.domInteractive - timing.connectEnd : void 0;
                }
            }));
        }
        function htmlEncode(html) {
            void 0 === html && (html = "");
            return html.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/\//g, "&#x2F;");
        }
        function isBrowser() {
            return "undefined" != typeof window && void 0 !== window.location;
        }
        function querySelectorAll(selector, doc) {
            void 0 === doc && (doc = window.document);
            return [].slice.call(doc.querySelectorAll(selector));
        }
        function onClick(element, handler) {
            element.addEventListener("touchstart", util_noop, {
                passive: !0
            });
            element.addEventListener("click", handler);
            element.addEventListener("keypress", (function(event) {
                if (event.keyCode === KEY_CODES.ENTER || event.keyCode === KEY_CODES.SPACE) return handler(event);
            }));
        }
        function getScript(_ref) {
            var _ref$host = _ref.host, host = void 0 === _ref$host ? window.location.host : _ref$host, path = _ref.path, _ref$reverse = _ref.reverse, reverse = void 0 !== _ref$reverse && _ref$reverse;
            return inlineMemoize(getScript, (function() {
                var url = "" + host + path;
                var scripts = [].slice.call(document.getElementsByTagName("script"));
                reverse && scripts.reverse();
                for (var _i4 = 0; _i4 < scripts.length; _i4++) {
                    var script = scripts[_i4];
                    if (script.src && script.src.replace(/^https?:\/\//, "").split("?")[0] === url) return script;
                }
            }), [ path ]);
        }
        function isLocalStorageEnabled() {
            return inlineMemoize(isLocalStorageEnabled, (function() {
                try {
                    if ("undefined" == typeof window) return !1;
                    if (window.localStorage) {
                        var value = Math.random().toString();
                        window.localStorage.setItem("__test__localStorage__", value);
                        var result = window.localStorage.getItem("__test__localStorage__");
                        window.localStorage.removeItem("__test__localStorage__");
                        if (value === result) return !0;
                    }
                } catch (err) {}
                return !1;
            }));
        }
        function getBrowserLocales() {
            var nav = window.navigator;
            var locales = nav.languages ? [].concat(nav.languages) : [];
            nav.language && locales.push(nav.language);
            nav.userLanguage && locales.push(nav.userLanguage);
            return locales.map((function(locale) {
                if (locale && locale.match(/^[a-z]{2}[-_][A-Z]{2}$/)) {
                    var _locale$split = locale.split(/[-_]/);
                    return {
                        country: _locale$split[1],
                        lang: _locale$split[0]
                    };
                }
                return locale && locale.match(/^[a-z]{2}$/) ? {
                    lang: locale
                } : null;
            })).filter(Boolean);
        }
        function appendChild(container, child) {
            container.appendChild(child);
        }
        function getElementSafe(id, doc) {
            void 0 === doc && (doc = document);
            return isElement(id) ? id : "string" == typeof id ? doc.querySelector(id) : void 0;
        }
        function getElement(id, doc) {
            void 0 === doc && (doc = document);
            var element = getElementSafe(id, doc);
            if (element) return element;
            throw new Error("Can not find element: " + stringify(id));
        }
        function elementReady(id) {
            return new zalgo_promise_src.ZalgoPromise((function(resolve, reject) {
                var name = stringify(id);
                var el = getElementSafe(id);
                if (el) return resolve(el);
                if (isDocumentReady()) return reject(new Error("Document is ready and element " + name + " does not exist"));
                var interval = setInterval((function() {
                    if (el = getElementSafe(id)) {
                        resolve(el);
                        clearInterval(interval);
                    } else if (isDocumentReady()) {
                        clearInterval(interval);
                        return reject(new Error("Document is ready and element " + name + " does not exist"));
                    }
                }), 10);
            }));
        }
        var dom_PopupOpenError = function(_ExtendableError) {
            _inheritsLoose(PopupOpenError, _ExtendableError);
            function PopupOpenError() {
                return _ExtendableError.apply(this, arguments) || this;
            }
            return PopupOpenError;
        }(util_ExtendableError);
        function popup(url, options) {
            var _options$closeOnUnloa = (options = options || {}).closeOnUnload, closeOnUnload = void 0 === _options$closeOnUnloa ? 1 : _options$closeOnUnloa, _options$name = options.name, name = void 0 === _options$name ? "" : _options$name, width = options.width, height = options.height;
            var top = 0;
            var left = 0;
            width && (window.outerWidth ? left = Math.round((window.outerWidth - width) / 2) + window.screenX : window.screen.width && (left = Math.round((window.screen.width - width) / 2)));
            height && (window.outerHeight ? top = Math.round((window.outerHeight - height) / 2) + window.screenY : window.screen.height && (top = Math.round((window.screen.height - height) / 2)));
            delete options.closeOnUnload;
            delete options.name;
            width && height && (options = Object(esm_extends.default)({
                top: top,
                left: left,
                width: width,
                height: height,
                status: 1,
                toolbar: 0,
                menubar: 0,
                resizable: 1,
                scrollbars: 1
            }, options));
            var params = Object.keys(options).map((function(key) {
                if (null != options[key]) return key + "=" + stringify(options[key]);
            })).filter(Boolean).join(",");
            var win;
            try {
                win = window.open(url, name, params);
            } catch (err) {
                throw new dom_PopupOpenError("Can not open popup window - " + (err.stack || err.message));
            }
            if (Object(cross_domain_utils_src.isWindowClosed)(win)) {
                var err;
                throw new dom_PopupOpenError("Can not open popup window - blocked");
            }
            closeOnUnload && window.addEventListener("unload", (function() {
                return win.close();
            }));
            return win;
        }
        function writeToWindow(win, html) {
            try {
                win.document.open();
                win.document.write(html);
                win.document.close();
            } catch (err) {
                try {
                    win.location = "javascript: document.open(); document.write(" + JSON.stringify(html) + "); document.close();";
                } catch (err2) {}
            }
        }
        function writeElementToWindow(win, el) {
            var tag = el.tagName.toLowerCase();
            if ("html" !== tag) throw new Error("Expected element to be html, got " + tag);
            var documentElement = win.document.documentElement;
            for (var _i6 = 0, _arrayFrom2 = arrayFrom(documentElement.children); _i6 < _arrayFrom2.length; _i6++) documentElement.removeChild(_arrayFrom2[_i6]);
            for (var _i8 = 0, _arrayFrom4 = arrayFrom(el.children); _i8 < _arrayFrom4.length; _i8++) documentElement.appendChild(_arrayFrom4[_i8]);
        }
        function setStyle(el, styleText, doc) {
            void 0 === doc && (doc = window.document);
            el.styleSheet ? el.styleSheet.cssText = styleText : el.appendChild(doc.createTextNode(styleText));
        }
        var awaitFrameLoadPromises;
        function awaitFrameLoad(frame) {
            if ((awaitFrameLoadPromises = awaitFrameLoadPromises || new weakmap_CrossDomainSafeWeakMap).has(frame)) {
                var _promise = awaitFrameLoadPromises.get(frame);
                if (_promise) return _promise;
            }
            var promise = new zalgo_promise_src.ZalgoPromise((function(resolve, reject) {
                frame.addEventListener("load", (function() {
                    Object(cross_domain_utils_src.linkFrameWindow)(frame);
                    resolve(frame);
                }));
                frame.addEventListener("error", (function(err) {
                    frame.contentWindow ? resolve(frame) : reject(err);
                }));
            }));
            awaitFrameLoadPromises.set(frame, promise);
            return promise;
        }
        function awaitFrameWindow(frame) {
            return awaitFrameLoad(frame).then((function(loadedFrame) {
                if (!loadedFrame.contentWindow) throw new Error("Could not find window in iframe");
                return loadedFrame.contentWindow;
            }));
        }
        function createElement(tag, options, container) {
            void 0 === tag && (tag = "div");
            void 0 === options && (options = {});
            tag = tag.toLowerCase();
            var element = document.createElement(tag);
            options.style && extend(element.style, options.style);
            options.class && (element.className = options.class.join(" "));
            options.id && element.setAttribute("id", options.id);
            if (options.attributes) for (var _i10 = 0, _Object$keys2 = Object.keys(options.attributes); _i10 < _Object$keys2.length; _i10++) {
                var key = _Object$keys2[_i10];
                element.setAttribute(key, options.attributes[key]);
            }
            options.styleSheet && setStyle(element, options.styleSheet);
            container && appendChild(container, element);
            if (options.html) if ("iframe" === tag) {
                if (!container || !element.contentWindow) throw new Error("Iframe html can not be written unless container provided and iframe in DOM");
                writeToWindow(element.contentWindow, options.html);
            } else element.innerHTML = options.html;
            return element;
        }
        function iframe(options, container) {
            void 0 === options && (options = {});
            var attributes = options.attributes || {};
            var style = options.style || {};
            var frame = createElement("iframe", {
                attributes: Object(esm_extends.default)({
                    allowTransparency: "true"
                }, attributes),
                style: Object(esm_extends.default)({
                    backgroundColor: "transparent",
                    border: "none"
                }, style),
                html: options.html,
                class: options.class
            });
            var isIE = window.navigator.userAgent.match(/MSIE|Edge/i);
            frame.hasAttribute("id") || frame.setAttribute("id", uniqueID());
            awaitFrameLoad(frame);
            container && getElement(container).appendChild(frame);
            (options.url || isIE) && frame.setAttribute("src", options.url || "about:blank");
            return frame;
        }
        function addEventListener(obj, event, handler) {
            obj.addEventListener(event, handler);
            return {
                cancel: function() {
                    obj.removeEventListener(event, handler);
                }
            };
        }
        function bindEvents(element, eventNames, handler) {
            handler = once(handler);
            for (var _i12 = 0; _i12 < eventNames.length; _i12++) element.addEventListener(eventNames[_i12], handler);
            return {
                cancel: once((function() {
                    for (var _i14 = 0; _i14 < eventNames.length; _i14++) element.removeEventListener(eventNames[_i14], handler);
                }))
            };
        }
        var VENDOR_PREFIXES = [ "webkit", "moz", "ms", "o" ];
        function setVendorCSS(element, name, value) {
            element.style[name] = value;
            var capitalizedName = capitalizeFirstLetter(name);
            for (var _i16 = 0; _i16 < VENDOR_PREFIXES.length; _i16++) element.style["" + VENDOR_PREFIXES[_i16] + capitalizedName] = value;
        }
        var ANIMATION_START_EVENTS = [ "animationstart", "webkitAnimationStart", "oAnimationStart", "MSAnimationStart" ];
        var ANIMATION_END_EVENTS = [ "animationend", "webkitAnimationEnd", "oAnimationEnd", "MSAnimationEnd" ];
        function animate(element, name, clean, timeout) {
            void 0 === timeout && (timeout = 1e3);
            return new zalgo_promise_src.ZalgoPromise((function(resolve, reject) {
                var el = getElement(element);
                if (!el) return resolve();
                var hasStarted = !1;
                var startTimeout;
                var endTimeout;
                var startEvent;
                var endEvent;
                function cleanUp() {
                    clearTimeout(startTimeout);
                    clearTimeout(endTimeout);
                    startEvent.cancel();
                    endEvent.cancel();
                }
                startEvent = bindEvents(el, ANIMATION_START_EVENTS, (function(event) {
                    if (event.target === el && event.animationName === name) {
                        clearTimeout(startTimeout);
                        event.stopPropagation();
                        startEvent.cancel();
                        hasStarted = !0;
                        endTimeout = setTimeout((function() {
                            cleanUp();
                            resolve();
                        }), timeout);
                    }
                }));
                endEvent = bindEvents(el, ANIMATION_END_EVENTS, (function(event) {
                    if (event.target === el && event.animationName === name) {
                        cleanUp();
                        return "string" == typeof event.animationName && event.animationName !== name ? reject("Expected animation name to be " + name + ", found " + event.animationName) : resolve();
                    }
                }));
                setVendorCSS(el, "animationName", name);
                startTimeout = setTimeout((function() {
                    if (!hasStarted) {
                        cleanUp();
                        return resolve();
                    }
                }), 200);
                clean && clean(cleanUp);
            }));
        }
        function makeElementVisible(element) {
            element.style.setProperty("visibility", "");
        }
        function makeElementInvisible(element) {
            element.style.setProperty("visibility", "hidden", "important");
        }
        function showElement(element) {
            element.style.setProperty("display", "");
        }
        function hideElement(element) {
            element.style.setProperty("display", "none", "important");
        }
        function destroyElement(element) {
            element && element.parentNode && element.parentNode.removeChild(element);
        }
        function showAndAnimate(element, name, clean) {
            var animation = animate(element, name, clean);
            showElement(element);
            return animation;
        }
        function animateAndHide(element, name, clean) {
            return animate(element, name, clean).then((function() {
                hideElement(element);
            }));
        }
        function addClass(element, name) {
            element.classList.add(name);
        }
        function removeClass(element, name) {
            element.classList.remove(name);
        }
        function isElementClosed(el) {
            return !(el && el.parentNode && el.ownerDocument && el.ownerDocument.documentElement && el.ownerDocument.documentElement.contains(el));
        }
        function watchElementForClose(element, handler) {
            handler = once(handler);
            var cancelled = !1;
            var mutationObservers = [];
            var interval;
            var sacrificialFrame;
            var sacrificialFrameWin;
            var cancel = function() {
                cancelled = !0;
                for (var _i18 = 0; _i18 < mutationObservers.length; _i18++) mutationObservers[_i18].disconnect();
                interval && interval.cancel();
                sacrificialFrameWin && sacrificialFrameWin.removeEventListener("unload", elementClosed);
                sacrificialFrame && destroyElement(sacrificialFrame);
            };
            var elementClosed = function() {
                if (!cancelled) {
                    handler();
                    cancel();
                }
            };
            if (isElementClosed(element)) {
                elementClosed();
                return {
                    cancel: cancel
                };
            }
            if (window.MutationObserver) {
                var mutationElement = element.parentElement;
                for (;mutationElement; ) {
                    var mutationObserver = new window.MutationObserver((function() {
                        isElementClosed(element) && elementClosed();
                    }));
                    mutationObserver.observe(mutationElement, {
                        childList: !0
                    });
                    mutationObservers.push(mutationObserver);
                    mutationElement = mutationElement.parentElement;
                }
            }
            (sacrificialFrame = document.createElement("iframe")).setAttribute("name", "__detect_close_" + uniqueID() + "__");
            sacrificialFrame.style.display = "none";
            awaitFrameWindow(sacrificialFrame).then((function(frameWin) {
                (sacrificialFrameWin = Object(cross_domain_utils_src.assertSameDomain)(frameWin)).addEventListener("unload", elementClosed);
            }));
            element.appendChild(sacrificialFrame);
            interval = safeInterval((function() {
                isElementClosed(element) && elementClosed();
            }), 1e3);
            return {
                cancel: cancel
            };
        }
        function fixScripts(el, doc) {
            void 0 === doc && (doc = window.document);
            for (var _i20 = 0, _querySelectorAll2 = querySelectorAll("script", el); _i20 < _querySelectorAll2.length; _i20++) {
                var script = _querySelectorAll2[_i20];
                var parentNode = script.parentNode;
                if (parentNode) {
                    var newScript = doc.createElement("script");
                    newScript.text = script.textContent;
                    parentNode.replaceChild(newScript, script);
                }
            }
        }
        function onResize(el, handler, _temp) {
            var _ref2 = void 0 === _temp ? {} : _temp, _ref2$width = _ref2.width, width = void 0 === _ref2$width || _ref2$width, _ref2$height = _ref2.height, height = void 0 === _ref2$height || _ref2$height, _ref2$interval = _ref2.interval, interval = void 0 === _ref2$interval ? 100 : _ref2$interval, _ref2$win = _ref2.win, win = void 0 === _ref2$win ? window : _ref2$win;
            var currentWidth = el.offsetWidth;
            var currentHeight = el.offsetHeight;
            var canceled = !1;
            handler({
                width: currentWidth,
                height: currentHeight
            });
            var check = function() {
                if (!canceled && isElementVisible(el)) {
                    var newWidth = el.offsetWidth;
                    var newHeight = el.offsetHeight;
                    (width && newWidth !== currentWidth || height && newHeight !== currentHeight) && handler({
                        width: newWidth,
                        height: newHeight
                    });
                    currentWidth = newWidth;
                    currentHeight = newHeight;
                }
            };
            var observer;
            var timeout;
            win.addEventListener("resize", check);
            if (void 0 !== win.ResizeObserver) {
                (observer = new win.ResizeObserver(check)).observe(el);
                timeout = safeInterval(check, 10 * interval);
            } else if (void 0 !== win.MutationObserver) {
                (observer = new win.MutationObserver(check)).observe(el, {
                    attributes: !0,
                    childList: !0,
                    subtree: !0,
                    characterData: !1
                });
                timeout = safeInterval(check, 10 * interval);
            } else timeout = safeInterval(check, interval);
            return {
                cancel: function() {
                    canceled = !0;
                    observer.disconnect();
                    window.removeEventListener("resize", check);
                    timeout.cancel();
                }
            };
        }
        function getResourceLoadTime(url) {
            var performance = getPerformance();
            if (performance && "function" == typeof performance.getEntries) {
                var entries = performance.getEntries();
                for (var i = 0; i < entries.length; i++) {
                    var entry = entries[i];
                    if (entry && entry.name && 0 === entry.name.indexOf(url) && "number" == typeof entry.duration) return Math.floor(entry.duration);
                }
            }
        }
        function isShadowElement(element) {
            for (;element.parentNode; ) element = element.parentNode;
            return "[object ShadowRoot]" === element.toString();
        }
        function getShadowRoot(element) {
            for (;element.parentNode; ) element = element.parentNode;
            if (isShadowElement(element)) return element;
        }
        function getShadowHost(element) {
            var shadowRoot = getShadowRoot(element);
            if (shadowRoot && shadowRoot.host) return shadowRoot.host;
        }
        function insertShadowSlot(element) {
            var shadowHost = getShadowHost(element);
            if (!shadowHost) throw new Error("Element is not in shadow dom");
            var slotName = "shadow-slot-" + uniqueID();
            var slot = document.createElement("slot");
            slot.setAttribute("name", slotName);
            element.appendChild(slot);
            var slotProvider = document.createElement("div");
            slotProvider.setAttribute("slot", slotName);
            shadowHost.appendChild(slotProvider);
            return isShadowElement(shadowHost) ? insertShadowSlot(slotProvider) : slotProvider;
        }
        function preventClickFocus(el) {
            var onFocus = function onFocus(event) {
                el.removeEventListener("focus", onFocus);
                event.preventDefault();
                el.blur();
                return !1;
            };
            el.addEventListener("mousedown", (function() {
                el.addEventListener("focus", onFocus);
                setTimeout((function() {
                    el.removeEventListener("focus", onFocus);
                }), 1);
            }));
        }
        function getStackTrace() {
            try {
                throw new Error("_");
            } catch (err) {
                return err.stack || "";
            }
        }
        var currentScript = "undefined" != typeof document ? document.currentScript : null;
        var getCurrentScript = memoize((function() {
            if (currentScript) return currentScript;
            if (currentScript = function() {
                try {
                    var stack = getStackTrace();
                    var stackDetails = /.*at [^(]*\((.*):(.+):(.+)\)$/gi.exec(stack);
                    var scriptLocation = stackDetails && stackDetails[1];
                    if (!scriptLocation) return;
                    for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName("script")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {
                        var script = _Array$prototype$slic2[_i22];
                        if (script.src && script.src === scriptLocation) return script;
                    }
                } catch (err) {}
            }()) return currentScript;
            throw new Error("Can not determine current script");
        }));
        var currentUID = uniqueID();
        var getCurrentScriptUID = memoize((function() {
            var script;
            try {
                script = getCurrentScript();
            } catch (err) {
                return currentUID;
            }
            var uid = script.getAttribute(ATTRIBUTES.UID);
            if (uid && "string" == typeof uid) return uid;
            if ((uid = script.getAttribute(ATTRIBUTES.UID + "-auto")) && "string" == typeof uid) return uid;
            if (script.src) {
                var hashedString = strHashStr(JSON.stringify({
                    src: script.src,
                    dataset: script.dataset
                }));
                uid = "uid_" + hashedString.slice(hashedString.length - UID_HASH_LENGTH);
            } else uid = uniqueID();
            script.setAttribute(ATTRIBUTES.UID + "-auto", uid);
            return uid;
        }));
        function submitForm(_ref3) {
            var url = _ref3.url, target = _ref3.target, body = _ref3.body, _ref3$method = _ref3.method, method = void 0 === _ref3$method ? "post" : _ref3$method;
            var form = document.createElement("form");
            form.setAttribute("target", target);
            form.setAttribute("method", method);
            form.setAttribute("action", url);
            form.style.display = "none";
            if (body) for (var _i24 = 0, _Object$keys4 = Object.keys(body); _i24 < _Object$keys4.length; _i24++) {
                var _body$key;
                var key = _Object$keys4[_i24];
                var input = document.createElement("input");
                input.setAttribute("name", key);
                input.setAttribute("value", null == (_body$key = body[key]) ? void 0 : _body$key.toString());
                form.appendChild(input);
            }
            getBody().appendChild(form);
            form.submit();
            getBody().removeChild(form);
        }
        function getStorage(_ref) {
            var name = _ref.name, _ref$lifetime = _ref.lifetime, lifetime = void 0 === _ref$lifetime ? 12e5 : _ref$lifetime;
            return inlineMemoize(getStorage, (function() {
                var STORAGE_KEY = "__" + name + "_storage__";
                var newStateID = uniqueID();
                var accessedStorage;
                function getState(handler) {
                    var localStorageEnabled = isLocalStorageEnabled();
                    var storage;
                    accessedStorage && (storage = accessedStorage);
                    if (!storage && localStorageEnabled) {
                        var rawStorage = window.localStorage.getItem(STORAGE_KEY);
                        rawStorage && (storage = JSON.parse(rawStorage));
                    }
                    storage || (storage = getGlobal()[STORAGE_KEY]);
                    storage || (storage = {
                        id: newStateID
                    });
                    storage.id || (storage.id = newStateID);
                    accessedStorage = storage;
                    var result = handler(storage);
                    localStorageEnabled ? window.localStorage.setItem(STORAGE_KEY, JSON.stringify(storage)) : getGlobal()[STORAGE_KEY] = storage;
                    accessedStorage = null;
                    return result;
                }
                function getID() {
                    return getState((function(storage) {
                        return storage.id;
                    }));
                }
                function getSession(handler) {
                    return getState((function(storage) {
                        var session = storage.__session__;
                        var now = Date.now();
                        session && now - session.created > lifetime && (session = null);
                        session || (session = {
                            guid: uniqueID(),
                            created: now
                        });
                        storage.__session__ = session;
                        return handler(session);
                    }));
                }
                return {
                    getState: getState,
                    getID: getID,
                    isStateFresh: function() {
                        return getID() === newStateID;
                    },
                    getSessionState: function(handler) {
                        return getSession((function(session) {
                            session.state = session.state || {};
                            return handler(session.state);
                        }));
                    },
                    getSessionID: function() {
                        return getSession((function(session) {
                            return session.guid;
                        }));
                    }
                };
            }), [ {
                name: name,
                lifetime: lifetime
            } ]);
        }
        function getBelterExperimentStorage() {
            return getStorage({
                name: "belter_experiment"
            });
        }
        function isEventUnique(name) {
            return getBelterExperimentStorage().getSessionState((function(state) {
                state.loggedBeacons = state.loggedBeacons || [];
                if (-1 === state.loggedBeacons.indexOf(name)) {
                    state.loggedBeacons.push(name);
                    return !0;
                }
                return !1;
            }));
        }
        function getRandomInteger(range) {
            return Math.floor(Math.random() * range);
        }
        function experiment(_ref) {
            var name = _ref.name, _ref$sample = _ref.sample, sample = void 0 === _ref$sample ? 50 : _ref$sample, _ref$logTreatment = _ref.logTreatment, logTreatment = void 0 === _ref$logTreatment ? util_noop : _ref$logTreatment, _ref$logCheckpoint = _ref.logCheckpoint, logCheckpoint = void 0 === _ref$logCheckpoint ? util_noop : _ref$logCheckpoint, _ref$sticky = _ref.sticky;
            var throttle = void 0 === _ref$sticky || _ref$sticky ? function(name) {
                return getBelterExperimentStorage().getState((function(state) {
                    state.throttlePercentiles = state.throttlePercentiles || {};
                    state.throttlePercentiles[name] = state.throttlePercentiles[name] || getRandomInteger(100);
                    return state.throttlePercentiles[name];
                }));
            }(name) : getRandomInteger(100);
            var group;
            var treatment = name + "_" + (group = throttle < sample ? "test" : sample >= 50 || sample <= throttle && throttle < 2 * sample ? "control" : "throttle");
            var started = !1;
            var forced = !1;
            try {
                window.localStorage && window.localStorage.getItem(name) && (forced = !0);
            } catch (err) {}
            var exp = {
                isEnabled: function() {
                    return "test" === group || forced;
                },
                isDisabled: function() {
                    return "test" !== group && !forced;
                },
                getTreatment: function() {
                    return treatment;
                },
                log: function(checkpoint, payload) {
                    void 0 === payload && (payload = {});
                    if (!started) return exp;
                    isEventUnique(treatment + "_" + JSON.stringify(payload)) && logTreatment({
                        name: name,
                        treatment: treatment,
                        payload: payload,
                        throttle: throttle
                    });
                    isEventUnique(treatment + "_" + checkpoint + "_" + JSON.stringify(payload)) && logCheckpoint({
                        name: name,
                        treatment: treatment,
                        checkpoint: checkpoint,
                        payload: payload,
                        throttle: throttle
                    });
                    return exp;
                },
                logStart: function(payload) {
                    void 0 === payload && (payload = {});
                    started = !0;
                    return exp.log("start", payload);
                },
                logComplete: function(payload) {
                    void 0 === payload && (payload = {});
                    return exp.log("complete", payload);
                }
            };
            return exp;
        }
        function getGlobalNameSpace(_ref) {
            var name = _ref.name, _ref$version = _ref.version, version = void 0 === _ref$version ? "latest" : _ref$version;
            var global = getGlobal();
            var globalKey = "__" + name + "__" + version + "_global__";
            var namespace = global[globalKey] = global[globalKey] || {};
            return {
                get: function(key, defValue) {
                    defValue = defValue || {};
                    return namespace[key] = namespace[key] || defValue;
                }
            };
        }
        var headerBuilders = [];
        function request(_ref) {
            var url = _ref.url, _ref$method = _ref.method, method = void 0 === _ref$method ? "get" : _ref$method, _ref$headers = _ref.headers, headers = void 0 === _ref$headers ? {} : _ref$headers, json = _ref.json, data = _ref.data, body = _ref.body, _ref$win = _ref.win, win = void 0 === _ref$win ? window : _ref$win, _ref$timeout = _ref.timeout, timeout = void 0 === _ref$timeout ? 0 : _ref$timeout;
            return new zalgo_promise_src.ZalgoPromise((function(resolve, reject) {
                if (json && data || json && body || data && json) throw new Error("Only options.json or options.data or options.body should be passed");
                var normalizedHeaders = {};
                for (var _i4 = 0, _Object$keys2 = Object.keys(headers); _i4 < _Object$keys2.length; _i4++) {
                    var _key2 = _Object$keys2[_i4];
                    normalizedHeaders[_key2.toLowerCase()] = headers[_key2];
                }
                json ? normalizedHeaders["content-type"] = normalizedHeaders["content-type"] || "application/json" : (data || body) && (normalizedHeaders["content-type"] = normalizedHeaders["content-type"] || "application/x-www-form-urlencoded; charset=utf-8");
                normalizedHeaders.accept = normalizedHeaders.accept || "application/json";
                for (var _i6 = 0; _i6 < headerBuilders.length; _i6++) {
                    var builtHeaders = (0, headerBuilders[_i6])();
                    for (var _i8 = 0, _Object$keys4 = Object.keys(builtHeaders); _i8 < _Object$keys4.length; _i8++) {
                        var _key3 = _Object$keys4[_i8];
                        normalizedHeaders[_key3.toLowerCase()] = builtHeaders[_key3];
                    }
                }
                var xhr = new win.XMLHttpRequest;
                xhr.addEventListener("load", (function() {
                    var responseHeaders = function(rawHeaders) {
                        void 0 === rawHeaders && (rawHeaders = "");
                        var result = {};
                        for (var _i2 = 0, _rawHeaders$trim$spli2 = rawHeaders.trim().split("\n"); _i2 < _rawHeaders$trim$spli2.length; _i2++) {
                            var _line$split = _rawHeaders$trim$spli2[_i2].split(":"), _key = _line$split[0], values = _line$split.slice(1);
                            result[_key.toLowerCase()] = values.join(":").trim();
                        }
                        return result;
                    }(this.getAllResponseHeaders());
                    if (!this.status) return reject(new Error("Request to " + method.toLowerCase() + " " + url + " failed: no response status code."));
                    var contentType = responseHeaders["content-type"];
                    var isJSON = contentType && (0 === contentType.indexOf("application/json") || 0 === contentType.indexOf("text/json"));
                    var responseBody = this.responseText;
                    try {
                        responseBody = JSON.parse(responseBody);
                    } catch (err) {
                        if (isJSON) return reject(new Error("Invalid json: " + this.responseText + "."));
                    }
                    return resolve({
                        status: this.status,
                        headers: responseHeaders,
                        body: responseBody
                    });
                }), !1);
                xhr.addEventListener("error", (function(evt) {
                    reject(new Error("Request to " + method.toLowerCase() + " " + url + " failed: " + evt.toString() + "."));
                }), !1);
                xhr.open(method, url, !0);
                for (var _key4 in normalizedHeaders) normalizedHeaders.hasOwnProperty(_key4) && xhr.setRequestHeader(_key4, normalizedHeaders[_key4]);
                json ? body = JSON.stringify(json) : data && (body = Object.keys(data).map((function(key) {
                    return encodeURIComponent(key) + "=" + (data ? encodeURIComponent(data[key]) : "");
                })).join("&"));
                xhr.timeout = timeout;
                xhr.ontimeout = function() {
                    reject(new Error("Request to " + method.toLowerCase() + " " + url + " has timed out"));
                };
                xhr.send(body);
            }));
        }
        function addHeaderBuilder(method) {
            headerBuilders.push(method);
        }
        var TYPES = !0;
        function memoized(target, name, descriptor) {
            descriptor.value = memoize(descriptor.value, {
                name: name,
                thisNamespace: !0
            });
        }
        function decorators_promise(target, name, descriptor) {
            descriptor.value = promisify(descriptor.value, {
                name: name
            });
        }
        function isPerc(str) {
            return "string" == typeof str && /^[0-9]+%$/.test(str);
        }
        function isPx(str) {
            return "string" == typeof str && /^[0-9]+px$/.test(str);
        }
        function toNum(val) {
            if ("number" == typeof val) return val;
            var match = val.match(/^([0-9]+)(px|%)$/);
            if (!match) throw new Error("Could not match css value from " + val);
            return parseInt(match[1], 10);
        }
        function toPx(val) {
            return toNum(val) + "px";
        }
        function toCSS(val) {
            return "number" == typeof val ? toPx(val) : isPerc(val) ? val : toPx(val);
        }
        function percOf(num, perc) {
            return parseInt(num * toNum(perc) / 100, 10);
        }
        function normalizeDimension(dim, max) {
            if ("number" == typeof dim) return dim;
            if (isPerc(dim)) return percOf(max, dim);
            if (isPx(dim)) return toNum(dim);
            throw new Error("Can not normalize dimension: " + dim);
        }
        function wrapPromise(method, _temp) {
            var _ref$timeout = (void 0 === _temp ? {} : _temp).timeout, timeout = void 0 === _ref$timeout ? 5e3 : _ref$timeout;
            var expected = [];
            var promises = [];
            return new zalgo_promise_src.ZalgoPromise((function(resolve, reject) {
                var timer = setTimeout((function() {
                    expected.length && reject(new Error("Expected " + expected[0].name + " to be called in " + timeout + "ms"));
                    promises.length && reject(new Error("Expected " + promises[0].name + " promise to complete in " + timeout + "ms"));
                }), timeout);
                var expect = function(name, handler) {
                    void 0 === handler && (handler = util_noop);
                    var exp = {
                        name: name,
                        handler: handler
                    };
                    expected.push(exp);
                    return function() {
                        var _this = this;
                        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                        removeFromArray(expected, exp);
                        var _tryCatch = tryCatch((function() {
                            var _handler;
                            return (_handler = handler).call.apply(_handler, [ _this ].concat(args));
                        })), result = _tryCatch.result, error = _tryCatch.error;
                        if (error) {
                            promises.push({
                                name: name,
                                promise: zalgo_promise_src.ZalgoPromise.asyncReject(error)
                            });
                            throw error;
                        }
                        promises.push({
                            name: name,
                            promise: zalgo_promise_src.ZalgoPromise.resolve(result)
                        });
                        return result;
                    };
                };
                var avoid = function(name, fn) {
                    void 0 === fn && (fn = util_noop);
                    return function() {
                        var _fn;
                        promises.push({
                            name: name,
                            promise: zalgo_promise_src.ZalgoPromise.asyncReject(new Error("Expected " + name + " to not be called"))
                        });
                        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                        return (_fn = fn).call.apply(_fn, [ this ].concat(args));
                    };
                };
                var expectError = function(name, handler) {
                    void 0 === handler && (handler = util_noop);
                    var exp = {
                        name: name,
                        handler: handler
                    };
                    expected.push(exp);
                    return function() {
                        var _this2 = this;
                        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
                        removeFromArray(expected, exp);
                        var _tryCatch2 = tryCatch((function() {
                            var _handler2;
                            return (_handler2 = handler).call.apply(_handler2, [ _this2 ].concat(args));
                        })), result = _tryCatch2.result, error = _tryCatch2.error;
                        if (error) throw error;
                        promises.push({
                            name: name,
                            promise: zalgo_promise_src.ZalgoPromise.resolve(result).then((function() {
                                throw new Error("Expected " + name + " to throw an error");
                            }), util_noop)
                        });
                        return result;
                    };
                };
                promises.push({
                    name: "wrapPromise handler",
                    promise: zalgo_promise_src.ZalgoPromise.try((function() {
                        return method({
                            expect: expect,
                            avoid: avoid,
                            expectError: expectError,
                            error: avoid,
                            wait: function() {
                                return zalgo_promise_src.ZalgoPromise.resolve();
                            }
                        });
                    }))
                });
                (function wait() {
                    return zalgo_promise_src.ZalgoPromise.try((function() {
                        if (promises.length) {
                            var prom = promises[0];
                            return prom.promise.finally((function() {
                                removeFromArray(promises, prom);
                            })).then(wait);
                        }
                    })).then((function() {
                        if (expected.length) return zalgo_promise_src.ZalgoPromise.delay(10).then(wait);
                    }));
                })().finally((function() {
                    clearTimeout(timer);
                })).then(resolve, reject);
            }));
        }
    },
    "./node_modules/@krakenjs/cross-domain-utils/src/index.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "getActualProtocol", (function() {
            return getActualProtocol;
        }));
        __webpack_require__.d(__webpack_exports__, "getProtocol", (function() {
            return getProtocol;
        }));
        __webpack_require__.d(__webpack_exports__, "isFileProtocol", (function() {
            return isFileProtocol;
        }));
        __webpack_require__.d(__webpack_exports__, "isAboutProtocol", (function() {
            return isAboutProtocol;
        }));
        __webpack_require__.d(__webpack_exports__, "isMockProtocol", (function() {
            return isMockProtocol;
        }));
        __webpack_require__.d(__webpack_exports__, "getParent", (function() {
            return getParent;
        }));
        __webpack_require__.d(__webpack_exports__, "getOpener", (function() {
            return getOpener;
        }));
        __webpack_require__.d(__webpack_exports__, "canReadFromWindow", (function() {
            return canReadFromWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "getActualDomain", (function() {
            return getActualDomain;
        }));
        __webpack_require__.d(__webpack_exports__, "getDomain", (function() {
            return getDomain;
        }));
        __webpack_require__.d(__webpack_exports__, "isBlankDomain", (function() {
            return isBlankDomain;
        }));
        __webpack_require__.d(__webpack_exports__, "isActuallySameDomain", (function() {
            return isActuallySameDomain;
        }));
        __webpack_require__.d(__webpack_exports__, "isSameDomain", (function() {
            return isSameDomain;
        }));
        __webpack_require__.d(__webpack_exports__, "assertSameDomain", (function() {
            return assertSameDomain;
        }));
        __webpack_require__.d(__webpack_exports__, "getParents", (function() {
            return getParents;
        }));
        __webpack_require__.d(__webpack_exports__, "isAncestorParent", (function() {
            return isAncestorParent;
        }));
        __webpack_require__.d(__webpack_exports__, "getFrames", (function() {
            return getFrames;
        }));
        __webpack_require__.d(__webpack_exports__, "getAllChildFrames", (function() {
            return getAllChildFrames;
        }));
        __webpack_require__.d(__webpack_exports__, "getTop", (function() {
            return getTop;
        }));
        __webpack_require__.d(__webpack_exports__, "getNextOpener", (function() {
            return getNextOpener;
        }));
        __webpack_require__.d(__webpack_exports__, "getUltimateTop", (function() {
            return getUltimateTop;
        }));
        __webpack_require__.d(__webpack_exports__, "getAllFramesInWindow", (function() {
            return getAllFramesInWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "getAllWindows", (function() {
            return getAllWindows;
        }));
        __webpack_require__.d(__webpack_exports__, "isTop", (function() {
            return isTop;
        }));
        __webpack_require__.d(__webpack_exports__, "isFrameWindowClosed", (function() {
            return isFrameWindowClosed;
        }));
        __webpack_require__.d(__webpack_exports__, "isWindowClosed", (function() {
            return isWindowClosed;
        }));
        __webpack_require__.d(__webpack_exports__, "linkFrameWindow", (function() {
            return linkFrameWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "getUserAgent", (function() {
            return getUserAgent;
        }));
        __webpack_require__.d(__webpack_exports__, "getFrameByName", (function() {
            return getFrameByName;
        }));
        __webpack_require__.d(__webpack_exports__, "findChildFrameByName", (function() {
            return findChildFrameByName;
        }));
        __webpack_require__.d(__webpack_exports__, "findFrameByName", (function() {
            return findFrameByName;
        }));
        __webpack_require__.d(__webpack_exports__, "isParent", (function() {
            return isParent;
        }));
        __webpack_require__.d(__webpack_exports__, "isOpener", (function() {
            return isOpener;
        }));
        __webpack_require__.d(__webpack_exports__, "getAncestor", (function() {
            return getAncestor;
        }));
        __webpack_require__.d(__webpack_exports__, "getAncestors", (function() {
            return getAncestors;
        }));
        __webpack_require__.d(__webpack_exports__, "isAncestor", (function() {
            return isAncestor;
        }));
        __webpack_require__.d(__webpack_exports__, "isPopup", (function() {
            return isPopup;
        }));
        __webpack_require__.d(__webpack_exports__, "isIframe", (function() {
            return isIframe;
        }));
        __webpack_require__.d(__webpack_exports__, "isFullpage", (function() {
            return isFullpage;
        }));
        __webpack_require__.d(__webpack_exports__, "getDistanceFromTop", (function() {
            return getDistanceFromTop;
        }));
        __webpack_require__.d(__webpack_exports__, "getNthParent", (function() {
            return getNthParent;
        }));
        __webpack_require__.d(__webpack_exports__, "getNthParentFromTop", (function() {
            return getNthParentFromTop;
        }));
        __webpack_require__.d(__webpack_exports__, "isSameTopWindow", (function() {
            return isSameTopWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "matchDomain", (function() {
            return matchDomain;
        }));
        __webpack_require__.d(__webpack_exports__, "stringifyDomainPattern", (function() {
            return stringifyDomainPattern;
        }));
        __webpack_require__.d(__webpack_exports__, "getDomainFromUrl", (function() {
            return getDomainFromUrl;
        }));
        __webpack_require__.d(__webpack_exports__, "onCloseWindow", (function() {
            return onCloseWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "isWindow", (function() {
            return isWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "isBrowser", (function() {
            return isBrowser;
        }));
        __webpack_require__.d(__webpack_exports__, "isCurrentDomain", (function() {
            return isCurrentDomain;
        }));
        __webpack_require__.d(__webpack_exports__, "isMockDomain", (function() {
            return isMockDomain;
        }));
        __webpack_require__.d(__webpack_exports__, "normalizeMockUrl", (function() {
            return normalizeMockUrl;
        }));
        __webpack_require__.d(__webpack_exports__, "getFrameForWindow", (function() {
            return getFrameForWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "closeWindow", (function() {
            return closeWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "TYPES", (function() {
            return TYPES;
        }));
        __webpack_require__.d(__webpack_exports__, "PROTOCOL", (function() {
            return PROTOCOL;
        }));
        __webpack_require__.d(__webpack_exports__, "WILDCARD", (function() {
            return WILDCARD;
        }));
        __webpack_require__.d(__webpack_exports__, "WINDOW_TYPE", (function() {
            return WINDOW_TYPE;
        }));
        function isRegex(item) {
            return "[object RegExp]" === {}.toString.call(item);
        }
        var PROTOCOL = {
            MOCK: "mock:",
            FILE: "file:",
            ABOUT: "about:"
        };
        var WILDCARD = "*";
        var WINDOW_TYPE = {
            IFRAME: "iframe",
            POPUP: "popup"
        };
        var IE_WIN_ACCESS_ERROR = "Call was rejected by callee.\r\n";
        function getActualProtocol(win) {
            void 0 === win && (win = window);
            return win.location.protocol;
        }
        function getProtocol(win) {
            void 0 === win && (win = window);
            if (win.mockDomain) {
                var protocol = win.mockDomain.split("//")[0];
                if (protocol) return protocol;
            }
            return getActualProtocol(win);
        }
        function isFileProtocol(win) {
            void 0 === win && (win = window);
            return getProtocol(win) === PROTOCOL.FILE;
        }
        function isAboutProtocol(win) {
            void 0 === win && (win = window);
            return getProtocol(win) === PROTOCOL.ABOUT;
        }
        function isMockProtocol(win) {
            void 0 === win && (win = window);
            return getProtocol(win) === PROTOCOL.MOCK;
        }
        function getParent(win) {
            void 0 === win && (win = window);
            if (win) try {
                if (win.parent && win.parent !== win) return win.parent;
            } catch (err) {}
        }
        function getOpener(win) {
            void 0 === win && (win = window);
            if (win && !getParent(win)) try {
                return win.opener;
            } catch (err) {}
        }
        function canReadFromWindow(win) {
            try {
                return !0;
            } catch (err) {}
            return !1;
        }
        function getActualDomain(win) {
            void 0 === win && (win = window);
            var location = win.location;
            if (!location) throw new Error("Can not read window location");
            var protocol = getActualProtocol(win);
            if (!protocol) throw new Error("Can not read window protocol");
            if (protocol === PROTOCOL.FILE) return PROTOCOL.FILE + "//";
            if (protocol === PROTOCOL.ABOUT) {
                var parent = getParent(win);
                return parent && canReadFromWindow() ? getActualDomain(parent) : PROTOCOL.ABOUT + "//";
            }
            var host = location.host;
            if (!host) throw new Error("Can not read window host");
            return protocol + "//" + host;
        }
        function getDomain(win) {
            void 0 === win && (win = window);
            var domain = getActualDomain(win);
            return domain && win.mockDomain && 0 === win.mockDomain.indexOf(PROTOCOL.MOCK) ? win.mockDomain : domain;
        }
        function isBlankDomain(win) {
            try {
                if (!win.location.href) return !0;
                if ("about:blank" === win.location.href) return !0;
            } catch (err) {}
            return !1;
        }
        function isActuallySameDomain(win) {
            try {
                if (win === window) return !0;
            } catch (err) {}
            try {
                var desc = Object.getOwnPropertyDescriptor(win, "location");
                if (desc && !1 === desc.enumerable) return !1;
            } catch (err) {}
            try {
                if (isAboutProtocol(win) && canReadFromWindow()) return !0;
            } catch (err) {}
            try {
                if (isMockProtocol(win) && canReadFromWindow()) return !0;
            } catch (err) {}
            try {
                if (getActualDomain(win) === getActualDomain(window)) return !0;
            } catch (err) {}
            return !1;
        }
        function isSameDomain(win) {
            if (!isActuallySameDomain(win)) return !1;
            try {
                if (win === window) return !0;
                if (isAboutProtocol(win) && canReadFromWindow()) return !0;
                if (getDomain(window) === getDomain(win)) return !0;
            } catch (err) {}
            return !1;
        }
        function assertSameDomain(win) {
            if (!isSameDomain(win)) throw new Error("Expected window to be same domain");
            return win;
        }
        function getParents(win) {
            var result = [];
            try {
                for (;win.parent !== win; ) {
                    result.push(win.parent);
                    win = win.parent;
                }
            } catch (err) {}
            return result;
        }
        function isAncestorParent(parent, child) {
            if (!parent || !child) return !1;
            var childParent = getParent(child);
            return childParent ? childParent === parent : -1 !== getParents(child).indexOf(parent);
        }
        function getFrames(win) {
            var result = [];
            var frames;
            try {
                frames = win.frames;
            } catch (err) {
                frames = win;
            }
            var len;
            try {
                len = frames.length;
            } catch (err) {}
            if (0 === len) return result;
            if (len) {
                for (var i = 0; i < len; i++) {
                    var frame = void 0;
                    try {
                        frame = frames[i];
                    } catch (err) {
                        continue;
                    }
                    result.push(frame);
                }
                return result;
            }
            for (var _i = 0; _i < 100; _i++) {
                var _frame = void 0;
                try {
                    _frame = frames[_i];
                } catch (err) {
                    return result;
                }
                if (!_frame) return result;
                result.push(_frame);
            }
            return result;
        }
        function getAllChildFrames(win) {
            var result = [];
            for (var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++) {
                var frame = _getFrames2[_i3];
                result.push(frame);
                for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++) result.push(_getAllChildFrames2[_i5]);
            }
            return result;
        }
        function getTop(win) {
            void 0 === win && (win = window);
            try {
                if (win.top) return win.top;
            } catch (err) {}
            if (getParent(win) === win) return win;
            try {
                if (isAncestorParent(window, win) && window.top) return window.top;
            } catch (err) {}
            try {
                if (isAncestorParent(win, window) && window.top) return window.top;
            } catch (err) {}
            for (var _i7 = 0, _getAllChildFrames4 = getAllChildFrames(win); _i7 < _getAllChildFrames4.length; _i7++) {
                var frame = _getAllChildFrames4[_i7];
                try {
                    if (frame.top) return frame.top;
                } catch (err) {}
                if (getParent(frame) === frame) return frame;
            }
        }
        function getNextOpener(win) {
            void 0 === win && (win = window);
            return getOpener(getTop(win) || win);
        }
        function getUltimateTop(win) {
            void 0 === win && (win = window);
            var opener = getNextOpener(win);
            return opener ? getUltimateTop(opener) : top;
        }
        function getAllFramesInWindow(win) {
            var top = getTop(win);
            if (!top) throw new Error("Can not determine top window");
            var result = [].concat(getAllChildFrames(top), [ top ]);
            -1 === result.indexOf(win) && (result = [].concat(result, [ win ], getAllChildFrames(win)));
            return result;
        }
        function getAllWindows(win) {
            void 0 === win && (win = window);
            var frames = getAllFramesInWindow(win);
            var opener = getNextOpener(win);
            return opener ? [].concat(getAllWindows(opener), frames) : frames;
        }
        function isTop(win) {
            return win === getTop(win);
        }
        function isFrameWindowClosed(frame) {
            if (!frame.contentWindow) return !0;
            if (!frame.parentNode) return !0;
            var doc = frame.ownerDocument;
            if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {
                var parent = frame;
                for (;parent.parentNode && parent.parentNode !== parent; ) parent = parent.parentNode;
                if (!parent.host || !doc.documentElement.contains(parent.host)) return !0;
            }
            return !1;
        }
        var iframeWindows = [];
        var iframeFrames = [];
        function isWindowClosed(win, allowMock) {
            void 0 === allowMock && (allowMock = !0);
            try {
                if (win === window) return !1;
            } catch (err) {
                return !0;
            }
            try {
                if (!win) return !0;
            } catch (err) {
                return !0;
            }
            try {
                if (win.closed) return !0;
            } catch (err) {
                return !err || err.message !== IE_WIN_ACCESS_ERROR;
            }
            if (allowMock && isSameDomain(win)) try {
                if (win.mockclosed) return !0;
            } catch (err) {}
            try {
                if (!win.parent || !win.top) return !0;
            } catch (err) {}
            var iframeIndex = function(collection, item) {
                for (var i = 0; i < collection.length; i++) try {
                    if (collection[i] === item) return i;
                } catch (err) {}
                return -1;
            }(iframeWindows, win);
            if (-1 !== iframeIndex) {
                var frame = iframeFrames[iframeIndex];
                if (frame && isFrameWindowClosed(frame)) return !0;
            }
            return !1;
        }
        function linkFrameWindow(frame) {
            !function() {
                for (var i = 0; i < iframeWindows.length; i++) {
                    var closed = !1;
                    try {
                        closed = iframeWindows[i].closed;
                    } catch (err) {}
                    if (closed) {
                        iframeFrames.splice(i, 1);
                        iframeWindows.splice(i, 1);
                    }
                }
            }();
            if (frame && frame.contentWindow) try {
                iframeWindows.push(frame.contentWindow);
                iframeFrames.push(frame);
            } catch (err) {}
        }
        function getUserAgent(win) {
            return (win = win || window).navigator.mockUserAgent || win.navigator.userAgent;
        }
        function getFrameByName(win, name) {
            var winFrames = getFrames(win);
            for (var _i9 = 0; _i9 < winFrames.length; _i9++) {
                var childFrame = winFrames[_i9];
                try {
                    if (isSameDomain(childFrame) && childFrame.name === name && -1 !== winFrames.indexOf(childFrame)) return childFrame;
                } catch (err) {}
            }
            try {
                if (-1 !== winFrames.indexOf(win.frames[name])) return win.frames[name];
            } catch (err) {}
            try {
                if (-1 !== winFrames.indexOf(win[name])) return win[name];
            } catch (err) {}
        }
        function findChildFrameByName(win, name) {
            var frame = getFrameByName(win, name);
            if (frame) return frame;
            for (var _i11 = 0, _getFrames4 = getFrames(win); _i11 < _getFrames4.length; _i11++) {
                var namedFrame = findChildFrameByName(_getFrames4[_i11], name);
                if (namedFrame) return namedFrame;
            }
        }
        function findFrameByName(win, name) {
            return getFrameByName(win, name) || findChildFrameByName(getTop(win) || win, name);
        }
        function isParent(win, frame) {
            var frameParent = getParent(frame);
            if (frameParent) return frameParent === win;
            for (var _i13 = 0, _getFrames6 = getFrames(win); _i13 < _getFrames6.length; _i13++) if (_getFrames6[_i13] === frame) return !0;
            return !1;
        }
        function isOpener(parent, child) {
            return parent === getOpener(child);
        }
        function getAncestor(win) {
            void 0 === win && (win = window);
            return getOpener(win = win || window) || getParent(win) || void 0;
        }
        function getAncestors(win) {
            var results = [];
            var ancestor = win;
            for (;ancestor; ) (ancestor = getAncestor(ancestor)) && results.push(ancestor);
            return results;
        }
        function isAncestor(parent, child) {
            var actualParent = getAncestor(child);
            if (actualParent) return actualParent === parent;
            if (child === parent) return !1;
            if (getTop(child) === child) return !1;
            for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) if (_getFrames8[_i15] === child) return !0;
            return !1;
        }
        function isPopup(win) {
            void 0 === win && (win = window);
            return Boolean(getOpener(win));
        }
        function isIframe(win) {
            void 0 === win && (win = window);
            return Boolean(getParent(win));
        }
        function isFullpage(win) {
            void 0 === win && (win = window);
            return Boolean(!isIframe(win) && !isPopup(win));
        }
        function anyMatch(collection1, collection2) {
            for (var _i17 = 0; _i17 < collection1.length; _i17++) {
                var item1 = collection1[_i17];
                for (var _i19 = 0; _i19 < collection2.length; _i19++) if (item1 === collection2[_i19]) return !0;
            }
            return !1;
        }
        function getDistanceFromTop(win) {
            void 0 === win && (win = window);
            var distance = 0;
            var parent = win;
            for (;parent; ) (parent = getParent(parent)) && (distance += 1);
            return distance;
        }
        function getNthParent(win, n) {
            void 0 === n && (n = 1);
            var parent = win;
            for (var i = 0; i < n; i++) {
                if (!parent) return;
                parent = getParent(parent);
            }
            return parent;
        }
        function getNthParentFromTop(win, n) {
            void 0 === n && (n = 1);
            return getNthParent(win, getDistanceFromTop(win) - n);
        }
        function isSameTopWindow(win1, win2) {
            var top1 = getTop(win1) || win1;
            var top2 = getTop(win2) || win2;
            try {
                if (top1 && top2) return top1 === top2;
            } catch (err) {}
            var allFrames1 = getAllFramesInWindow(win1);
            var allFrames2 = getAllFramesInWindow(win2);
            if (anyMatch(allFrames1, allFrames2)) return !0;
            var opener1 = getOpener(top1);
            var opener2 = getOpener(top2);
            return opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2) || opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1), 
            !1;
        }
        function matchDomain(pattern, origin) {
            if ("string" == typeof pattern) {
                if ("string" == typeof origin) return pattern === WILDCARD || origin === pattern;
                if (isRegex(origin)) return !1;
                if (Array.isArray(origin)) return !1;
            }
            return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some((function(subpattern) {
                return matchDomain(subpattern, origin);
            })));
        }
        function stringifyDomainPattern(pattern) {
            return Array.isArray(pattern) ? "(" + pattern.join(" | ") + ")" : isRegex(pattern) ? "RegExp(" + pattern.toString() + ")" : pattern.toString();
        }
        function getDomainFromUrl(url) {
            return url.match(/^(https?|mock|file):\/\//) ? url.split("/").slice(0, 3).join("/") : getDomain();
        }
        function onCloseWindow(win, callback, delay, maxtime) {
            void 0 === delay && (delay = 1e3);
            void 0 === maxtime && (maxtime = 1 / 0);
            var timeout;
            !function check() {
                if (isWindowClosed(win)) {
                    timeout && clearTimeout(timeout);
                    return callback();
                }
                if (maxtime <= 0) clearTimeout(timeout); else {
                    maxtime -= delay;
                    timeout = setTimeout(check, delay);
                }
            }();
            return {
                cancel: function() {
                    timeout && clearTimeout(timeout);
                }
            };
        }
        function isWindow(obj) {
            try {
                if (obj === window) return !0;
            } catch (err) {
                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
            }
            try {
                if ("[object Window]" === {}.toString.call(obj)) return !0;
            } catch (err) {
                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
            }
            try {
                if (window.Window && obj instanceof window.Window) return !0;
            } catch (err) {
                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
            }
            try {
                if (obj && obj.self === obj) return !0;
            } catch (err) {
                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
            }
            try {
                if (obj && obj.parent === obj) return !0;
            } catch (err) {
                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
            }
            try {
                if (obj && obj.top === obj) return !0;
            } catch (err) {
                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
            }
            try {
                if (obj && "__unlikely_value__" === obj.__cross_domain_utils_window_check__) return !1;
            } catch (err) {
                return !0;
            }
            try {
                if ("postMessage" in obj && "self" in obj && "location" in obj) return !0;
            } catch (err) {}
            return !1;
        }
        function isBrowser() {
            return "undefined" != typeof window && void 0 !== window.location;
        }
        function isCurrentDomain(domain) {
            return !!isBrowser() && getDomain() === domain;
        }
        function isMockDomain(domain) {
            return 0 === domain.indexOf(PROTOCOL.MOCK);
        }
        function normalizeMockUrl(url) {
            if (!isMockDomain(getDomainFromUrl(url))) return url;
            throw new Error("Mock urls not supported out of test mode");
        }
        function getFrameForWindow(win) {
            if (isSameDomain(win)) return assertSameDomain(win).frameElement;
            for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll("iframe"); _i21 < _document$querySelect2.length; _i21++) {
                var frame = _document$querySelect2[_i21];
                if (frame && frame.contentWindow && frame.contentWindow === win) return frame;
            }
        }
        function closeWindow(win) {
            if (isIframe(win)) {
                var frame = getFrameForWindow(win);
                if (frame && frame.parentElement) {
                    frame.parentElement.removeChild(frame);
                    return;
                }
            }
            try {
                win.close();
            } catch (err) {}
        }
        var TYPES = !0;
    },
    "./node_modules/@krakenjs/zalgo-promise/src/index.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "ZalgoPromise", (function() {
            return promise_ZalgoPromise;
        }));
        function utils_isPromise(item) {
            try {
                if (!item) return !1;
                if ("undefined" != typeof Promise && item instanceof Promise) return !0;
                if ("undefined" != typeof window && "function" == typeof window.Window && item instanceof window.Window) return !1;
                if ("undefined" != typeof window && "function" == typeof window.constructor && item instanceof window.constructor) return !1;
                var _toString = {}.toString;
                if (_toString) {
                    var name = _toString.call(item);
                    if ("[object Window]" === name || "[object global]" === name || "[object DOMWindow]" === name) return !1;
                }
                if ("function" == typeof item.then) return !0;
            } catch (err) {
                return !1;
            }
            return !1;
        }
        var dispatchedErrors = [];
        var possiblyUnhandledPromiseHandlers = [];
        var activeCount = 0;
        var flushPromise;
        function flushActive() {
            if (!activeCount && flushPromise) {
                var promise = flushPromise;
                flushPromise = null;
                promise.resolve();
            }
        }
        function startActive() {
            activeCount += 1;
        }
        function endActive() {
            activeCount -= 1;
            flushActive();
        }
        var promise_ZalgoPromise = function() {
            function ZalgoPromise(handler) {
                var _this = this;
                this.resolved = void 0;
                this.rejected = void 0;
                this.errorHandled = void 0;
                this.value = void 0;
                this.error = void 0;
                this.handlers = void 0;
                this.dispatching = void 0;
                this.stack = void 0;
                this.resolved = !1;
                this.rejected = !1;
                this.errorHandled = !1;
                this.handlers = [];
                if (handler) {
                    var _result;
                    var _error;
                    var resolved = !1;
                    var rejected = !1;
                    var isAsync = !1;
                    startActive();
                    try {
                        handler((function(res) {
                            if (isAsync) _this.resolve(res); else {
                                resolved = !0;
                                _result = res;
                            }
                        }), (function(err) {
                            if (isAsync) _this.reject(err); else {
                                rejected = !0;
                                _error = err;
                            }
                        }));
                    } catch (err) {
                        endActive();
                        this.reject(err);
                        return;
                    }
                    endActive();
                    isAsync = !0;
                    resolved ? this.resolve(_result) : rejected && this.reject(_error);
                }
                try {
                    throw new Error("ZalgoPromise");
                } catch (err) {
                    this.stack = err.stack;
                }
            }
            var _proto = ZalgoPromise.prototype;
            _proto.resolve = function(result) {
                if (this.resolved || this.rejected) return this;
                if (utils_isPromise(result)) throw new Error("Can not resolve promise with another promise");
                this.resolved = !0;
                this.value = result;
                this.dispatch();
                return this;
            };
            _proto.reject = function(error) {
                var _this2 = this;
                if (this.resolved || this.rejected) return this;
                if (utils_isPromise(error)) throw new Error("Can not reject promise with another promise");
                if (!error) {
                    var _err = error && "function" == typeof error.toString ? error.toString() : {}.toString.call(error);
                    error = new Error("Expected reject to be called with Error, got " + _err);
                }
                this.rejected = !0;
                this.error = error;
                this.errorHandled || setTimeout((function() {
                    _this2.errorHandled || function(err, promise) {
                        if (-1 === dispatchedErrors.indexOf(err)) {
                            dispatchedErrors.push(err);
                            setTimeout((function() {
                                throw new Error((err.stack || err.toString()) + "\n\nFrom promise:\n\n" + promise.stack);
                            }), 1);
                            for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);
                        }
                    }(error, _this2);
                }), 1);
                this.dispatch();
                return this;
            };
            _proto.asyncReject = function(error) {
                this.errorHandled = !0;
                this.reject(error);
                return this;
            };
            _proto.dispatch = function() {
                var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;
                if (!this.dispatching && (resolved || rejected)) {
                    this.dispatching = !0;
                    startActive();
                    var chain = function(firstPromise, secondPromise) {
                        return firstPromise.then((function(res) {
                            secondPromise.resolve(res);
                        }), (function(err) {
                            secondPromise.reject(err);
                        }));
                    };
                    for (var i = 0; i < handlers.length; i++) {
                        var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;
                        var _result2 = void 0;
                        if (resolved) try {
                            _result2 = onSuccess ? onSuccess(this.value) : this.value;
                        } catch (err) {
                            promise.reject(err);
                            continue;
                        } else if (rejected) {
                            if (!onError) {
                                promise.reject(this.error);
                                continue;
                            }
                            try {
                                _result2 = onError(this.error);
                            } catch (err) {
                                promise.reject(err);
                                continue;
                            }
                        }
                        if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {
                            var promiseResult = _result2;
                            promiseResult.resolved ? promise.resolve(promiseResult.value) : promise.reject(promiseResult.error);
                            promiseResult.errorHandled = !0;
                        } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);
                    }
                    handlers.length = 0;
                    this.dispatching = !1;
                    endActive();
                }
            };
            _proto.then = function(onSuccess, onError) {
                if (onSuccess && "function" != typeof onSuccess && !onSuccess.call) throw new Error("Promise.then expected a function for success handler");
                if (onError && "function" != typeof onError && !onError.call) throw new Error("Promise.then expected a function for error handler");
                var promise = new ZalgoPromise;
                this.handlers.push({
                    promise: promise,
                    onSuccess: onSuccess,
                    onError: onError
                });
                this.errorHandled = !0;
                this.dispatch();
                return promise;
            };
            _proto.catch = function(onError) {
                return this.then(void 0, onError);
            };
            _proto.finally = function(onFinally) {
                if (onFinally && "function" != typeof onFinally && !onFinally.call) throw new Error("Promise.finally expected a function");
                return this.then((function(result) {
                    return ZalgoPromise.try(onFinally).then((function() {
                        return result;
                    }));
                }), (function(err) {
                    return ZalgoPromise.try(onFinally).then((function() {
                        throw err;
                    }));
                }));
            };
            _proto.timeout = function(time, err) {
                var _this3 = this;
                if (this.resolved || this.rejected) return this;
                var timeout = setTimeout((function() {
                    _this3.resolved || _this3.rejected || _this3.reject(err || new Error("Promise timed out after " + time + "ms"));
                }), time);
                return this.then((function(result) {
                    clearTimeout(timeout);
                    return result;
                }));
            };
            _proto.toPromise = function() {
                if ("undefined" == typeof Promise) throw new TypeError("Could not find Promise");
                return Promise.resolve(this);
            };
            _proto.lazy = function() {
                this.errorHandled = !0;
                return this;
            };
            ZalgoPromise.resolve = function(value) {
                return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise((function(resolve, reject) {
                    return value.then(resolve, reject);
                })) : (new ZalgoPromise).resolve(value);
            };
            ZalgoPromise.reject = function(error) {
                return (new ZalgoPromise).reject(error);
            };
            ZalgoPromise.asyncReject = function(error) {
                return (new ZalgoPromise).asyncReject(error);
            };
            ZalgoPromise.all = function(promises) {
                var promise = new ZalgoPromise;
                var count = promises.length;
                var results = [].slice();
                if (!count) {
                    promise.resolve(results);
                    return promise;
                }
                var chain = function(i, firstPromise, secondPromise) {
                    return firstPromise.then((function(res) {
                        results[i] = res;
                        0 == (count -= 1) && promise.resolve(results);
                    }), (function(err) {
                        secondPromise.reject(err);
                    }));
                };
                for (var i = 0; i < promises.length; i++) {
                    var prom = promises[i];
                    if (prom instanceof ZalgoPromise) {
                        if (prom.resolved) {
                            results[i] = prom.value;
                            count -= 1;
                            continue;
                        }
                    } else if (!utils_isPromise(prom)) {
                        results[i] = prom;
                        count -= 1;
                        continue;
                    }
                    chain(i, ZalgoPromise.resolve(prom), promise);
                }
                0 === count && promise.resolve(results);
                return promise;
            };
            ZalgoPromise.hash = function(promises) {
                var result = {};
                var awaitPromises = [];
                var _loop = function(key) {
                    if (promises.hasOwnProperty(key)) {
                        var value = promises[key];
                        utils_isPromise(value) ? awaitPromises.push(value.then((function(res) {
                            result[key] = res;
                        }))) : result[key] = value;
                    }
                };
                for (var key in promises) _loop(key);
                return ZalgoPromise.all(awaitPromises).then((function() {
                    return result;
                }));
            };
            ZalgoPromise.map = function(items, method) {
                return ZalgoPromise.all(items.map(method));
            };
            ZalgoPromise.onPossiblyUnhandledException = function(handler) {
                return function(handler) {
                    possiblyUnhandledPromiseHandlers.push(handler);
                    return {
                        cancel: function() {
                            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);
                        }
                    };
                }(handler);
            };
            ZalgoPromise.try = function(method, context, args) {
                if (method && "function" != typeof method && !method.call) throw new Error("Promise.try expected a function");
                var result;
                startActive();
                try {
                    result = method.apply(context, args || []);
                } catch (err) {
                    endActive();
                    return ZalgoPromise.reject(err);
                }
                endActive();
                return ZalgoPromise.resolve(result);
            };
            ZalgoPromise.delay = function(_delay) {
                return new ZalgoPromise((function(resolve) {
                    setTimeout(resolve, _delay);
                }));
            };
            ZalgoPromise.isPromise = function(value) {
                return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);
            };
            ZalgoPromise.flush = function() {
                return function(Zalgo) {
                    var promise = flushPromise = flushPromise || new Zalgo;
                    flushActive();
                    return promise;
                }(ZalgoPromise);
            };
            return ZalgoPromise;
        }();
    },
    "./node_modules/@paypal/sdk-constants/src/index.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "DEFAULT_COUNTRY", (function() {
            return DEFAULT_COUNTRY;
        }));
        __webpack_require__.d(__webpack_exports__, "DEFAULT_CURRENCY", (function() {
            return DEFAULT_CURRENCY;
        }));
        __webpack_require__.d(__webpack_exports__, "DEFAULT_INTENT", (function() {
            return DEFAULT_INTENT;
        }));
        __webpack_require__.d(__webpack_exports__, "DEFAULT_COMMIT", (function() {
            return DEFAULT_COMMIT;
        }));
        __webpack_require__.d(__webpack_exports__, "DEFAULT_SALE_COMMIT", (function() {
            return DEFAULT_SALE_COMMIT;
        }));
        __webpack_require__.d(__webpack_exports__, "DEFAULT_NONSALE_COMMIT", (function() {
            return DEFAULT_NONSALE_COMMIT;
        }));
        __webpack_require__.d(__webpack_exports__, "DEFAULT_VAULT", (function() {
            return DEFAULT_VAULT;
        }));
        __webpack_require__.d(__webpack_exports__, "DEFAULT_COMPONENTS", (function() {
            return DEFAULT_COMPONENTS;
        }));
        __webpack_require__.d(__webpack_exports__, "DEFAULT_DEBUG", (function() {
            return DEFAULT_DEBUG;
        }));
        __webpack_require__.d(__webpack_exports__, "ENV", (function() {
            return ENV;
        }));
        __webpack_require__.d(__webpack_exports__, "MOBILE_ENV", (function() {
            return MOBILE_ENV;
        }));
        __webpack_require__.d(__webpack_exports__, "ERROR_CODE", (function() {
            return ERROR_CODE;
        }));
        __webpack_require__.d(__webpack_exports__, "FPTI_KEY", (function() {
            return FPTI_KEY;
        }));
        __webpack_require__.d(__webpack_exports__, "FPTI_USER_ACTION", (function() {
            return FPTI_USER_ACTION;
        }));
        __webpack_require__.d(__webpack_exports__, "FPTI_DATA_SOURCE", (function() {
            return FPTI_DATA_SOURCE;
        }));
        __webpack_require__.d(__webpack_exports__, "FPTI_FEED", (function() {
            return FPTI_FEED;
        }));
        __webpack_require__.d(__webpack_exports__, "FPTI_SDK_NAME", (function() {
            return FPTI_SDK_NAME;
        }));
        __webpack_require__.d(__webpack_exports__, "FUNDING", (function() {
            return FUNDING;
        }));
        __webpack_require__.d(__webpack_exports__, "FUNDING_BRAND_LABEL", (function() {
            return FUNDING_BRAND_LABEL;
        }));
        __webpack_require__.d(__webpack_exports__, "CARD", (function() {
            return CARD;
        }));
        __webpack_require__.d(__webpack_exports__, "WALLET_INSTRUMENT", (function() {
            return WALLET_INSTRUMENT;
        }));
        __webpack_require__.d(__webpack_exports__, "FUNDING_PRODUCTS", (function() {
            return FUNDING_PRODUCTS;
        }));
        __webpack_require__.d(__webpack_exports__, "COUNTRY", (function() {
            return COUNTRY;
        }));
        __webpack_require__.d(__webpack_exports__, "LANG", (function() {
            return LANG;
        }));
        __webpack_require__.d(__webpack_exports__, "COUNTRY_LANGS", (function() {
            return COUNTRY_LANGS;
        }));
        __webpack_require__.d(__webpack_exports__, "INTENT", (function() {
            return INTENT;
        }));
        __webpack_require__.d(__webpack_exports__, "COMMIT", (function() {
            return COMMIT;
        }));
        __webpack_require__.d(__webpack_exports__, "VAULT", (function() {
            return VAULT;
        }));
        __webpack_require__.d(__webpack_exports__, "CURRENCY", (function() {
            return CURRENCY;
        }));
        __webpack_require__.d(__webpack_exports__, "SDK_PATH", (function() {
            return SDK_PATH;
        }));
        __webpack_require__.d(__webpack_exports__, "SDK_SETTINGS", (function() {
            return SDK_SETTINGS;
        }));
        __webpack_require__.d(__webpack_exports__, "SDK_QUERY_KEYS", (function() {
            return SDK_QUERY_KEYS;
        }));
        __webpack_require__.d(__webpack_exports__, "COMPONENTS", (function() {
            return COMPONENTS;
        }));
        __webpack_require__.d(__webpack_exports__, "DEBUG", (function() {
            return DEBUG;
        }));
        __webpack_require__.d(__webpack_exports__, "QUERY_BOOL", (function() {
            return QUERY_BOOL;
        }));
        __webpack_require__.d(__webpack_exports__, "UNKNOWN", (function() {
            return UNKNOWN;
        }));
        __webpack_require__.d(__webpack_exports__, "PROTOCOL", (function() {
            return PROTOCOL;
        }));
        __webpack_require__.d(__webpack_exports__, "PAGE_TYPES", (function() {
            return PAGE_TYPES;
        }));
        __webpack_require__.d(__webpack_exports__, "MERCHANT_ID_MAX", (function() {
            return MERCHANT_ID_MAX;
        }));
        __webpack_require__.d(__webpack_exports__, "DISPLAY_ONLY_VALUES", (function() {
            return DISPLAY_ONLY_VALUES;
        }));
        __webpack_require__.d(__webpack_exports__, "PLATFORM", (function() {
            return PLATFORM;
        }));
        __webpack_require__.d(__webpack_exports__, "TYPES", (function() {
            return TYPES;
        }));
        __webpack_require__.d(__webpack_exports__, "APM_LIST", (function() {
            return APM_LIST;
        }));
        var COUNTRY = {
            AD: "AD",
            AE: "AE",
            AG: "AG",
            AI: "AI",
            AL: "AL",
            AM: "AM",
            AN: "AN",
            AO: "AO",
            AR: "AR",
            AT: "AT",
            AU: "AU",
            AW: "AW",
            AZ: "AZ",
            BA: "BA",
            BB: "BB",
            BE: "BE",
            BF: "BF",
            BG: "BG",
            BH: "BH",
            BI: "BI",
            BJ: "BJ",
            BM: "BM",
            BN: "BN",
            BO: "BO",
            BR: "BR",
            BS: "BS",
            BT: "BT",
            BW: "BW",
            BY: "BY",
            BZ: "BZ",
            CA: "CA",
            CD: "CD",
            CG: "CG",
            CH: "CH",
            CI: "CI",
            CK: "CK",
            CL: "CL",
            CM: "CM",
            CN: "CN",
            CO: "CO",
            CR: "CR",
            CV: "CV",
            CY: "CY",
            CZ: "CZ",
            DE: "DE",
            DJ: "DJ",
            DK: "DK",
            DM: "DM",
            DO: "DO",
            DZ: "DZ",
            EC: "EC",
            EE: "EE",
            EG: "EG",
            ER: "ER",
            ES: "ES",
            ET: "ET",
            FI: "FI",
            FJ: "FJ",
            FK: "FK",
            FM: "FM",
            FO: "FO",
            FR: "FR",
            GA: "GA",
            GB: "GB",
            GD: "GD",
            GE: "GE",
            GF: "GF",
            GI: "GI",
            GL: "GL",
            GM: "GM",
            GN: "GN",
            GP: "GP",
            GR: "GR",
            GT: "GT",
            GW: "GW",
            GY: "GY",
            HK: "HK",
            HN: "HN",
            HR: "HR",
            HU: "HU",
            ID: "ID",
            IE: "IE",
            IL: "IL",
            IN: "IN",
            IS: "IS",
            IT: "IT",
            JM: "JM",
            JO: "JO",
            JP: "JP",
            KE: "KE",
            KG: "KG",
            KH: "KH",
            KI: "KI",
            KM: "KM",
            KN: "KN",
            KR: "KR",
            KW: "KW",
            KY: "KY",
            KZ: "KZ",
            LA: "LA",
            LC: "LC",
            LI: "LI",
            LK: "LK",
            LS: "LS",
            LT: "LT",
            LU: "LU",
            LV: "LV",
            MA: "MA",
            MC: "MC",
            MD: "MD",
            ME: "ME",
            MG: "MG",
            MH: "MH",
            MK: "MK",
            ML: "ML",
            MN: "MN",
            MQ: "MQ",
            MR: "MR",
            MS: "MS",
            MT: "MT",
            MU: "MU",
            MV: "MV",
            MW: "MW",
            MX: "MX",
            MY: "MY",
            MZ: "MZ",
            NA: "NA",
            NC: "NC",
            NE: "NE",
            NF: "NF",
            NG: "NG",
            NI: "NI",
            NL: "NL",
            NO: "NO",
            NP: "NP",
            NR: "NR",
            NU: "NU",
            NZ: "NZ",
            OM: "OM",
            PA: "PA",
            PE: "PE",
            PF: "PF",
            PG: "PG",
            PH: "PH",
            PL: "PL",
            PM: "PM",
            PN: "PN",
            PT: "PT",
            PW: "PW",
            PY: "PY",
            QA: "QA",
            RE: "RE",
            RO: "RO",
            RS: "RS",
            RU: "RU",
            RW: "RW",
            SA: "SA",
            SB: "SB",
            SC: "SC",
            SE: "SE",
            SG: "SG",
            SH: "SH",
            SI: "SI",
            SJ: "SJ",
            SK: "SK",
            SL: "SL",
            SM: "SM",
            SN: "SN",
            SO: "SO",
            SR: "SR",
            ST: "ST",
            SV: "SV",
            SZ: "SZ",
            TC: "TC",
            TD: "TD",
            TG: "TG",
            TH: "TH",
            TJ: "TJ",
            TM: "TM",
            TN: "TN",
            TO: "TO",
            TR: "TR",
            TT: "TT",
            TV: "TV",
            TW: "TW",
            TZ: "TZ",
            UA: "UA",
            UG: "UG",
            US: "US",
            UY: "UY",
            VA: "VA",
            VC: "VC",
            VE: "VE",
            VG: "VG",
            VN: "VN",
            VU: "VU",
            WF: "WF",
            WS: "WS",
            YE: "YE",
            YT: "YT",
            ZA: "ZA",
            ZM: "ZM",
            ZW: "ZW"
        };
        var LANG = {
            AR: "ar",
            BG: "bg",
            CS: "cs",
            DA: "da",
            DE: "de",
            EL: "el",
            EN: "en",
            ES: "es",
            ET: "et",
            FI: "fi",
            FR: "fr",
            HE: "he",
            HU: "hu",
            ID: "id",
            IT: "it",
            JA: "ja",
            KO: "ko",
            LT: "lt",
            LV: "lv",
            MS: "ms",
            NL: "nl",
            NO: "no",
            PL: "pl",
            PT: "pt",
            RO: "ro",
            RU: "ru",
            SI: "si",
            SK: "sk",
            SL: "sl",
            SQ: "sq",
            SV: "sv",
            TH: "th",
            TL: "tl",
            TR: "tr",
            VI: "vi",
            ZH: "zh",
            ZH_HANT: "zh_Hant"
        };
        var COUNTRY_LANGS = {
            AD: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            AE: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH, LANG.AR ],
            AG: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            AI: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            AL: [ LANG.SQ, LANG.EN ],
            AM: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            AN: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            AO: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            AR: [ LANG.ES, LANG.EN ],
            AT: [ LANG.DE, LANG.EN ],
            AU: [ LANG.EN ],
            AW: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            AZ: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            BA: [ LANG.EN ],
            BB: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            BE: [ LANG.EN, LANG.NL, LANG.FR ],
            BF: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            BG: [ LANG.BG, LANG.EN ],
            BH: [ LANG.AR, LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            BI: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            BJ: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            BM: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            BN: [ LANG.MS, LANG.EN ],
            BO: [ LANG.ES, LANG.EN, LANG.FR, LANG.ZH ],
            BR: [ LANG.PT, LANG.EN ],
            BS: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            BT: [ LANG.EN ],
            BW: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            BY: [ LANG.EN ],
            BZ: [ LANG.EN, LANG.ES, LANG.FR, LANG.ZH ],
            CA: [ LANG.EN, LANG.FR ],
            CD: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            CG: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            CH: [ LANG.DE, LANG.FR, LANG.EN ],
            CI: [ LANG.FR, LANG.EN ],
            CK: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            CL: [ LANG.ES, LANG.EN, LANG.FR, LANG.ZH ],
            CM: [ LANG.FR, LANG.EN ],
            CN: [ LANG.ZH ],
            CO: [ LANG.ES, LANG.EN, LANG.FR, LANG.ZH ],
            CR: [ LANG.ES, LANG.EN, LANG.FR, LANG.ZH ],
            CV: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            CY: [ LANG.EN ],
            CZ: [ LANG.CS, LANG.EN ],
            DE: [ LANG.DE, LANG.EN ],
            DJ: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            DK: [ LANG.DA, LANG.EN ],
            DM: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            DO: [ LANG.ES, LANG.EN, LANG.FR, LANG.ZH ],
            DZ: [ LANG.AR, LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            EC: [ LANG.ES, LANG.EN, LANG.FR, LANG.ZH ],
            EE: [ LANG.ET, LANG.EN, LANG.RU ],
            EG: [ LANG.AR, LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            ER: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            ES: [ LANG.ES, LANG.EN ],
            ET: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            FI: [ LANG.FI, LANG.EN ],
            FJ: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            FK: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            FM: [ LANG.EN ],
            FO: [ LANG.DA, LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            FR: [ LANG.FR, LANG.EN ],
            GA: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            GB: [ LANG.EN ],
            GD: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            GE: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            GF: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            GI: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            GL: [ LANG.DA, LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            GM: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            GN: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            GP: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            GR: [ LANG.EL, LANG.EN ],
            GT: [ LANG.ES, LANG.EN, LANG.FR, LANG.ZH ],
            GW: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            GY: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            HK: [ LANG.EN, LANG.ZH_HANT, LANG.ZH ],
            HN: [ LANG.ES, LANG.EN, LANG.FR, LANG.ZH ],
            HR: [ LANG.EN ],
            HU: [ LANG.HU, LANG.EN ],
            ID: [ LANG.ID, LANG.EN ],
            IE: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            IL: [ LANG.HE, LANG.EN ],
            IN: [ LANG.EN ],
            IS: [ LANG.EN ],
            IT: [ LANG.IT, LANG.EN ],
            JM: [ LANG.EN, LANG.ES, LANG.FR, LANG.ZH ],
            JO: [ LANG.AR, LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            JP: [ LANG.JA, LANG.EN ],
            KE: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            KG: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            KH: [ LANG.EN ],
            KI: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            KM: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            KN: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            KR: [ LANG.KO, LANG.EN ],
            KW: [ LANG.AR, LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            KY: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            KZ: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            LA: [ LANG.EN ],
            LC: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            LI: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            LK: [ LANG.SI, LANG.EN ],
            LS: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            LT: [ LANG.LT, LANG.EN, LANG.RU, LANG.ZH ],
            LU: [ LANG.EN, LANG.DE, LANG.FR, LANG.ES, LANG.ZH ],
            LV: [ LANG.LV, LANG.EN, LANG.RU ],
            MA: [ LANG.AR, LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            MC: [ LANG.FR, LANG.EN ],
            MD: [ LANG.EN ],
            ME: [ LANG.EN ],
            MG: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            MH: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            MK: [ LANG.EN ],
            ML: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            MN: [ LANG.EN ],
            MQ: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            MR: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            MS: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            MT: [ LANG.EN ],
            MU: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            MV: [ LANG.EN ],
            MW: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            MX: [ LANG.ES, LANG.EN ],
            MY: [ LANG.MS, LANG.EN ],
            MZ: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            NA: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            NC: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            NE: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            NF: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            NG: [ LANG.EN ],
            NI: [ LANG.ES, LANG.EN, LANG.FR, LANG.ZH ],
            NL: [ LANG.NL, LANG.EN ],
            NO: [ LANG.NO, LANG.EN ],
            NP: [ LANG.EN ],
            NR: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            NU: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            NZ: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            OM: [ LANG.AR, LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            PA: [ LANG.ES, LANG.EN, LANG.FR, LANG.ZH ],
            PE: [ LANG.ES, LANG.EN, LANG.FR, LANG.ZH ],
            PF: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            PG: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            PH: [ LANG.TL, LANG.EN ],
            PL: [ LANG.PL, LANG.EN ],
            PM: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            PN: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            PT: [ LANG.PT, LANG.EN ],
            PW: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            PY: [ LANG.ES, LANG.EN ],
            QA: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH, LANG.AR ],
            RE: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            RO: [ LANG.RO, LANG.EN ],
            RS: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            RU: [ LANG.RU, LANG.EN ],
            RW: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            SA: [ LANG.AR, LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            SB: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            SC: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            SE: [ LANG.SV, LANG.EN ],
            SG: [ LANG.EN ],
            SH: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            SI: [ LANG.SL, LANG.EN ],
            SJ: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            SK: [ LANG.SK, LANG.EN ],
            SL: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            SM: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            SN: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            SO: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            SR: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            ST: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            SV: [ LANG.ES, LANG.EN, LANG.FR, LANG.ZH ],
            SZ: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            TC: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            TD: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            TG: [ LANG.FR, LANG.EN, LANG.ES, LANG.ZH ],
            TH: [ LANG.TH, LANG.EN ],
            TJ: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            TM: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            TN: [ LANG.AR, LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            TO: [ LANG.EN ],
            TR: [ LANG.TR, LANG.EN ],
            TT: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            TV: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            TW: [ LANG.ZH_HANT, LANG.ZH, LANG.EN ],
            TZ: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            UA: [ LANG.EN, LANG.RU, LANG.FR, LANG.ES, LANG.ZH ],
            UG: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            US: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            UY: [ LANG.ES, LANG.EN, LANG.FR, LANG.ZH ],
            VA: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            VC: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            VE: [ LANG.ES, LANG.EN, LANG.FR, LANG.ZH ],
            VG: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            VN: [ LANG.VI, LANG.EN ],
            VU: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            WF: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            WS: [ LANG.EN ],
            YE: [ LANG.AR, LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            YT: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            ZA: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            ZM: [ LANG.EN, LANG.FR, LANG.ES, LANG.ZH ],
            ZW: [ LANG.EN ]
        };
        var INTENT = {
            CAPTURE: "capture",
            AUTHORIZE: "authorize",
            ORDER: "order",
            TOKENIZE: "tokenize",
            SUBSCRIPTION: "subscription"
        };
        var COMMIT = {
            TRUE: !0,
            FALSE: !1
        };
        var VAULT = {
            TRUE: !0,
            FALSE: !1
        };
        var CURRENCY = {
            AED: "AED",
            ALL: "ALL",
            ANG: "ANG",
            AOA: "AOA",
            AUD: "AUD",
            AWG: "AWG",
            BAM: "BAM",
            BBD: "BBD",
            BGN: "BGN",
            BIF: "BIF",
            BMD: "BMD",
            BND: "BND",
            BOB: "BOB",
            BRL: "BRL",
            BSD: "BSD",
            BTN: "BTN",
            CAD: "CAD",
            CDF: "CDF",
            CHF: "CHF",
            CLP: "CLP",
            COP: "COP",
            CRC: "CRC",
            CVE: "CVE",
            CZK: "CZK",
            DJF: "DJF",
            DKK: "DKK",
            DOP: "DOP",
            DZD: "DZD",
            EGP: "EGP",
            ETB: "ETB",
            EUR: "EUR",
            FJD: "FJD",
            FKP: "FKP",
            GBP: "GBP",
            GIP: "GIP",
            GMD: "GMD",
            GNF: "GNF",
            GTQ: "GTQ",
            GYD: "GYD",
            HKD: "HKD",
            HNL: "HNL",
            HRK: "HRK",
            HUF: "HUF",
            IDR: "IDR",
            ILS: "ILS",
            INR: "INR",
            ISK: "ISK",
            JMD: "JMD",
            JPY: "JPY",
            KES: "KES",
            KMF: "KMF",
            KRW: "KRW",
            KYD: "KYD",
            LAK: "LAK",
            LKR: "LKR",
            MDL: "MDL",
            MGA: "MGA",
            MKD: "MKD",
            MNT: "MNT",
            MRO: "MRO",
            MUR: "MUR",
            MVR: "MVR",
            MXN: "MXN",
            MYR: "MYR",
            NAD: "NAD",
            NIO: "NIO",
            NOK: "NOK",
            NPR: "NPR",
            NZD: "NZD",
            PEN: "PEN",
            PGK: "PGK",
            PHP: "PHP",
            PLN: "PLN",
            PYG: "PYG",
            QAR: "QAR",
            RON: "RON",
            RSD: "RSD",
            RUB: "RUB",
            SAR: "SAR",
            SBD: "SBD",
            SCR: "SCR",
            SEK: "SEK",
            SGD: "SGD",
            SHP: "SHP",
            SLL: "SLL",
            SOS: "SOS",
            SRD: "SRD",
            SZL: "SZL",
            THB: "THB",
            TJS: "TJS",
            TOP: "TOP",
            TTD: "TTD",
            TWD: "TWD",
            TZS: "TZS",
            USD: "USD",
            UYU: "UYU",
            VND: "VND",
            VUV: "VUV",
            WST: "WST",
            XAF: "XAF",
            XCD: "XCD",
            YER: "YER"
        };
        var SDK_PATH = "/sdk/js";
        var SDK_SETTINGS = {
            NAMESPACE: "data-namespace",
            CLIENT_TOKEN: "data-client-token",
            MERCHANT_ID: "data-merchant-id",
            PARTNER_ATTRIBUTION_ID: "data-partner-attribution-id",
            STAGE_HOST: "data-stage-host",
            API_STAGE_HOST: "data-api-stage-host",
            CSP_NONCE: "data-csp-nonce",
            ENABLE_3DS: "data-enable-3ds",
            SDK_INTEGRATION_SOURCE: "data-sdk-integration-source",
            USER_ID_TOKEN: "data-user-id-token",
            AMOUNT: "data-amount",
            CLIENT_METADATA_ID: "data-client-metadata-id",
            PAGE_TYPE: "data-page-type",
            USER_EXPERIENCE_FLOW: "data-user-experience-flow",
            POPUPS_DISABLED: "data-popups-disabled"
        };
        var SDK_QUERY_KEYS = {
            COMPONENTS: "components",
            ENV: "env",
            DEBUG: "debug",
            CACHEBUST: "cachebust",
            CLIENT_ID: "client-id",
            MERCHANT_ID: "merchant-id",
            LOCALE: "locale",
            CURRENCY: "currency",
            INTENT: "intent",
            COMMIT: "commit",
            VAULT: "vault",
            BUYER_COUNTRY: "buyer-country",
            ENABLE_FUNDING: "enable-funding",
            DISABLE_FUNDING: "disable-funding",
            DISABLE_CARD: "disable-card",
            INTEGRATION_DATE: "integration-date",
            STAGE_HOST: "stage-host",
            STAGE_ALIAS: "stage-alias",
            CDN_REGISTRY: "cdn-registry",
            VERSION: "version"
        };
        var COMPONENTS = {
            BUTTONS: "buttons",
            HOSTED_FIELDS: "hosted-fields",
            CARD_FIELDS: "card-fields"
        };
        var DEBUG = {
            TRUE: !0,
            FALSE: !1
        };
        var QUERY_BOOL = {
            TRUE: "true",
            FALSE: "false"
        };
        var UNKNOWN = "unknown";
        var PROTOCOL = {
            HTTP: "http",
            HTTPS: "https"
        };
        var PAGE_TYPES = {
            HOME: "home",
            PRODUCT: "product",
            CART: "cart",
            CHECKOUT: "checkout",
            PRODUCT_LISTING: "product-listing",
            SEARCH_RESULTS: "search-results",
            PRODUCT_DETAILS: "product-details",
            MINI_CART: "mini-cart"
        };
        var MERCHANT_ID_MAX = 10;
        var DISPLAY_ONLY_VALUES = {
            VAULTABLE: "vaultable"
        };
        var DEFAULT_COUNTRY = COUNTRY.US;
        var DEFAULT_CURRENCY = CURRENCY.USD;
        var DEFAULT_INTENT = INTENT.CAPTURE;
        var DEFAULT_COMMIT = COMMIT.TRUE;
        var DEFAULT_SALE_COMMIT = COMMIT.TRUE;
        var DEFAULT_NONSALE_COMMIT = COMMIT.TRUE;
        var DEFAULT_VAULT = VAULT.FALSE;
        var DEFAULT_COMPONENTS = COMPONENTS.BUTTONS;
        var DEFAULT_DEBUG = DEBUG.FALSE;
        var ENV = {
            LOCAL: "local",
            STAGE: "stage",
            SANDBOX: "sandbox",
            PRODUCTION: "production",
            TEST: "test"
        };
        var MOBILE_ENV = {
            ANDROID: "android",
            IOS: "iOS"
        };
        var ERROR_CODE = {
            VALIDATION_ERROR: "validation_error"
        };
        var FPTI_KEY = {
            FEED: "feed_name",
            STATE: "state_name",
            EVENT_NAME: "event_name",
            TRANSITION: "transition_name",
            PAGE: "page_name",
            BUTTON_TYPE: "button_type",
            SESSION_UID: "page_session_id",
            BUTTON_SESSION_UID: "button_session_id",
            TOKEN: "token",
            CONTEXT_ID: "context_id",
            CONTEXT_TYPE: "context_type",
            REFERER: "referer_url",
            MERCHANT_DOMAIN: "merchant_domain",
            PAY_ID: "pay_id",
            SELLER_ID: "seller_id",
            CLIENT_ID: "client_id",
            DATA_SOURCE: "serverside_data_source",
            BUTTON_SOURCE: "button_source",
            ERROR_CODE: "ext_error_code",
            ERROR_DESC: "ext_error_desc",
            PAGE_LOAD_TIME: "page_load_time",
            EXPERIMENT_EXPERIENCE: "experimentation_experience",
            EXPERIMENT_TREATMENT: "experimentation_treatment",
            EXPERIMENT_NAME: "pxp_exp_id",
            TREATMENT_NAME: "pxp_trtmnt_id",
            TRANSITION_TIME: "transition_time",
            FUNDING_LIST: "eligible_payment_methods",
            FUNDING_COUNT: "eligible_payment_count",
            CHOSEN_FUNDING: "selected_payment_method",
            BUTTON_LAYOUT: "button_layout",
            VERSION: "checkoutjs_version",
            LOCALE: "locale",
            BUYER_COUNTRY: "buyer_cntry",
            INTEGRATION_IDENTIFIER: "integration_identifier",
            PARTNER_ATTRIBUTION_ID: "bn_code",
            PAGE_TYPE: "pp_placement",
            SDK_NAME: "sdk_name",
            SDK_VERSION: "sdk_version",
            SDK_ENVIRONMENT: "sdk_environment",
            MOBILE_APP_VERSION: "mobile_app_version",
            MOBILE_BUNDLE_IDENTIFIER: "mapv",
            USER_AGENT: "user_agent",
            USER_ACTION: "user_action",
            CONTEXT_CORRID: "context_correlation_id",
            SDK_CACHE: "sdk_cache",
            SDK_LOAD_TIME: "sdk_load_time",
            IS_VAULT: "is_vault",
            DISABLE_FUNDING: "disable_funding",
            DISABLE_CARD: "disable_card",
            RESPONSE_DURATION: "response_duration",
            SDK_INTEGRATION_SOURCE: "sdk_integration_source",
            PAYMENT_FLOW: "payment_flow",
            BUTTON_VERSION: "button_version",
            FI_LIST: "fi_list",
            FI_ID: "fi_id",
            PRODUCT: "product",
            CHOSEN_FI_TYPE: "chosen_fi_type",
            SELECTED_FI: "merchant_selected_funding_source",
            POTENTIAL_PAYMENT_METHODS: "potential_payment_methods",
            PAY_NOW: "pay_now",
            STICKINESS_ID: "stickiness_id",
            TIMESTAMP: "t",
            OPTION_SELECTED: "optsel",
            USER_IDENTITY_METHOD: "user_identity_method",
            FIELDS_COMPONENT_SESSION_ID: "fields_component_session_id",
            CPL_COMP_METRICS: "cpl_comp_metrics",
            CPL_CHUNK_METRICS: "cpl_chunk_metrics",
            CPL_QUERY_METRICS: "cpl_query_metrics"
        };
        var FPTI_USER_ACTION = {
            COMMIT: "commit",
            CONTINUE: "continue"
        };
        var FPTI_DATA_SOURCE = {
            PAYMENTS_SDK: "checkout"
        };
        var FPTI_FEED = {
            PAYMENTS_SDK: "payments_sdk"
        };
        var FPTI_SDK_NAME = {
            PAYMENTS_SDK: "payments_sdk"
        };
        var FUNDING = {
            PAYPAL: "paypal",
            VENMO: "venmo",
            APPLEPAY: "applepay",
            ITAU: "itau",
            CREDIT: "credit",
            PAYLATER: "paylater",
            CARD: "card",
            IDEAL: "ideal",
            SEPA: "sepa",
            BANCONTACT: "bancontact",
            GIROPAY: "giropay",
            SOFORT: "sofort",
            EPS: "eps",
            MYBANK: "mybank",
            P24: "p24",
            PAYU: "payu",
            BLIK: "blik",
            TRUSTLY: "trustly",
            OXXO: "oxxo",
            BOLETO: "boleto",
            BOLETOBANCARIO: "boletobancario",
            WECHATPAY: "wechatpay",
            MERCADOPAGO: "mercadopago",
            MULTIBANCO: "multibanco",
            SATISPAY: "satispay",
            PAIDY: "paidy"
        };
        var FUNDING_BRAND_LABEL = {
            PAYPAL: "PayPal",
            CREDIT: "PayPal Credit"
        };
        var CARD = {
            VISA: "visa",
            MASTERCARD: "mastercard",
            AMEX: "amex",
            DISCOVER: "discover",
            HIPER: "hiper",
            ELO: "elo",
            JCB: "jcb",
            CUP: "cup"
        };
        var WALLET_INSTRUMENT = {
            BALANCE: "balance",
            CARD: "card",
            BANK: "bank",
            CREDIT: "credit"
        };
        var FUNDING_PRODUCTS = {
            PAY_IN_3: "payIn3",
            PAY_IN_4: "payIn4",
            PAYLATER: "paylater",
            CREDIT: "credit"
        };
        var PLATFORM = {
            DESKTOP: "desktop",
            MOBILE: "mobile"
        };
        var TYPES = !0;
        var APM_LIST = [ FUNDING.IDEAL, FUNDING.BANCONTACT, FUNDING.GIROPAY, FUNDING.SOFORT, FUNDING.EPS, FUNDING.MYBANK, FUNDING.P24, FUNDING.PAYU, FUNDING.BLIK, FUNDING.TRUSTLY, FUNDING.OXXO, FUNDING.BOLETO, FUNDING.BOLETOBANCARIO, FUNDING.WECHATPAY, FUNDING.MERCADOPAGO, FUNDING.MULTIBANCO, FUNDING.SATISPAY, FUNDING.PAIDY ];
    },
    "./node_modules/card-validator/dist/card-number.js": function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.cardNumber = void 0;
        var luhn10 = __webpack_require__("./node_modules/card-validator/dist/luhn-10.js");
        var getCardTypes = __webpack_require__("./node_modules/card-validator/node_modules/credit-card-type/dist/index.js");
        function verification(card, isPotentiallyValid, isValid) {
            return {
                card: card,
                isPotentiallyValid: isPotentiallyValid,
                isValid: isValid
            };
        }
        exports.cardNumber = function(value, options) {
            void 0 === options && (options = {});
            var isValid, maxLength;
            if ("string" != typeof value && "number" != typeof value) return verification(null, !1, !1);
            var testCardValue = String(value).replace(/-|\s/g, "");
            if (!/^\d*$/.test(testCardValue)) return verification(null, !1, !1);
            var potentialTypes = getCardTypes(testCardValue);
            if (0 === potentialTypes.length) return verification(null, !1, !1);
            if (1 !== potentialTypes.length) return verification(null, !0, !1);
            var cardType = potentialTypes[0];
            if (options.maxLength && testCardValue.length > options.maxLength) return verification(cardType, !1, !1);
            isValid = cardType.type === getCardTypes.types.UNIONPAY && !0 !== options.luhnValidateUnionPay || luhn10(testCardValue);
            maxLength = Math.max.apply(null, cardType.lengths);
            options.maxLength && (maxLength = Math.min(options.maxLength, maxLength));
            for (var i = 0; i < cardType.lengths.length; i++) if (cardType.lengths[i] === testCardValue.length) return verification(cardType, testCardValue.length < maxLength || isValid, isValid);
            return verification(cardType, testCardValue.length < maxLength, !1);
        };
    },
    "./node_modules/card-validator/dist/cardholder-name.js": function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.cardholderName = void 0;
        var CARD_NUMBER_REGEX = /^[\d\s-]*$/;
        function verification(isValid, isPotentiallyValid) {
            return {
                isValid: isValid,
                isPotentiallyValid: isPotentiallyValid
            };
        }
        exports.cardholderName = function(value) {
            return "string" != typeof value ? verification(!1, !1) : 0 === value.length ? verification(!1, !0) : value.length > 255 ? verification(!1, !1) : CARD_NUMBER_REGEX.test(value) ? verification(!1, !0) : verification(!0, !0);
        };
    },
    "./node_modules/card-validator/dist/cvv.js": function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.cvv = void 0;
        function verification(isValid, isPotentiallyValid) {
            return {
                isValid: isValid,
                isPotentiallyValid: isPotentiallyValid
            };
        }
        exports.cvv = function(value, maxLength) {
            void 0 === maxLength && (maxLength = 3);
            maxLength = maxLength instanceof Array ? maxLength : [ maxLength ];
            return "string" != typeof value ? verification(!1, !1) : /^\d*$/.test(value) ? function(array, thing) {
                for (var i = 0; i < array.length; i++) if (thing === array[i]) return !0;
                return !1;
            }(maxLength, value.length) ? verification(!0, !0) : value.length < Math.min.apply(null, maxLength) ? verification(!1, !0) : value.length > function(array) {
                var maximum = 3;
                var i = 0;
                for (;i < array.length; i++) maximum = array[i] > maximum ? array[i] : maximum;
                return maximum;
            }(maxLength) ? verification(!1, !1) : verification(!0, !0) : verification(!1, !1);
        };
    },
    "./node_modules/card-validator/dist/expiration-date.js": function(module, exports, __webpack_require__) {
        "use strict";
        var __assign = this && this.__assign || function() {
            return (__assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) ({}).hasOwnProperty.call(s, p) && (t[p] = s[p]);
                }
                return t;
            }).apply(this, arguments);
        };
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.expirationDate = void 0;
        var parse_date_1 = __webpack_require__("./node_modules/card-validator/dist/lib/parse-date.js");
        var expiration_month_1 = __webpack_require__("./node_modules/card-validator/dist/expiration-month.js");
        var expiration_year_1 = __webpack_require__("./node_modules/card-validator/dist/expiration-year.js");
        function verification(isValid, isPotentiallyValid, month, year) {
            return {
                isValid: isValid,
                isPotentiallyValid: isPotentiallyValid,
                month: month,
                year: year
            };
        }
        exports.expirationDate = function(value, maxElapsedYear) {
            var date;
            if ("string" == typeof value) {
                value = value.replace(/^(\d\d) (\d\d(\d\d)?)$/, "$1/$2");
                date = parse_date_1.parseDate(String(value));
            } else {
                if (null === value || "object" != typeof value) return verification(!1, !1, null, null);
                var fullDate = __assign({}, value);
                date = {
                    month: String(fullDate.month),
                    year: String(fullDate.year)
                };
            }
            var monthValid = expiration_month_1.expirationMonth(date.month);
            var yearValid = expiration_year_1.expirationYear(date.year, maxElapsedYear);
            if (monthValid.isValid) {
                if (yearValid.isCurrentYear) {
                    var isValidForThisYear = monthValid.isValidForThisYear;
                    return verification(isValidForThisYear, isValidForThisYear, date.month, date.year);
                }
                if (yearValid.isValid) return verification(!0, !0, date.month, date.year);
            }
            return verification(!1, !(!monthValid.isPotentiallyValid || !yearValid.isPotentiallyValid), null, null);
        };
    },
    "./node_modules/card-validator/dist/expiration-month.js": function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.expirationMonth = void 0;
        function verification(isValid, isPotentiallyValid, isValidForThisYear) {
            return {
                isValid: isValid,
                isPotentiallyValid: isPotentiallyValid,
                isValidForThisYear: isValidForThisYear || !1
            };
        }
        exports.expirationMonth = function(value) {
            var currentMonth = (new Date).getMonth() + 1;
            if ("string" != typeof value) return verification(!1, !1);
            if ("" === value.replace(/\s/g, "") || "0" === value) return verification(!1, !0);
            if (!/^\d*$/.test(value)) return verification(!1, !1);
            var month = parseInt(value, 10);
            if (isNaN(Number(value))) return verification(!1, !1);
            var result = month > 0 && month < 13;
            return verification(result, result, result && month >= currentMonth);
        };
    },
    "./node_modules/card-validator/dist/expiration-year.js": function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.expirationYear = void 0;
        function verification(isValid, isPotentiallyValid, isCurrentYear) {
            return {
                isValid: isValid,
                isPotentiallyValid: isPotentiallyValid,
                isCurrentYear: isCurrentYear || !1
            };
        }
        exports.expirationYear = function(value, maxElapsedYear) {
            void 0 === maxElapsedYear && (maxElapsedYear = 19);
            var isCurrentYear;
            if ("string" != typeof value) return verification(!1, !1);
            if ("" === value.replace(/\s/g, "")) return verification(!1, !0);
            if (!/^\d*$/.test(value)) return verification(!1, !1);
            var len = value.length;
            if (len < 2) return verification(!1, !0);
            var currentYear = (new Date).getFullYear();
            if (3 === len) return verification(!1, value.slice(0, 2) === String(currentYear).slice(0, 2));
            if (len > 4) return verification(!1, !1);
            var numericValue = parseInt(value, 10);
            var twoDigitYear = Number(String(currentYear).substr(2, 2));
            var valid = !1;
            if (2 === len) {
                if (String(currentYear).substr(0, 2) === value) return verification(!1, !0);
                isCurrentYear = twoDigitYear === numericValue;
                valid = numericValue >= twoDigitYear && numericValue <= twoDigitYear + maxElapsedYear;
            } else if (4 === len) {
                isCurrentYear = currentYear === numericValue;
                valid = numericValue >= currentYear && numericValue <= currentYear + maxElapsedYear;
            }
            return verification(valid, valid, isCurrentYear);
        };
    },
    "./node_modules/card-validator/dist/index.js": function(module, exports, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            void 0 === k2 && (k2 = k);
            Object.defineProperty(o, k2, {
                enumerable: !0,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            void 0 === k2 && (k2 = k);
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: !0,
                value: v
            });
        } : function(o, v) {
            o.default = v;
        });
        var creditCardType = (this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) for (var k in mod) "default" !== k && {}.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
        })(__webpack_require__("./node_modules/card-validator/node_modules/credit-card-type/dist/index.js"));
        var cardholder_name_1 = __webpack_require__("./node_modules/card-validator/dist/cardholder-name.js");
        var card_number_1 = __webpack_require__("./node_modules/card-validator/dist/card-number.js");
        var expiration_date_1 = __webpack_require__("./node_modules/card-validator/dist/expiration-date.js");
        var expiration_month_1 = __webpack_require__("./node_modules/card-validator/dist/expiration-month.js");
        var expiration_year_1 = __webpack_require__("./node_modules/card-validator/dist/expiration-year.js");
        var cvv_1 = __webpack_require__("./node_modules/card-validator/dist/cvv.js");
        var postal_code_1 = __webpack_require__("./node_modules/card-validator/dist/postal-code.js");
        module.exports = {
            creditCardType: creditCardType,
            cardholderName: cardholder_name_1.cardholderName,
            number: card_number_1.cardNumber,
            expirationDate: expiration_date_1.expirationDate,
            expirationMonth: expiration_month_1.expirationMonth,
            expirationYear: expiration_year_1.expirationYear,
            cvv: cvv_1.cvv,
            postalCode: postal_code_1.postalCode
        };
    },
    "./node_modules/card-validator/dist/lib/is-array.js": function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.isArray = void 0;
        exports.isArray = Array.isArray || function(arg) {
            return "[object Array]" === {}.toString.call(arg);
        };
    },
    "./node_modules/card-validator/dist/lib/parse-date.js": function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.parseDate = void 0;
        var expiration_year_1 = __webpack_require__("./node_modules/card-validator/dist/expiration-year.js");
        var is_array_1 = __webpack_require__("./node_modules/card-validator/dist/lib/is-array.js");
        exports.parseDate = function(datestring) {
            var date;
            /^\d{4}-\d{1,2}$/.test(datestring) ? date = datestring.split("-").reverse() : /\//.test(datestring) ? date = datestring.split(/\s*\/\s*/g) : /\s/.test(datestring) && (date = datestring.split(/ +/g));
            if (is_array_1.isArray(date)) return {
                month: date[0] || "",
                year: date.slice(1).join()
            };
            var numberOfDigitsInMonth = function(dateString) {
                var firstCharacter = Number(dateString[0]);
                var assumedYear;
                if (0 === firstCharacter) return 2;
                if (firstCharacter > 1) return 1;
                if (1 === firstCharacter && Number(dateString[1]) > 2) return 1;
                if (1 === firstCharacter) {
                    assumedYear = dateString.substr(1);
                    return expiration_year_1.expirationYear(assumedYear).isPotentiallyValid ? 1 : 2;
                }
                return 5 === dateString.length ? 1 : dateString.length > 5 ? 2 : 1;
            }(datestring);
            var month = datestring.substr(0, numberOfDigitsInMonth);
            return {
                month: month,
                year: datestring.substr(month.length)
            };
        };
    },
    "./node_modules/card-validator/dist/luhn-10.js": function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = function(identifier) {
            var sum = 0;
            var alt = !1;
            var i = identifier.length - 1;
            var num;
            for (;i >= 0; ) {
                num = parseInt(identifier.charAt(i), 10);
                alt && (num *= 2) > 9 && (num = num % 10 + 1);
                alt = !alt;
                sum += num;
                i--;
            }
            return sum % 10 == 0;
        };
    },
    "./node_modules/card-validator/dist/postal-code.js": function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.postalCode = void 0;
        function verification(isValid, isPotentiallyValid) {
            return {
                isValid: isValid,
                isPotentiallyValid: isPotentiallyValid
            };
        }
        exports.postalCode = function(value, options) {
            void 0 === options && (options = {});
            var minLength = options.minLength || 3;
            return "string" != typeof value ? verification(!1, !1) : verification(!(value.length < minLength), !0);
        };
    },
    "./node_modules/card-validator/node_modules/credit-card-type/dist/index.js": function(module, exports, __webpack_require__) {
        "use strict";
        var __assign = this && this.__assign || function() {
            return (__assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) ({}).hasOwnProperty.call(s, p) && (t[p] = s[p]);
                }
                return t;
            }).apply(this, arguments);
        };
        var cardTypes = __webpack_require__("./node_modules/card-validator/node_modules/credit-card-type/dist/lib/card-types.js");
        var add_matching_cards_to_results_1 = __webpack_require__("./node_modules/card-validator/node_modules/credit-card-type/dist/lib/add-matching-cards-to-results.js");
        var is_valid_input_type_1 = __webpack_require__("./node_modules/card-validator/node_modules/credit-card-type/dist/lib/is-valid-input-type.js");
        var find_best_match_1 = __webpack_require__("./node_modules/card-validator/node_modules/credit-card-type/dist/lib/find-best-match.js");
        var clone_1 = __webpack_require__("./node_modules/card-validator/node_modules/credit-card-type/dist/lib/clone.js");
        var customCards = {};
        var cardNames = {
            VISA: "visa",
            MASTERCARD: "mastercard",
            AMERICAN_EXPRESS: "american-express",
            DINERS_CLUB: "diners-club",
            DISCOVER: "discover",
            JCB: "jcb",
            UNIONPAY: "unionpay",
            MAESTRO: "maestro",
            ELO: "elo",
            MIR: "mir",
            HIPER: "hiper",
            HIPERCARD: "hipercard"
        };
        var ORIGINAL_TEST_ORDER = [ cardNames.VISA, cardNames.MASTERCARD, cardNames.AMERICAN_EXPRESS, cardNames.DINERS_CLUB, cardNames.DISCOVER, cardNames.JCB, cardNames.UNIONPAY, cardNames.MAESTRO, cardNames.ELO, cardNames.MIR, cardNames.HIPER, cardNames.HIPERCARD ];
        var testOrder = clone_1.clone(ORIGINAL_TEST_ORDER);
        function findType(cardType) {
            return customCards[cardType] || cardTypes[cardType];
        }
        function getCardPosition(name, ignoreErrorForNotExisting) {
            void 0 === ignoreErrorForNotExisting && (ignoreErrorForNotExisting = !1);
            var position = testOrder.indexOf(name);
            if (!ignoreErrorForNotExisting && -1 === position) throw new Error('"' + name + '" is not a supported card type.');
            return position;
        }
        function creditCardType(cardNumber) {
            var results = [];
            if (!is_valid_input_type_1.isValidInputType(cardNumber)) return results;
            if (0 === cardNumber.length) return testOrder.map((function(cardType) {
                return clone_1.clone(findType(cardType));
            }));
            testOrder.forEach((function(cardType) {
                var cardConfiguration = findType(cardType);
                add_matching_cards_to_results_1.addMatchingCardsToResults(cardNumber, cardConfiguration, results);
            }));
            var bestMatch = find_best_match_1.findBestMatch(results);
            return bestMatch ? [ bestMatch ] : results;
        }
        creditCardType.getTypeInfo = function(cardType) {
            return clone_1.clone(findType(cardType));
        };
        creditCardType.removeCard = function(name) {
            var position = getCardPosition(name);
            testOrder.splice(position, 1);
        };
        creditCardType.addCard = function(config) {
            var existingCardPosition = getCardPosition(config.type, !0);
            customCards[config.type] = config;
            -1 === existingCardPosition && testOrder.push(config.type);
        };
        creditCardType.updateCard = function(cardType, updates) {
            var originalObject = customCards[cardType] || cardTypes[cardType];
            if (!originalObject) throw new Error('"' + cardType + "\" is not a recognized type. Use `addCard` instead.'");
            if (updates.type && originalObject.type !== updates.type) throw new Error("Cannot overwrite type parameter.");
            var clonedCard = clone_1.clone(originalObject);
            clonedCard = __assign(__assign({}, clonedCard), updates);
            customCards[clonedCard.type] = clonedCard;
        };
        creditCardType.changeOrder = function(name, position) {
            var currentPosition = getCardPosition(name);
            testOrder.splice(currentPosition, 1);
            testOrder.splice(position, 0, name);
        };
        creditCardType.resetModifications = function() {
            testOrder = clone_1.clone(ORIGINAL_TEST_ORDER);
            customCards = {};
        };
        creditCardType.types = cardNames;
        module.exports = creditCardType;
    },
    "./node_modules/card-validator/node_modules/credit-card-type/dist/lib/add-matching-cards-to-results.js": function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.addMatchingCardsToResults = void 0;
        var clone_1 = __webpack_require__("./node_modules/card-validator/node_modules/credit-card-type/dist/lib/clone.js");
        var matches_1 = __webpack_require__("./node_modules/card-validator/node_modules/credit-card-type/dist/lib/matches.js");
        exports.addMatchingCardsToResults = function(cardNumber, cardConfiguration, results) {
            var i, patternLength;
            for (i = 0; i < cardConfiguration.patterns.length; i++) {
                var pattern = cardConfiguration.patterns[i];
                if (matches_1.matches(cardNumber, pattern)) {
                    var clonedCardConfiguration = clone_1.clone(cardConfiguration);
                    patternLength = Array.isArray(pattern) ? String(pattern[0]).length : String(pattern).length;
                    cardNumber.length >= patternLength && (clonedCardConfiguration.matchStrength = patternLength);
                    results.push(clonedCardConfiguration);
                    break;
                }
            }
        };
    },
    "./node_modules/card-validator/node_modules/credit-card-type/dist/lib/card-types.js": function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = {
            visa: {
                niceType: "Visa",
                type: "visa",
                patterns: [ 4 ],
                gaps: [ 4, 8, 12 ],
                lengths: [ 16, 18, 19 ],
                code: {
                    name: "CVV",
                    size: 3
                }
            },
            mastercard: {
                niceType: "Mastercard",
                type: "mastercard",
                patterns: [ [ 51, 55 ], [ 2221, 2229 ], [ 223, 229 ], [ 23, 26 ], [ 270, 271 ], 2720 ],
                gaps: [ 4, 8, 12 ],
                lengths: [ 16 ],
                code: {
                    name: "CVC",
                    size: 3
                }
            },
            "american-express": {
                niceType: "American Express",
                type: "american-express",
                patterns: [ 34, 37 ],
                gaps: [ 4, 10 ],
                lengths: [ 15 ],
                code: {
                    name: "CID",
                    size: 4
                }
            },
            "diners-club": {
                niceType: "Diners Club",
                type: "diners-club",
                patterns: [ [ 300, 305 ], 36, 38, 39 ],
                gaps: [ 4, 10 ],
                lengths: [ 14, 16, 19 ],
                code: {
                    name: "CVV",
                    size: 3
                }
            },
            discover: {
                niceType: "Discover",
                type: "discover",
                patterns: [ 6011, [ 644, 649 ], 65 ],
                gaps: [ 4, 8, 12 ],
                lengths: [ 16, 19 ],
                code: {
                    name: "CID",
                    size: 3
                }
            },
            jcb: {
                niceType: "JCB",
                type: "jcb",
                patterns: [ 2131, 1800, [ 3528, 3589 ] ],
                gaps: [ 4, 8, 12 ],
                lengths: [ 16, 17, 18, 19 ],
                code: {
                    name: "CVV",
                    size: 3
                }
            },
            unionpay: {
                niceType: "UnionPay",
                type: "unionpay",
                patterns: [ 620, [ 624, 626 ], [ 62100, 62182 ], [ 62184, 62187 ], [ 62185, 62197 ], [ 62200, 62205 ], [ 622010, 622999 ], 622018, [ 622019, 622999 ], [ 62207, 62209 ], [ 622126, 622925 ], [ 623, 626 ], 6270, 6272, 6276, [ 627700, 627779 ], [ 627781, 627799 ], [ 6282, 6289 ], 6291, 6292, 810, [ 8110, 8131 ], [ 8132, 8151 ], [ 8152, 8163 ], [ 8164, 8171 ] ],
                gaps: [ 4, 8, 12 ],
                lengths: [ 14, 15, 16, 17, 18, 19 ],
                code: {
                    name: "CVN",
                    size: 3
                }
            },
            maestro: {
                niceType: "Maestro",
                type: "maestro",
                patterns: [ 493698, [ 5e5, 504174 ], [ 504176, 506698 ], [ 506779, 508999 ], [ 56, 59 ], 63, 67, 6 ],
                gaps: [ 4, 8, 12 ],
                lengths: [ 12, 13, 14, 15, 16, 17, 18, 19 ],
                code: {
                    name: "CVC",
                    size: 3
                }
            },
            elo: {
                niceType: "Elo",
                type: "elo",
                patterns: [ 401178, 401179, 438935, 457631, 457632, 431274, 451416, 457393, 504175, [ 506699, 506778 ], [ 509e3, 509999 ], 627780, 636297, 636368, [ 650031, 650033 ], [ 650035, 650051 ], [ 650405, 650439 ], [ 650485, 650538 ], [ 650541, 650598 ], [ 650700, 650718 ], [ 650720, 650727 ], [ 650901, 650978 ], [ 651652, 651679 ], [ 655e3, 655019 ], [ 655021, 655058 ] ],
                gaps: [ 4, 8, 12 ],
                lengths: [ 16 ],
                code: {
                    name: "CVE",
                    size: 3
                }
            },
            mir: {
                niceType: "Mir",
                type: "mir",
                patterns: [ [ 2200, 2204 ] ],
                gaps: [ 4, 8, 12 ],
                lengths: [ 16, 17, 18, 19 ],
                code: {
                    name: "CVP2",
                    size: 3
                }
            },
            hiper: {
                niceType: "Hiper",
                type: "hiper",
                patterns: [ 637095, 63737423, 63743358, 637568, 637599, 637609, 637612 ],
                gaps: [ 4, 8, 12 ],
                lengths: [ 16 ],
                code: {
                    name: "CVC",
                    size: 3
                }
            },
            hipercard: {
                niceType: "Hipercard",
                type: "hipercard",
                patterns: [ 606282 ],
                gaps: [ 4, 8, 12 ],
                lengths: [ 16 ],
                code: {
                    name: "CVC",
                    size: 3
                }
            }
        };
    },
    "./node_modules/card-validator/node_modules/credit-card-type/dist/lib/clone.js": function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.clone = void 0;
        exports.clone = function(originalObject) {
            return originalObject ? JSON.parse(JSON.stringify(originalObject)) : null;
        };
    },
    "./node_modules/card-validator/node_modules/credit-card-type/dist/lib/find-best-match.js": function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.findBestMatch = void 0;
        exports.findBestMatch = function(results) {
            return function(results) {
                var numberOfResultsWithMaxStrengthProperty = results.filter((function(result) {
                    return result.matchStrength;
                })).length;
                return numberOfResultsWithMaxStrengthProperty > 0 && numberOfResultsWithMaxStrengthProperty === results.length;
            }(results) ? results.reduce((function(bestMatch, result) {
                return bestMatch ? Number(bestMatch.matchStrength) < Number(result.matchStrength) ? result : bestMatch : result;
            })) : null;
        };
    },
    "./node_modules/card-validator/node_modules/credit-card-type/dist/lib/is-valid-input-type.js": function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.isValidInputType = void 0;
        exports.isValidInputType = function(cardNumber) {
            return "string" == typeof cardNumber || cardNumber instanceof String;
        };
    },
    "./node_modules/card-validator/node_modules/credit-card-type/dist/lib/matches.js": function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.matches = void 0;
        exports.matches = function(cardNumber, pattern) {
            return Array.isArray(pattern) ? function(cardNumber, min, max) {
                var maxLengthToCheck = String(min).length;
                var substr = cardNumber.substr(0, maxLengthToCheck);
                var integerRepresentationOfCardNumber = parseInt(substr, 10);
                min = parseInt(String(min).substr(0, substr.length), 10);
                max = parseInt(String(max).substr(0, substr.length), 10);
                return integerRepresentationOfCardNumber >= min && integerRepresentationOfCardNumber <= max;
            }(cardNumber, pattern[0], pattern[1]) : function(cardNumber, pattern) {
                return (pattern = String(pattern)).substring(0, cardNumber.length) === cardNumber.substring(0, pattern.length);
            }(cardNumber, pattern);
        };
    },
    "./src/api/api.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "callRestAPI", (function() {
            return callRestAPI;
        }));
        __webpack_require__.d(__webpack_exports__, "callSmartAPI", (function() {
            return callSmartAPI;
        }));
        __webpack_require__.d(__webpack_exports__, "callGraphQL", (function() {
            return callGraphQL;
        }));
        __webpack_require__.d(__webpack_exports__, "getResponseCorrelationID", (function() {
            return getResponseCorrelationID;
        }));
        __webpack_require__.d(__webpack_exports__, "getErrorResponseCorrelationID", (function() {
            return getErrorResponseCorrelationID;
        }));
        var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/extends.js");
        var _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/config.js");
        var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/constants.js");
        var _lib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/lib/index.js");
        function callRestAPI(_ref) {
            var _extends2;
            var accessToken = _ref.accessToken, method = _ref.method, url = _ref.url, data = _ref.data, headers = _ref.headers, eventName = _ref.eventName, _ref$metricDimensions = _ref.metricDimensions, metricDimensions = void 0 === _ref$metricDimensions ? {} : _ref$metricDimensions;
            if (!accessToken) throw new Error("No access token passed to " + url);
            var requestHeaders = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)(((_extends2 = {})[_constants__WEBPACK_IMPORTED_MODULE_5__.HEADERS.AUTHORIZATION] = "Bearer " + accessToken, 
            _extends2[_constants__WEBPACK_IMPORTED_MODULE_5__.HEADERS.CONTENT_TYPE] = "application/json", 
            _extends2), headers);
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_3__.request)({
                method: method,
                url: url,
                headers: requestHeaders,
                json: data
            }).then((function(_ref2) {
                var status = _ref2.status, body = _ref2.body, responseHeaders = _ref2.headers;
                if (status >= 300) {
                    var error = new Error(url + " returned status " + status + " (Corr ID: " + responseHeaders[_constants__WEBPACK_IMPORTED_MODULE_5__.HEADERS.PAYPAL_DEBUG_ID] + ").\n\n" + JSON.stringify(body));
                    error.response = {
                        status: status,
                        headers: responseHeaders,
                        body: body
                    };
                    if (status === _constants__WEBPACK_IMPORTED_MODULE_5__.STATUS_CODES.TOO_MANY_REQUESTS) {
                        var _getLogger$track;
                        Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().track(((_getLogger$track = {})[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_1__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_TRANSITION.CALL_REST_API, 
                        _getLogger$track[_constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_CUSTOM_KEY.ERR_DESC] = "Error: " + status + " - " + body, 
                        _getLogger$track[_constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_CUSTOM_KEY.INFO_MSG] = "URL: " + url, 
                        _getLogger$track));
                    }
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().warn("rest_api_" + eventName + "_status_" + status + "_error");
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.sendCountMetric)({
                        name: "pp.app.paypal_sdk.buttons.rest_api_" + eventName + ".error.count",
                        dimensions: metricDimensions
                    });
                    throw error;
                }
                Object(_lib__WEBPACK_IMPORTED_MODULE_6__.sendCountMetric)({
                    name: "pp.app.paypal_sdk.buttons.rest_api_" + eventName + ".success.count",
                    dimensions: metricDimensions
                });
                return body;
            }));
        }
        function callSmartAPI(_ref3) {
            var accessToken = _ref3.accessToken, url = _ref3.url, _ref3$method = _ref3.method, method = void 0 === _ref3$method ? "get" : _ref3$method, _ref3$headers = _ref3.headers, reqHeaders = void 0 === _ref3$headers ? {} : _ref3$headers, json = _ref3.json, _ref3$authenticated = _ref3.authenticated, authenticated = void 0 === _ref3$authenticated || _ref3$authenticated, eventName = _ref3.eventName, _ref3$metricDimension = _ref3.metricDimensions, metricDimensions = void 0 === _ref3$metricDimension ? {} : _ref3$metricDimension;
            reqHeaders[_constants__WEBPACK_IMPORTED_MODULE_5__.HEADERS.REQUESTED_BY] = _constants__WEBPACK_IMPORTED_MODULE_5__.SMART_PAYMENT_BUTTONS;
            if (authenticated && !accessToken) throw new Error("Buyer access token not present - can not call smart api: " + url);
            accessToken && (reqHeaders[_constants__WEBPACK_IMPORTED_MODULE_5__.HEADERS.ACCESS_TOKEN] = accessToken);
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_3__.request)({
                url: url,
                method: method,
                headers: reqHeaders,
                json: json
            }).then((function(_ref4) {
                var status = _ref4.status, body = _ref4.body, headers = _ref4.headers;
                if ("contingency" === body.ack) {
                    var err = new Error(body.contingency);
                    err.response = {
                        url: url,
                        method: method,
                        headers: reqHeaders,
                        body: body
                    };
                    err.data = body.data;
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().warn("smart_api_" + eventName + "_contingency_error");
                    throw err;
                }
                if (status === _constants__WEBPACK_IMPORTED_MODULE_5__.STATUS_CODES.TOO_MANY_REQUESTS) {
                    var _getLogger$track2;
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().track(((_getLogger$track2 = {})[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_1__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_TRANSITION.CALL_REST_API, 
                    _getLogger$track2[_constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_CUSTOM_KEY.ERR_DESC] = "Error: " + status + " - " + body, 
                    _getLogger$track2[_constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_CUSTOM_KEY.INFO_MSG] = "URL: " + url, 
                    _getLogger$track2));
                }
                if (status > 400) {
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().warn("smart_api_" + eventName + "_status_" + status + "_error");
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.sendCountMetric)({
                        name: "pp.app.paypal_sdk.buttons.smart_api_" + eventName + ".error.count",
                        dimensions: Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({
                            status: status
                        }, metricDimensions)
                    });
                    throw new Error("Api: " + url + " returned status code: " + status + " (Corr ID: " + headers[_constants__WEBPACK_IMPORTED_MODULE_5__.HEADERS.PAYPAL_DEBUG_ID] + ")\n\n" + JSON.stringify(body));
                }
                if ("success" !== body.ack) {
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().warn("smart_api_" + eventName + "_ack_error");
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.sendCountMetric)({
                        name: "pp.app.paypal_sdk.buttons.smart_api_" + eventName + ".error.count",
                        dimensions: metricDimensions
                    });
                    throw new Error("Api: " + url + " returned ack: " + body.ack + " (Corr ID: " + headers[_constants__WEBPACK_IMPORTED_MODULE_5__.HEADERS.PAYPAL_DEBUG_ID] + ")\n\n" + JSON.stringify(body));
                }
                Object(_lib__WEBPACK_IMPORTED_MODULE_6__.sendCountMetric)({
                    name: "pp.app.paypal_sdk.buttons.smart_api_" + eventName + ".success.count",
                    dimensions: metricDimensions
                });
                return {
                    data: body.data,
                    headers: headers
                };
            }));
        }
        function callGraphQL(_ref5) {
            var name = _ref5.name, query = _ref5.query, _ref5$variables = _ref5.variables, variables = void 0 === _ref5$variables ? {} : _ref5$variables, _ref5$headers = _ref5.headers, headers = void 0 === _ref5$headers ? {} : _ref5$headers, _ref5$returnErrorObje = _ref5.returnErrorObject, returnErrorObject = void 0 !== _ref5$returnErrorObje && _ref5$returnErrorObje;
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_3__.request)({
                url: _config__WEBPACK_IMPORTED_MODULE_4__.GRAPHQL_URI + "?" + name,
                method: "POST",
                json: {
                    query: query,
                    variables: variables
                },
                headers: Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({
                    "x-app-name": _constants__WEBPACK_IMPORTED_MODULE_5__.SMART_PAYMENT_BUTTONS
                }, headers)
            }).then((function(_ref6) {
                var status = _ref6.status, body = _ref6.body;
                var errors = body.errors || [];
                if (errors.length) {
                    var message = errors[0].message || JSON.stringify(errors[0]);
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().warn("graphql_" + name + "_error", {
                        err: message
                    });
                    if (returnErrorObject) throw errors[0];
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.sendCountMetric)({
                        name: "pp.app.paypal_sdk.buttons.graphql_" + name + ".error.count",
                        dimensions: {}
                    });
                    throw new Error(message);
                }
                if (200 !== status) {
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().warn("graphql_" + name + "_status_" + status + "_error");
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.sendCountMetric)({
                        name: "pp.app.paypal_sdk.buttons.graphql_" + name + ".error.count",
                        dimensions: {
                            status: status
                        }
                    });
                    throw new Error(_config__WEBPACK_IMPORTED_MODULE_4__.GRAPHQL_URI + " returned status " + status + "\n\n" + JSON.stringify(body));
                }
                Object(_lib__WEBPACK_IMPORTED_MODULE_6__.sendCountMetric)({
                    name: "pp.app.paypal_sdk.buttons.graphql_" + name + ".success.count",
                    dimensions: {}
                });
                return body.data;
            }));
        }
        function getResponseCorrelationID(res) {
            return res.headers[_constants__WEBPACK_IMPORTED_MODULE_5__.HEADERS.PAYPAL_DEBUG_ID];
        }
        function getErrorResponseCorrelationID(err) {
            var res = null == err ? void 0 : err.response;
            if (res) return getResponseCorrelationID(res);
        }
    },
    "./src/api/index.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "createAccessToken", (function() {
            return createAccessToken;
        }));
        __webpack_require__.d(__webpack_exports__, "getFirebaseSessionToken", (function() {
            return getFirebaseSessionToken;
        }));
        __webpack_require__.d(__webpack_exports__, "onLsatUpgradeCalled", (function() {
            return onLsatUpgradeCalled;
        }));
        __webpack_require__.d(__webpack_exports__, "getLsatUpgradeWithIgnoreCache", (function() {
            return getLsatUpgradeWithIgnoreCache;
        }));
        __webpack_require__.d(__webpack_exports__, "getLsatUpgradeCalled", (function() {
            return getLsatUpgradeCalled;
        }));
        __webpack_require__.d(__webpack_exports__, "onLsatUpgradeError", (function() {
            return onLsatUpgradeError;
        }));
        __webpack_require__.d(__webpack_exports__, "getLsatUpgradeError", (function() {
            return getLsatUpgradeError;
        }));
        __webpack_require__.d(__webpack_exports__, "clearLsatState", (function() {
            return clearLsatState;
        }));
        __webpack_require__.d(__webpack_exports__, "upgradeFacilitatorAccessToken", (function() {
            return upgradeFacilitatorAccessToken;
        }));
        __webpack_require__.d(__webpack_exports__, "upgradeFacilitatorAccessTokenWithIgnoreCache", (function() {
            return upgradeFacilitatorAccessTokenWithIgnoreCache;
        }));
        __webpack_require__.d(__webpack_exports__, "exchangeAccessTokenForAuthCode", (function() {
            return exchangeAccessTokenForAuthCode;
        }));
        __webpack_require__.d(__webpack_exports__, "getConnectURL", (function() {
            return getConnectURL;
        }));
        __webpack_require__.d(__webpack_exports__, "createOrderID", (function() {
            return createOrderID;
        }));
        __webpack_require__.d(__webpack_exports__, "isInvalidResourceIDError", (function() {
            return isInvalidResourceIDError;
        }));
        __webpack_require__.d(__webpack_exports__, "getOrder", (function() {
            return getOrder;
        }));
        __webpack_require__.d(__webpack_exports__, "isProcessorDeclineError", (function() {
            return isProcessorDeclineError;
        }));
        __webpack_require__.d(__webpack_exports__, "isUnprocessableEntityError", (function() {
            return isUnprocessableEntityError;
        }));
        __webpack_require__.d(__webpack_exports__, "captureOrder", (function() {
            return captureOrder;
        }));
        __webpack_require__.d(__webpack_exports__, "authorizeOrder", (function() {
            return authorizeOrder;
        }));
        __webpack_require__.d(__webpack_exports__, "patchOrder", (function() {
            return patchOrder;
        }));
        __webpack_require__.d(__webpack_exports__, "patchShipping", (function() {
            return patchShipping;
        }));
        __webpack_require__.d(__webpack_exports__, "confirmOrderAPI", (function() {
            return confirmOrderAPI;
        }));
        __webpack_require__.d(__webpack_exports__, "buildPaymentSource", (function() {
            return buildPaymentSource;
        }));
        __webpack_require__.d(__webpack_exports__, "validatePaymentMethod", (function() {
            return validatePaymentMethod;
        }));
        __webpack_require__.d(__webpack_exports__, "billingTokenToOrderID", (function() {
            return billingTokenToOrderID;
        }));
        __webpack_require__.d(__webpack_exports__, "subscriptionIdToCartId", (function() {
            return subscriptionIdToCartId;
        }));
        __webpack_require__.d(__webpack_exports__, "enableVault", (function() {
            return enableVault;
        }));
        __webpack_require__.d(__webpack_exports__, "deleteVault", (function() {
            return deleteVault;
        }));
        __webpack_require__.d(__webpack_exports__, "updateClientConfig", (function() {
            return updateClientConfig;
        }));
        __webpack_require__.d(__webpack_exports__, "approveOrder", (function() {
            return approveOrder;
        }));
        __webpack_require__.d(__webpack_exports__, "oneClickApproveOrder", (function() {
            return oneClickApproveOrder;
        }));
        __webpack_require__.d(__webpack_exports__, "getSupplementalOrderInfo", (function() {
            return getSupplementalOrderInfo;
        }));
        __webpack_require__.d(__webpack_exports__, "getShippingOrderInfo", (function() {
            return order_getShippingOrderInfo;
        }));
        __webpack_require__.d(__webpack_exports__, "getDetailedOrderInfo", (function() {
            return order_getDetailedOrderInfo;
        }));
        __webpack_require__.d(__webpack_exports__, "updateButtonClientConfig", (function() {
            return updateButtonClientConfig;
        }));
        __webpack_require__.d(__webpack_exports__, "approveCardPayment", (function() {
            return approveCardPayment;
        }));
        __webpack_require__.d(__webpack_exports__, "createPayment", (function() {
            return createPayment;
        }));
        __webpack_require__.d(__webpack_exports__, "createPaymentID", (function() {
            return createPaymentID;
        }));
        __webpack_require__.d(__webpack_exports__, "createPaymentToken", (function() {
            return createPaymentToken;
        }));
        __webpack_require__.d(__webpack_exports__, "getPayment", (function() {
            return getPayment;
        }));
        __webpack_require__.d(__webpack_exports__, "executePayment", (function() {
            return executePayment;
        }));
        __webpack_require__.d(__webpack_exports__, "patchPayment", (function() {
            return patchPayment;
        }));
        __webpack_require__.d(__webpack_exports__, "approveApplePayPayment", (function() {
            return approveApplePayPayment;
        }));
        __webpack_require__.d(__webpack_exports__, "createSubscription", (function() {
            return createSubscription;
        }));
        __webpack_require__.d(__webpack_exports__, "reviseSubscription", (function() {
            return reviseSubscription;
        }));
        __webpack_require__.d(__webpack_exports__, "activateSubscription", (function() {
            return activateSubscription;
        }));
        __webpack_require__.d(__webpack_exports__, "getSubscription", (function() {
            return getSubscription;
        }));
        __webpack_require__.d(__webpack_exports__, "messageSocket", (function() {
            return messageSocket;
        }));
        __webpack_require__.d(__webpack_exports__, "webSocket", (function() {
            return webSocket;
        }));
        __webpack_require__.d(__webpack_exports__, "loadFirebaseSDK", (function() {
            return loadFirebaseSDK;
        }));
        __webpack_require__.d(__webpack_exports__, "firebaseSocket", (function() {
            return firebaseSocket;
        }));
        __webpack_require__.d(__webpack_exports__, "FRAUDNET_FNCLS", (function() {
            return FRAUDNET_FNCLS;
        }));
        __webpack_require__.d(__webpack_exports__, "FRAUDNET_APP_NAME", (function() {
            return FRAUDNET_APP_NAME;
        }));
        __webpack_require__.d(__webpack_exports__, "loadFraudnet", (function() {
            return loadFraudnet;
        }));
        __webpack_require__.d(__webpack_exports__, "getSmartWallet", (function() {
            return getSmartWallet;
        }));
        __webpack_require__.d(__webpack_exports__, "getFundingEligibility", (function() {
            return getFundingEligibility;
        }));
        __webpack_require__.d(__webpack_exports__, "getGuestEnabledStatus", (function() {
            return getGuestEnabledStatus;
        }));
        __webpack_require__.d(__webpack_exports__, "getNativeEligibility", (function() {
            return getNativeEligibility;
        }));
        __webpack_require__.d(__webpack_exports__, "getApplePayMerchantSession", (function() {
            return getApplePayMerchantSession;
        }));
        __webpack_require__.d(__webpack_exports__, "callRestAPI", (function() {
            return api.callRestAPI;
        }));
        __webpack_require__.d(__webpack_exports__, "callSmartAPI", (function() {
            return api.callSmartAPI;
        }));
        __webpack_require__.d(__webpack_exports__, "callGraphQL", (function() {
            return api.callGraphQL;
        }));
        __webpack_require__.d(__webpack_exports__, "getResponseCorrelationID", (function() {
            return api.getResponseCorrelationID;
        }));
        __webpack_require__.d(__webpack_exports__, "getErrorResponseCorrelationID", (function() {
            return api.getErrorResponseCorrelationID;
        }));
        __webpack_require__.d(__webpack_exports__, "getApplepayConfig", (function() {
            return config_getApplepayConfig;
        }));
        var src = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var belter_src = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        var sdk_constants_src = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var src_config = __webpack_require__("./src/config.js");
        var lib = __webpack_require__("./src/lib/index.js");
        var constants = __webpack_require__("./src/constants.js");
        var api = __webpack_require__("./src/api/api.js");
        function createAccessToken(clientID, _temp) {
            var targetSubject = (void 0 === _temp ? {} : _temp).targetSubject;
            return Object(belter_src.inlineMemoize)(createAccessToken, (function() {
                Object(lib.getLogger)().info("rest_api_create_access_token");
                var basicAuth = Object(belter_src.base64encode)((clientID || "") + ":");
                var data = {
                    grant_type: "client_credentials"
                };
                targetSubject && (data.target_subject = targetSubject);
                return Object(belter_src.request)({
                    method: "post",
                    url: src_config.AUTH_API_URL,
                    headers: {
                        Authorization: "Basic " + basicAuth
                    },
                    data: data
                }).then((function(_ref2) {
                    var body = _ref2.body;
                    if (body && "invalid_client" === body.error) {
                        Object(lib.getLogger)().warn("rest_api_v1_oauth2_token_create_error", {
                            err: "invalid client id"
                        });
                        throw new Error("Auth Api invalid client id: " + (clientID || "") + ":\n\n" + JSON.stringify(body, null, 4));
                    }
                    if (!body || !body.access_token) {
                        Object(lib.getLogger)().warn("rest_api_v1_oauth2_token_create_error");
                        throw new Error("Auth Api response error:\n\n" + JSON.stringify(body, null, 4));
                    }
                    return body.access_token;
                }));
            }), [ clientID, targetSubject ]);
        }
        function getFirebaseSessionToken(sessionUID) {
            return Object(api.callGraphQL)({
                name: "GetFireBaseSessionToken",
                query: "\n            query GetFireBaseSessionToken($sessionUID: String!) {\n                firebase {\n                    auth(sessionUID: $sessionUID) {\n                        sessionToken\n                    }\n                }\n            }\n        ",
                variables: {
                    sessionUID: sessionUID
                }
            }).then((function(res) {
                return res.firebase.auth.sessionToken;
            }));
        }
        var auth_lsatUpgradeCalled = !1;
        var auth_lsatUpgradeError;
        var lsatUpgradeWithIgnoreCache = !1;
        var onLsatUpgradeCalled = function() {
            auth_lsatUpgradeCalled = !0;
        };
        var getLsatUpgradeWithIgnoreCache = function() {
            return lsatUpgradeWithIgnoreCache;
        };
        var getLsatUpgradeCalled = function() {
            return auth_lsatUpgradeCalled;
        };
        var onLsatUpgradeError = function(err) {
            auth_lsatUpgradeError = err;
        };
        var getLsatUpgradeError = function() {
            return auth_lsatUpgradeError;
        };
        var clearLsatState = function() {
            auth_lsatUpgradeCalled = !1;
            auth_lsatUpgradeError = null;
            lsatUpgradeWithIgnoreCache = !1;
        };
        function upgradeFacilitatorAccessToken(facilitatorAccessToken, _ref3) {
            var _headers;
            var buyerAccessToken = _ref3.buyerAccessToken, orderID = _ref3.orderID;
            clearLsatState();
            onLsatUpgradeCalled();
            return Object(api.callGraphQL)({
                name: "UpgradeFacilitatorAccessToken",
                headers: (_headers = {}, _headers[constants.HEADERS.ACCESS_TOKEN] = buyerAccessToken, 
                _headers[constants.HEADERS.CLIENT_CONTEXT] = orderID, _headers),
                query: "\n            mutation UpgradeFacilitatorAccessToken(\n                $orderID: String!\n                $buyerAccessToken: String!\n                $facilitatorAccessToken: String!\n            ) {\n                upgradeLowScopeAccessToken(\n                    token: $orderID\n                    buyerAccessToken: $buyerAccessToken\n                    merchantLSAT: $facilitatorAccessToken\n                )\n            }\n        ",
                variables: {
                    facilitatorAccessToken: facilitatorAccessToken,
                    buyerAccessToken: buyerAccessToken,
                    orderID: orderID
                }
            }).then(belter_src.noop).catch((function(err) {
                onLsatUpgradeError(err);
                throw err;
            }));
        }
        function upgradeFacilitatorAccessTokenWithIgnoreCache(facilitatorAccessToken, buyerAccessToken, orderID) {
            return Object(belter_src.inlineMemoize)(upgradeFacilitatorAccessTokenWithIgnoreCache, (function() {
                var _headers2;
                clearLsatState();
                onLsatUpgradeCalled();
                lsatUpgradeWithIgnoreCache = !0;
                return Object(api.callGraphQL)({
                    name: "CreateUpgradedLowScopeAccessToken",
                    headers: (_headers2 = {}, _headers2[constants.HEADERS.ACCESS_TOKEN] = buyerAccessToken, 
                    _headers2[constants.HEADERS.CLIENT_CONTEXT] = orderID, _headers2),
                    query: "\n            mutation CreateUpgradedLowScopeAccessToken(\n                $orderID: String!\n                $buyerAccessToken: String!\n                $facilitatorAccessToken: String!\n            ) {\n                createUpgradedLowScopeAccessToken(\n                    token: $orderID\n                    buyerAccessToken: $buyerAccessToken\n                    merchantLSAT: $facilitatorAccessToken\n                )\n            }\n        ",
                    variables: {
                        facilitatorAccessToken: facilitatorAccessToken,
                        buyerAccessToken: buyerAccessToken,
                        orderID: orderID
                    }
                }).then((function(res) {
                    Object(lib.getLogger)().info("create_upgraded_low_scope_access_token_success", {
                        orderID: orderID
                    });
                    return null == res ? void 0 : res.createUpgradedLowScopeAccessToken;
                })).catch((function(err) {
                    Object(lib.getLogger)().warn("create_upgraded_low_scope_access_token_error", {
                        orderID: orderID
                    });
                    onLsatUpgradeError(err);
                    return facilitatorAccessToken;
                }));
            }), [ facilitatorAccessToken, buyerAccessToken, orderID ]);
        }
        function exchangeAccessTokenForAuthCode(buyerAccessToken) {
            return Object(api.callGraphQL)({
                name: "ExchangeAuthCode",
                query: "\n            query ExchangeAuthCode(\n                $buyerAccessToken: String!\n            ) {\n                auth(\n                    accessToken: $buyerAccessToken\n                ) {\n                    authCode\n                }\n            }\n        ",
                variables: {
                    buyerAccessToken: buyerAccessToken
                }
            }).then((function(_ref4) {
                return _ref4.auth.authCode;
            }));
        }
        function getConnectURL(_ref5) {
            var clientID = _ref5.clientID, orderID = _ref5.orderID, payerID = _ref5.payerID, fundingSource = _ref5.fundingSource;
            var scopes = _ref5.connect.scopes;
            return Object(api.callGraphQL)({
                name: "GetConnectURL",
                query: "\n            query GetConnectURL(\n                $clientID: String!\n                $orderID: String!\n                $scopes: [String]!\n                $fundingSource: String\n                $payerID: String\n            ) {\n                auth(\n                    clientId: $clientID\n                ) {\n                    connectUrl(\n                        token: $orderID\n                        scopes: $scopes\n                        fundingSource: $fundingSource\n                        payerId: $payerID\n                    ) {\n                        href\n                    }\n                }\n            }\n        ",
                variables: {
                    clientID: clientID,
                    orderID: orderID,
                    payerID: payerID,
                    scopes: scopes,
                    fundingSource: fundingSource
                }
            }).then((function(_ref6) {
                return _ref6.auth.connectUrl.href;
            }));
        }
        var esm_extends = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/extends.js");
        function createOrderID(order, _ref) {
            var _headers;
            var facilitatorAccessToken = _ref.facilitatorAccessToken, partnerAttributionID = _ref.partnerAttributionID;
            Object(lib.getLogger)().info("rest_api_create_order_id");
            return Object(api.callRestAPI)({
                accessToken: facilitatorAccessToken,
                method: "post",
                url: "" + src_config.ORDERS_API_URL,
                eventName: "v2_checkout_orders_create",
                data: order,
                headers: (_headers = {}, _headers[constants.HEADERS.PARTNER_ATTRIBUTION_ID] = partnerAttributionID || "", 
                _headers[constants.HEADERS.PREFER] = constants.PREFER.REPRESENTATION, _headers)
            }).then((function(body) {
                var _getLogger$track;
                var orderID = body && body.id;
                if (!orderID) throw new Error("Order Api response error:\n\n" + JSON.stringify(body, null, 4));
                Object(lib.getLogger)().track(((_getLogger$track = {})[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.CREATE_ORDER, 
                _getLogger$track[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = constants.FPTI_CONTEXT_TYPE.ORDER_ID, 
                _getLogger$track[sdk_constants_src.FPTI_KEY.TOKEN] = orderID, _getLogger$track[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = orderID, 
                _getLogger$track));
                return orderID;
            }));
        }
        function isInvalidResourceIDError(err) {
            var _err$response;
            return Boolean(null == err || null == (_err$response = err.response) || null == (_err$response = _err$response.body) || null == (_err$response = _err$response.details) ? void 0 : _err$response.some((function(detail) {
                return detail.issue === constants.ORDER_API_ERROR.INVALID_RESOURCE_ID;
            })));
        }
        function lsatUpgradeType() {
            return getLsatUpgradeWithIgnoreCache() ? "with_ignore_cache_lsat_upgrade" : "without_ignore_cache_lsat_upgrade";
        }
        function lsatUpgradeMetricValue() {
            var lsatUpgradeCalled = Boolean(getLsatUpgradeCalled());
            var lsatUpgradeIgnoreCache = Boolean(getLsatUpgradeWithIgnoreCache());
            var lsatUpgradeError = Boolean(getLsatUpgradeError());
            var cacheType = lsatUpgradeIgnoreCache ? "with_ignore_cache" : "without_ignore_cache";
            return lsatUpgradeCalled ? lsatUpgradeError ? cacheType + "_error" : cacheType + "_success" : cacheType + "_not_called";
        }
        function logPayeeInfoForClientSideHelpers(orderID, method) {
            getSupplementalOrderInfo(orderID).then((function(order) {
                var merchantIds = (order.checkoutSession.payees || []).map((function(p) {
                    return p.merchantId;
                }));
                Object(lib.getLogger)().info("using_client_side_helper_" + method, {
                    payee: merchantIds.join(),
                    orderID: orderID
                });
            })).catch((function(err) {
                Object(lib.getLogger)().warn("err_getting_payee_client_side_helper_" + method, {
                    orderID: orderID,
                    err: Object(belter_src.stringifyError)(err)
                });
            }));
        }
        function getOrder(orderID, _ref2) {
            var _headers4;
            var facilitatorAccessToken = _ref2.facilitatorAccessToken, buyerAccessToken = _ref2.buyerAccessToken, partnerAttributionID = _ref2.partnerAttributionID, _ref2$forceRestAPI = _ref2.forceRestAPI, forceRestAPI = void 0 !== _ref2$forceRestAPI && _ref2$forceRestAPI, experiments = _ref2.experiments;
            Object(lib.getLogger)().info("get_order_" + lsatUpgradeType() + "_" + (getLsatUpgradeCalled() ? "called" : "not_called"), {
                orderID: orderID
            });
            Object(lib.getLogger)().info("get_order_" + lsatUpgradeType() + "_" + (getLsatUpgradeError() ? "errored" : "did_not_error"), {
                orderID: orderID,
                err: Object(belter_src.stringifyError)(getLsatUpgradeError())
            });
            logPayeeInfoForClientSideHelpers(orderID, "get");
            if (forceRestAPI && !getLsatUpgradeError()) {
                var _headers2;
                return Object(api.callRestAPI)({
                    accessToken: facilitatorAccessToken,
                    url: src_config.ORDERS_API_URL + "/" + orderID,
                    eventName: "v2_checkout_orders_get",
                    headers: (_headers2 = {}, _headers2[constants.HEADERS.PARTNER_ATTRIBUTION_ID] = partnerAttributionID || "", 
                    _headers2[constants.HEADERS.PREFER] = constants.PREFER.REPRESENTATION, _headers2),
                    metricDimensions: {
                        lsatUpgrade: lsatUpgradeMetricValue()
                    }
                }).catch((function(err) {
                    var _headers3;
                    var restCorrID = Object(api.getErrorResponseCorrelationID)(err);
                    Object(lib.getLogger)().warn("get_order_" + lsatUpgradeType() + "_call_rest_api_error", {
                        restCorrID: restCorrID,
                        orderID: orderID,
                        err: Object(belter_src.stringifyError)(err)
                    });
                    isInvalidResourceIDError(err) && Object(lib.getLogger)().warn("get_order_" + lsatUpgradeType() + "_invalid_resource_id_error", {
                        restCorrID: restCorrID,
                        orderID: orderID,
                        err: Object(belter_src.stringifyError)(err)
                    });
                    if (experiments.disableSmartAPI) throw err;
                    return Object(api.callSmartAPI)({
                        accessToken: buyerAccessToken,
                        url: src_config.SMART_API_URI.ORDER + "/" + orderID,
                        eventName: "order_get",
                        headers: (_headers3 = {}, _headers3[constants.HEADERS.CLIENT_CONTEXT] = orderID, 
                        _headers3),
                        metricDimensions: {
                            lsatUpgrade: lsatUpgradeMetricValue(),
                            smartApiType: "fallback"
                        }
                    }).then((function(res) {
                        var smartCorrID = Object(api.getResponseCorrelationID)(res);
                        Object(lib.getLogger)().info("get_order_" + lsatUpgradeType() + "_smart_fallback_success", {
                            smartCorrID: smartCorrID,
                            restCorrID: restCorrID,
                            orderID: orderID
                        });
                        return res.data;
                    })).catch((function(smartErr) {
                        var smartCorrID = Object(api.getErrorResponseCorrelationID)(err);
                        Object(lib.getLogger)().error("get_order_" + lsatUpgradeType() + "_smart_fallback_error", {
                            smartCorrID: smartCorrID,
                            restCorrID: restCorrID,
                            orderID: orderID,
                            err: Object(belter_src.stringifyError)(smartErr)
                        });
                        throw smartErr;
                    }));
                })).finally((function() {
                    Object(lib.getLogger)().flush();
                }));
            }
            return Object(api.callSmartAPI)({
                accessToken: buyerAccessToken,
                url: src_config.SMART_API_URI.ORDER + "/" + orderID,
                eventName: "order_get",
                headers: (_headers4 = {}, _headers4[constants.HEADERS.CLIENT_CONTEXT] = orderID, 
                _headers4),
                metricDimensions: {
                    lsatUpgrade: lsatUpgradeMetricValue(),
                    smartApiType: "default"
                }
            }).then((function(_ref3) {
                return _ref3.data;
            })).finally((function() {
                Object(lib.getLogger)().flush();
            }));
        }
        function isProcessorDeclineError(err) {
            var _err$response2, _err$response3, _err$response4;
            var details = null != err && null != (_err$response2 = err.response) && null != (_err$response2 = _err$response2.body) && null != (_err$response2 = _err$response2.data) && _err$response2.details ? null == err || null == (_err$response3 = err.response) || null == (_err$response3 = _err$response3.body) || null == (_err$response3 = _err$response3.data) ? void 0 : _err$response3.details : null == err || null == (_err$response4 = err.response) || null == (_err$response4 = _err$response4.body) ? void 0 : _err$response4.details;
            return Boolean(null == details ? void 0 : details.some((function(detail) {
                return detail.issue === constants.ORDER_API_ERROR.INSTRUMENT_DECLINED || detail.issue === constants.ORDER_API_ERROR.PAYER_ACTION_REQUIRED;
            })));
        }
        function isUnprocessableEntityError(err) {
            var _err$response5;
            return Boolean(null == err || null == (_err$response5 = err.response) || null == (_err$response5 = _err$response5.body) || null == (_err$response5 = _err$response5.details) ? void 0 : _err$response5.some((function(detail) {
                return detail.issue === constants.ORDER_API_ERROR.DUPLICATE_INVOICE_ID;
            })));
        }
        function captureOrder(orderID, _ref4) {
            var _headers7;
            var facilitatorAccessToken = _ref4.facilitatorAccessToken, buyerAccessToken = _ref4.buyerAccessToken, partnerAttributionID = _ref4.partnerAttributionID, _ref4$forceRestAPI = _ref4.forceRestAPI, forceRestAPI = void 0 !== _ref4$forceRestAPI && _ref4$forceRestAPI, experiments = _ref4.experiments;
            Object(lib.getLogger)().info("capture_order_" + lsatUpgradeType() + "_" + (getLsatUpgradeCalled() ? "called" : "not_called"), {
                orderID: orderID
            });
            Object(lib.getLogger)().info("capture_order_" + lsatUpgradeType() + "_" + (getLsatUpgradeError() ? "errored" : "did_not_error"), {
                orderID: orderID,
                err: Object(belter_src.stringifyError)(getLsatUpgradeError())
            });
            logPayeeInfoForClientSideHelpers(orderID, "capture");
            if (forceRestAPI && !getLsatUpgradeError()) {
                var _headers5;
                return Object(api.callRestAPI)({
                    accessToken: facilitatorAccessToken,
                    method: "post",
                    eventName: "v2_checkout_orders_capture",
                    url: src_config.ORDERS_API_URL + "/" + orderID + "/capture",
                    headers: (_headers5 = {}, _headers5[constants.HEADERS.PARTNER_ATTRIBUTION_ID] = partnerAttributionID || "", 
                    _headers5[constants.HEADERS.PREFER] = constants.PREFER.REPRESENTATION, _headers5[constants.HEADERS.PAYPAL_REQUEST_ID] = orderID, 
                    _headers5),
                    metricDimensions: {
                        lsatUpgrade: lsatUpgradeMetricValue()
                    }
                }).catch((function(err) {
                    var _headers6;
                    var restCorrID = Object(api.getErrorResponseCorrelationID)(err);
                    Object(lib.getLogger)().warn("capture_order_" + lsatUpgradeType() + "_call_rest_api_error", {
                        restCorrID: restCorrID,
                        orderID: orderID,
                        err: Object(belter_src.stringifyError)(err)
                    });
                    isInvalidResourceIDError(err) && Object(lib.getLogger)().warn("capture_order_" + lsatUpgradeType() + "_invalid_resource_id_error", {
                        restCorrID: restCorrID,
                        orderID: orderID,
                        err: Object(belter_src.stringifyError)(err)
                    });
                    if (isProcessorDeclineError(err) || isUnprocessableEntityError(err)) throw err;
                    if (experiments.disableSmartAPI) throw err;
                    return Object(api.callSmartAPI)({
                        accessToken: buyerAccessToken,
                        method: "post",
                        eventName: "order_capture",
                        url: src_config.SMART_API_URI.ORDER + "/" + orderID + "/capture",
                        json: {
                            data: {
                                facilitatorAccessToken: facilitatorAccessToken
                            }
                        },
                        headers: (_headers6 = {}, _headers6[constants.HEADERS.CLIENT_CONTEXT] = orderID, 
                        _headers6),
                        metricDimensions: {
                            lsatUpgrade: lsatUpgradeMetricValue(),
                            smartApiType: "fallback"
                        }
                    }).then((function(res) {
                        var smartCorrID = Object(api.getResponseCorrelationID)(res);
                        Object(lib.getLogger)().info("capture_order_" + lsatUpgradeType() + "_smart_fallback_success", {
                            smartCorrID: smartCorrID,
                            restCorrID: restCorrID,
                            orderID: orderID
                        });
                        return res.data;
                    })).catch((function(smartErr) {
                        var smartCorrID = Object(api.getErrorResponseCorrelationID)(err);
                        Object(lib.getLogger)().info("capture_order_" + lsatUpgradeType() + "_smart_fallback_error", {
                            smartCorrID: smartCorrID,
                            restCorrID: restCorrID,
                            orderID: orderID,
                            err: Object(belter_src.stringifyError)(smartErr)
                        });
                        throw smartErr;
                    }));
                })).finally((function() {
                    Object(lib.getLogger)().flush();
                }));
            }
            return Object(api.callSmartAPI)({
                accessToken: buyerAccessToken,
                method: "post",
                eventName: "order_capture",
                url: src_config.SMART_API_URI.ORDER + "/" + orderID + "/capture",
                json: {
                    data: {
                        facilitatorAccessToken: facilitatorAccessToken
                    }
                },
                headers: (_headers7 = {}, _headers7[constants.HEADERS.CLIENT_CONTEXT] = orderID, 
                _headers7),
                metricDimensions: {
                    lsatUpgrade: lsatUpgradeMetricValue(),
                    smartApiType: "default"
                }
            }).then((function(_ref5) {
                return _ref5.data;
            })).finally((function() {
                Object(lib.getLogger)().flush();
            }));
        }
        function authorizeOrder(orderID, _ref6) {
            var _headers10;
            var facilitatorAccessToken = _ref6.facilitatorAccessToken, buyerAccessToken = _ref6.buyerAccessToken, partnerAttributionID = _ref6.partnerAttributionID, _ref6$forceRestAPI = _ref6.forceRestAPI, forceRestAPI = void 0 !== _ref6$forceRestAPI && _ref6$forceRestAPI, experiments = _ref6.experiments;
            Object(lib.getLogger)().info("authorize_order_" + lsatUpgradeType() + "_" + (getLsatUpgradeCalled() ? "called" : "not_called"), {
                orderID: orderID
            });
            Object(lib.getLogger)().info("authorize_order_" + lsatUpgradeType() + "_" + (getLsatUpgradeError() ? "errored" : "did_not_error"), {
                orderID: orderID,
                err: Object(belter_src.stringifyError)(getLsatUpgradeError())
            });
            logPayeeInfoForClientSideHelpers(orderID, "authorize");
            if (forceRestAPI && !getLsatUpgradeError()) {
                var _headers8;
                return Object(api.callRestAPI)({
                    accessToken: facilitatorAccessToken,
                    method: "post",
                    eventName: "v2_checkout_orders_authorize",
                    url: src_config.ORDERS_API_URL + "/" + orderID + "/authorize",
                    headers: (_headers8 = {}, _headers8[constants.HEADERS.PARTNER_ATTRIBUTION_ID] = partnerAttributionID || "", 
                    _headers8[constants.HEADERS.PREFER] = constants.PREFER.REPRESENTATION, _headers8),
                    metricDimensions: {
                        lsatUpgrade: lsatUpgradeMetricValue()
                    }
                }).catch((function(err) {
                    var _headers9;
                    var restCorrID = Object(api.getErrorResponseCorrelationID)(err);
                    Object(lib.getLogger)().warn("authorize_order_" + lsatUpgradeType() + "_call_rest_api_error", {
                        restCorrID: restCorrID,
                        orderID: orderID,
                        err: Object(belter_src.stringifyError)(err)
                    });
                    isInvalidResourceIDError(err) && Object(lib.getLogger)().warn("authorize_order_" + lsatUpgradeType() + "_invalid_resource_id_error", {
                        restCorrID: restCorrID,
                        orderID: orderID,
                        err: Object(belter_src.stringifyError)(err)
                    });
                    if (isProcessorDeclineError(err)) throw err;
                    if (experiments.disableSmartAPI) throw err;
                    return Object(api.callSmartAPI)({
                        accessToken: buyerAccessToken,
                        method: "post",
                        eventName: "order_authorize",
                        url: src_config.SMART_API_URI.ORDER + "/" + orderID + "/authorize",
                        json: {
                            data: {
                                facilitatorAccessToken: facilitatorAccessToken
                            }
                        },
                        headers: (_headers9 = {}, _headers9[constants.HEADERS.CLIENT_CONTEXT] = orderID, 
                        _headers9),
                        metricDimensions: {
                            lsatUpgrade: lsatUpgradeMetricValue(),
                            smartApiType: "fallback"
                        }
                    }).then((function(res) {
                        var smartCorrID = Object(api.getResponseCorrelationID)(res);
                        Object(lib.getLogger)().info("authorize_order_" + lsatUpgradeType() + "_smart_fallback_success", {
                            smartCorrID: smartCorrID,
                            restCorrID: restCorrID,
                            orderID: orderID
                        });
                        return res.data;
                    })).catch((function(smartErr) {
                        var smartCorrID = Object(api.getErrorResponseCorrelationID)(err);
                        Object(lib.getLogger)().info("authorize_order_" + lsatUpgradeType() + "_smart_fallback_error", {
                            smartCorrID: smartCorrID,
                            restCorrID: restCorrID,
                            orderID: orderID,
                            err: Object(belter_src.stringifyError)(smartErr)
                        });
                        throw smartErr;
                    }));
                })).finally((function() {
                    Object(lib.getLogger)().flush();
                }));
            }
            Object(lib.getLogger)().info("lsat_upgrade_false");
            return Object(api.callSmartAPI)({
                accessToken: buyerAccessToken,
                method: "post",
                eventName: "order_authorize",
                url: src_config.SMART_API_URI.ORDER + "/" + orderID + "/authorize",
                json: {
                    data: {
                        facilitatorAccessToken: facilitatorAccessToken
                    }
                },
                headers: (_headers10 = {}, _headers10[constants.HEADERS.CLIENT_CONTEXT] = orderID, 
                _headers10),
                metricDimensions: {
                    lsatUpgrade: lsatUpgradeMetricValue(),
                    smartApiType: "default"
                }
            }).then((function(_ref7) {
                return _ref7.data;
            })).finally((function() {
                Object(lib.getLogger)().flush();
            }));
        }
        function patchOrder(orderID, data, _ref8) {
            var _headers13;
            var facilitatorAccessToken = _ref8.facilitatorAccessToken, buyerAccessToken = _ref8.buyerAccessToken, partnerAttributionID = _ref8.partnerAttributionID, _ref8$forceRestAPI = _ref8.forceRestAPI, forceRestAPI = void 0 !== _ref8$forceRestAPI && _ref8$forceRestAPI, experiments = _ref8.experiments;
            Object(lib.getLogger)().info("patch_order_" + lsatUpgradeType() + "_" + (getLsatUpgradeCalled() ? "called" : "not_called"), {
                orderID: orderID
            });
            Object(lib.getLogger)().info("patch_order_" + lsatUpgradeType() + "_" + (getLsatUpgradeError() ? "errored" : "did_not_error"), {
                orderID: orderID,
                err: Object(belter_src.stringifyError)(getLsatUpgradeError())
            });
            logPayeeInfoForClientSideHelpers(orderID, "patch");
            if (forceRestAPI && !getLsatUpgradeError()) {
                var _headers11;
                return Object(api.callRestAPI)({
                    accessToken: facilitatorAccessToken,
                    method: "PATCH",
                    eventName: "v2_checkout_orders_patch",
                    url: src_config.ORDERS_API_URL + "/" + orderID,
                    data: data,
                    headers: (_headers11 = {}, _headers11[constants.HEADERS.PARTNER_ATTRIBUTION_ID] = partnerAttributionID || "", 
                    _headers11[constants.HEADERS.PREFER] = constants.PREFER.REPRESENTATION, _headers11),
                    metricDimensions: {
                        lsatUpgrade: lsatUpgradeMetricValue()
                    }
                }).catch((function(err) {
                    var _headers12;
                    var restCorrID = Object(api.getErrorResponseCorrelationID)(err);
                    Object(lib.getLogger)().warn("patch_order_" + lsatUpgradeType() + "_call_rest_api_error", {
                        restCorrID: restCorrID,
                        orderID: orderID,
                        err: Object(belter_src.stringifyError)(err)
                    });
                    isInvalidResourceIDError(err) && Object(lib.getLogger)().warn("patch_order_" + lsatUpgradeType() + "_invalid_resource_id_error", {
                        restCorrID: restCorrID,
                        orderID: orderID,
                        err: Object(belter_src.stringifyError)(err)
                    });
                    if (experiments.disableSmartAPI) throw err;
                    var requestData;
                    requestData = Array.isArray(data) ? {
                        patch: data,
                        facilitatorAccessToken: facilitatorAccessToken
                    } : Object(esm_extends.default)({}, data, {
                        facilitatorAccessToken: facilitatorAccessToken
                    });
                    return Object(api.callSmartAPI)({
                        accessToken: buyerAccessToken,
                        method: "post",
                        eventName: "order_patch",
                        url: src_config.SMART_API_URI.ORDER + "/" + orderID + "/patch",
                        json: {
                            data: requestData
                        },
                        headers: (_headers12 = {}, _headers12[constants.HEADERS.CLIENT_CONTEXT] = orderID, 
                        _headers12),
                        metricDimensions: {
                            lsatUpgrade: lsatUpgradeMetricValue(),
                            smartApiType: "fallback"
                        }
                    }).then((function(res) {
                        var smartCorrID = Object(api.getResponseCorrelationID)(res);
                        Object(lib.getLogger)().info("patch_order_" + lsatUpgradeType() + "_smart_fallback_success", {
                            smartCorrID: smartCorrID,
                            restCorrID: restCorrID,
                            orderID: orderID
                        });
                        return res.data;
                    })).catch((function(smartErr) {
                        var smartCorrID = Object(api.getErrorResponseCorrelationID)(err);
                        Object(lib.getLogger)().info("patch_order_" + lsatUpgradeType() + "_smart_fallback_error", {
                            smartCorrID: smartCorrID,
                            restCorrID: restCorrID,
                            orderID: orderID,
                            err: Object(belter_src.stringifyError)(smartErr)
                        });
                        throw smartErr;
                    }));
                })).finally((function() {
                    Object(lib.getLogger)().flush();
                }));
            }
            Object(lib.getLogger)().info("lsat_upgrade_false");
            var requestData;
            requestData = Array.isArray(data) ? {
                patch: data,
                facilitatorAccessToken: facilitatorAccessToken
            } : Object(esm_extends.default)({}, data, {
                facilitatorAccessToken: facilitatorAccessToken
            });
            return Object(api.callSmartAPI)({
                accessToken: buyerAccessToken,
                method: "post",
                eventName: "order_patch",
                url: src_config.SMART_API_URI.ORDER + "/" + orderID + "/patch",
                json: {
                    data: requestData
                },
                headers: (_headers13 = {}, _headers13[constants.HEADERS.CLIENT_CONTEXT] = orderID, 
                _headers13),
                metricDimensions: {
                    lsatUpgrade: lsatUpgradeMetricValue(),
                    smartApiType: "default"
                }
            }).then((function(_ref9) {
                return _ref9.data;
            })).finally((function() {
                Object(lib.getLogger)().flush();
            }));
        }
        function patchShipping(_ref10) {
            var clientID = _ref10.clientID, orderID = _ref10.orderID, data = _ref10.data;
            return Object(api.callGraphQL)({
                name: "UpdateShipping",
                query: "\n            mutation UpdateShipping(\n                $clientID: String!\n                $patch: [JSON]!\n                $token: String!\n            ) {\n                updateShipping(\n                    clientID: $clientID,\n                    patch: $patch,\n                    token: $token,\n                )\n            }\n        ",
                variables: {
                    clientID: clientID,
                    patch: data,
                    token: orderID
                }
            });
        }
        function confirmOrderAPI(orderID, data, _ref11) {
            var _headers14;
            var facilitatorAccessToken = _ref11.facilitatorAccessToken, partnerAttributionID = _ref11.partnerAttributionID;
            return Object(api.callRestAPI)({
                accessToken: facilitatorAccessToken,
                method: "post",
                eventName: "order_confirm_payment_source",
                url: src_config.ORDERS_API_URL + "/" + orderID + "/confirm-payment-source",
                data: data,
                headers: (_headers14 = {}, _headers14[constants.HEADERS.PARTNER_ATTRIBUTION_ID] = partnerAttributionID || "", 
                _headers14[constants.HEADERS.PREFER] = constants.PREFER.REPRESENTATION, _headers14)
            });
        }
        function buildPaymentSource(_ref12) {
            var _ref13;
            var paymentMethodID = _ref12.paymentMethodID, enableThreeDomainSecure = _ref12.enableThreeDomainSecure;
            return (_ref13 = {})[_ref12.fundingSource] = Object(esm_extends.default)({
                vault_id: paymentMethodID
            }, enableThreeDomainSecure && {
                verification_method: {
                    method: "SCA_ALWAYS"
                }
            }), _ref13;
        }
        function validatePaymentMethod(_ref14) {
            var _headers15;
            var accessToken = _ref14.accessToken, orderID = _ref14.orderID, paymentMethodID = _ref14.paymentMethodID, enableThreeDomainSecure = _ref14.enableThreeDomainSecure, partnerAttributionID = _ref14.partnerAttributionID, clientMetadataID = _ref14.clientMetadataID, installmentPlan = _ref14.installmentPlan;
            Object(lib.getLogger)().info("rest_api_create_order_token");
            var headers = ((_headers15 = {})[constants.HEADERS.AUTHORIZATION] = "Bearer " + accessToken, 
            _headers15[constants.HEADERS.PARTNER_ATTRIBUTION_ID] = partnerAttributionID, _headers15[constants.HEADERS.CLIENT_METADATA_ID] = clientMetadataID, 
            _headers15[constants.HEADERS.APP_NAME] = constants.SMART_PAYMENT_BUTTONS, _headers15[constants.HEADERS.APP_VERSION] = "5.0.162", 
            _headers15);
            var paymentSource = {
                token: {
                    id: paymentMethodID,
                    type: "NONCE"
                }
            };
            enableThreeDomainSecure && (paymentSource.contingencies = [ "3D_SECURE" ]);
            installmentPlan && (paymentSource.token.attributes = {
                installments: {
                    term: installmentPlan.term,
                    interval_duration: installmentPlan.interval_duration
                }
            });
            var json = {
                payment_source: paymentSource
            };
            return Object(belter_src.request)({
                method: "post",
                url: src_config.ORDERS_API_URL + "/" + orderID + "/" + src_config.VALIDATE_PAYMENT_METHOD_API,
                headers: headers,
                json: json
            });
        }
        function billingTokenToOrderID(billingToken) {
            return Object(api.callSmartAPI)({
                authenticated: !1,
                method: "post",
                eventName: "payment_ectoken",
                url: src_config.SMART_API_URI.PAYMENT + "/" + billingToken + "/ectoken"
            }).then((function(_ref15) {
                return _ref15.data.token;
            }));
        }
        function subscriptionIdToCartId(subscriptionID) {
            return Object(api.callSmartAPI)({
                authenticated: !1,
                method: "post",
                eventName: "billagmt_subscriptions_cartid",
                url: src_config.SMART_API_URI.SUBSCRIPTION + "/" + subscriptionID + "/cartid"
            }).then((function(_ref16) {
                return _ref16.data.token;
            }));
        }
        function enableVault(_ref17) {
            var _headers16;
            var orderID = _ref17.orderID, clientAccessToken = _ref17.clientAccessToken;
            var clientConfig = {
                fundingSource: _ref17.fundingSource,
                integrationArtifact: _ref17.integrationArtifact,
                userExperienceFlow: _ref17.userExperienceFlow,
                productFlow: _ref17.productFlow,
                buttonSessionID: _ref17.buttonSessionID
            };
            return Object(api.callGraphQL)({
                name: "EnableVault",
                query: "\n            mutation EnableVault(\n                $orderID : String!,\n                $clientConfig: ClientConfigInput!\n            ) {\n                enableVault(\n                    token: $orderID,\n                    clientConfig: $clientConfig\n                )\n            }\n        ",
                variables: {
                    orderID: orderID,
                    clientConfig: clientConfig
                },
                headers: (_headers16 = {}, _headers16[constants.HEADERS.ACCESS_TOKEN] = clientAccessToken, 
                _headers16[constants.HEADERS.CLIENT_CONTEXT] = orderID, _headers16)
            });
        }
        function deleteVault(_ref18) {
            var _headers17;
            var paymentMethodID = _ref18.paymentMethodID, clientAccessToken = _ref18.clientAccessToken;
            return Object(api.callGraphQL)({
                name: "DeleteVault",
                query: "\n            mutation DeleteVault(\n                $paymentMethodID : String!\n            ) {\n                deleteVault(\n                    paymentMethodID: $paymentMethodID\n                )\n            }\n        ",
                variables: {
                    paymentMethodID: paymentMethodID
                },
                headers: (_headers17 = {}, _headers17[constants.HEADERS.ACCESS_TOKEN] = clientAccessToken, 
                _headers17)
            });
        }
        function updateClientConfig(_ref19) {
            var _headers18;
            var orderID = _ref19.orderID, fundingSource = _ref19.fundingSource, integrationArtifact = _ref19.integrationArtifact, userExperienceFlow = _ref19.userExperienceFlow, productFlow = _ref19.productFlow, buttonSessionID = _ref19.buttonSessionID, featureFlags = _ref19.featureFlags;
            featureFlags && featureFlags.isButtonClientConfigCallBlocking ? Object(lib.getLogger)().info("blocking_cco_call", {
                time: Object(lib.getClientsideTimestamp)(),
                buttonSessionID: buttonSessionID,
                fundingSource: fundingSource
            }) : Object(lib.getLogger)().info("non_blocking_cco_call", {
                time: Object(lib.getClientsideTimestamp)(),
                buttonSessionID: buttonSessionID,
                fundingSource: fundingSource
            });
            return Object(api.callGraphQL)({
                name: "UpdateClientConfig",
                query: "\n            mutation UpdateClientConfig(\n                $orderID : String!,\n                $fundingSource : ButtonFundingSourceType!,\n                $integrationArtifact : IntegrationArtifactType!,\n                $userExperienceFlow : UserExperienceFlowType!,\n                $productFlow : ProductFlowType!,\n                $buttonSessionID : String\n            ) {\n                updateClientConfig(\n                    token: $orderID,\n                    fundingSource: $fundingSource,\n                    integrationArtifact: $integrationArtifact,\n                    userExperienceFlow: $userExperienceFlow,\n                    productFlow: $productFlow,\n                    buttonSessionID: $buttonSessionID\n                )\n            }\n        ",
                variables: {
                    orderID: orderID,
                    fundingSource: fundingSource,
                    integrationArtifact: integrationArtifact,
                    userExperienceFlow: userExperienceFlow,
                    productFlow: productFlow,
                    buttonSessionID: buttonSessionID
                },
                headers: (_headers18 = {}, _headers18[constants.HEADERS.CLIENT_CONTEXT] = orderID, 
                _headers18)
            }).then(belter_src.noop);
        }
        function approveOrder(_ref20) {
            var _headers19;
            var orderID = _ref20.orderID, planID = _ref20.planID, buyerAccessToken = _ref20.buyerAccessToken;
            return Object(api.callGraphQL)({
                name: "ApproveOrder",
                query: "\n            mutation ApproveOrder(\n                $orderID : String!\n                $planID : String!\n            ) {\n                approvePayment(\n                    token: $orderID\n                    selectedPlanId: $planID\n                ) {\n                    buyer {\n                        userId\n                        auth {\n                            accessToken\n                        }\n                    }\n                }\n            }\n        ",
                variables: {
                    orderID: orderID,
                    planID: planID
                },
                headers: (_headers19 = {}, _headers19[constants.HEADERS.ACCESS_TOKEN] = buyerAccessToken, 
                _headers19[constants.HEADERS.CLIENT_CONTEXT] = orderID, _headers19)
            }).then((function(_ref21) {
                var _approvePayment$buyer;
                var approvePayment = _ref21.approvePayment;
                Object(lib.setBuyerAccessToken)(null == approvePayment || null == (_approvePayment$buyer = approvePayment.buyer) || null == (_approvePayment$buyer = _approvePayment$buyer.auth) ? void 0 : _approvePayment$buyer.accessToken);
                return {
                    payerID: approvePayment.buyer.userId
                };
            }));
        }
        function oneClickApproveOrder(_ref22) {
            var _headers20;
            var orderID = _ref22.orderID, instrumentType = _ref22.instrumentType, instrumentID = _ref22.instrumentID, buyerAccessToken = _ref22.buyerAccessToken, clientMetadataID = _ref22.clientMetadataID;
            return Object(api.callGraphQL)({
                name: "OneClickApproveOrder",
                query: "\n            mutation OneClickApproveOrder(\n                $orderID : String!\n                $instrumentType : String!\n                $instrumentID : String!\n            ) {\n                oneClickPayment(\n                    token: $orderID\n                    selectedInstrumentType : $instrumentType\n                    selectedInstrumentId : $instrumentID\n                ) {\n                    userId\n                    auth {\n                        accessToken\n                    }\n                }\n            }\n        ",
                variables: {
                    orderID: orderID,
                    instrumentType: instrumentType,
                    instrumentID: instrumentID
                },
                headers: (_headers20 = {}, _headers20[constants.HEADERS.ACCESS_TOKEN] = buyerAccessToken, 
                _headers20[constants.HEADERS.CLIENT_CONTEXT] = orderID, _headers20[constants.HEADERS.CLIENT_METADATA_ID] = clientMetadataID || orderID, 
                _headers20)
            }).then((function(_ref23) {
                var _oneClickPayment$auth;
                var oneClickPayment = _ref23.oneClickPayment;
                null != oneClickPayment && null != (_oneClickPayment$auth = oneClickPayment.auth) && _oneClickPayment$auth.accessToken && Object(lib.setBuyerAccessToken)(oneClickPayment.auth.accessToken);
                return {
                    payerID: oneClickPayment.userId
                };
            }));
        }
        var getSupplementalOrderInfo = Object(belter_src.memoize)((function(orderID) {
            var _headers21;
            return Object(api.callGraphQL)({
                name: "GetCheckoutDetails",
                query: "\n        query GetCheckoutDetails($orderID: String!) {\n            checkoutSession(token: $orderID) {\n                cart {\n                    billingType\n                    intent\n                    paymentId\n                    billingToken\n                    amounts {\n                        total {\n                            currencyValue\n                            currencyCode\n                            currencyFormatSymbolISOCurrency\n                        }\n                    }\n                    supplementary {\n                        initiationIntent\n                    }\n                    category\n                }\n                flags {\n                    isChangeShippingAddressAllowed\n                }\n                payees {\n                    merchantId\n                    email {\n                        stringValue\n                    }\n                }\n            }\n        }\n        ",
                variables: {
                    orderID: orderID
                },
                headers: (_headers21 = {}, _headers21[constants.HEADERS.CLIENT_CONTEXT] = orderID, 
                _headers21)
            });
        }));
        var order_getShippingOrderInfo = function(orderID) {
            var _headers22;
            return Object(api.callGraphQL)({
                name: "GetCheckoutDetails",
                query: "\n            query GetCheckoutDetails($orderID: String!) {\n                checkoutSession(token: $orderID) {\n                    cart {\n                        billingType\n                        intent\n                        paymentId\n                        billingToken\n                        amounts {\n                            total {\n                                currencyValue\n                                currencyCode\n                                currencyFormatSymbolISOCurrency\n                            }\n                        }\n                        supplementary {\n                            initiationIntent\n                        }\n                        category\n                        shippingAddress {\n                            firstName\n                            lastName\n                            line1\n                            line2\n                            city\n                            state\n                            postalCode\n                            country\n                        }\n                        shippingMethods {\n                            id\n                            amount {\n                                currencyCode\n                                currencyValue\n                            }\n                            label\n                            selected\n                            type\n                        }\n                    }\n                    flags {\n                        isChangeShippingAddressAllowed\n                    }\n                    payees {\n                        merchantId\n                        email {\n                            stringValue\n                        }\n                    }\n                }\n            }\n        ",
                variables: {
                    orderID: orderID
                },
                headers: (_headers22 = {}, _headers22[constants.HEADERS.CLIENT_CONTEXT] = orderID, 
                _headers22)
            });
        };
        var order_getDetailedOrderInfo = function(orderID, country) {
            var _headers23;
            return Object(api.callGraphQL)({
                name: "GetCheckoutDetails",
                query: "\n            query GetCheckoutDetails($orderID: String!, $country: CountryCodes!) {\n                checkoutSession(token: $orderID) {\n                    merchant{\n                        name\n                    }\n                    flags{\n                        isShippingAddressRequired,\n                        isDigitalGoodsIntegration,\n                        isChangeShippingAddressAllowed\n                    }\n                    allowedCardIssuers(country: $country)\n                    cart {\n                        amounts {\n                            shippingAndHandling {\n                                currencyValue\n                                currencySymbol\n                                currencyFormat\n                            }\n                            tax {\n                                currencyValue\n                                currencySymbol\n                                currencyFormat\n                            }\n                            subtotal {\n                                currencyValue\n                                currencySymbol\n                                currencyFormat\n                            }\n                            total {\n                                currencyValue\n                                currencyCode\n                                currencyFormatSymbolISOCurrency\n                            }\n                        }\n                        shippingAddress {\n                            firstName\n                            lastName\n                            line1\n                            line2\n                            city\n                            state\n                            postalCode\n                            country\n                        }\n                        shippingMethods {\n                            id\n                            amount {\n                                currencyCode\n                                currencyValue\n                            }\n                            label\n                            selected\n                            type\n                        }\n                    }\n                }\n            }\n        ",
                variables: {
                    orderID: orderID,
                    country: country
                },
                headers: (_headers23 = {}, _headers23[constants.HEADERS.CLIENT_CONTEXT] = orderID, 
                _headers23)
            });
        };
        function updateButtonClientConfig(_ref24) {
            var _ref24$inline = _ref24.inline;
            return updateClientConfig({
                orderID: _ref24.orderID,
                fundingSource: _ref24.fundingSource,
                integrationArtifact: constants.INTEGRATION_ARTIFACT.PAYPAL_JS_SDK,
                userExperienceFlow: _ref24.userExperienceFlow || (void 0 !== _ref24$inline && _ref24$inline ? constants.USER_EXPERIENCE_FLOW.INLINE : constants.USER_EXPERIENCE_FLOW.INCONTEXT),
                productFlow: constants.PRODUCT_FLOW.SMART_PAYMENT_BUTTONS,
                buttonSessionID: _ref24.buttonSessionID,
                featureFlags: _ref24.featureFlags
            });
        }
        function approveCardPayment(_ref25) {
            var card = _ref25.card, orderID = _ref25.orderID, clientID = _ref25.clientID, branded = _ref25.branded;
            return Object(api.callGraphQL)({
                name: "ProcessPayment",
                query: '\n            mutation ProcessPayment(\n                $orderID: String!\n                $clientID: String!\n                $card: CardInput!\n                $branded: Boolean!\n            ) {\n                processPayment(\n                    clientID: $clientID\n                    paymentMethod: { type: CARD, card: $card }\n                    branded: $branded\n                    orderID: $orderID\n                    buttonSessionID: "f7r7367r4"\n                )\n            }\n        ',
                variables: {
                    orderID: orderID,
                    clientID: clientID,
                    card: card,
                    branded: branded
                },
                returnErrorObject: !0
            }).then((function(gqlResult) {
                if (!gqlResult) throw new Error("Error on GraphQL ProcessPayment mutation");
                return gqlResult;
            }));
        }
        function createPayment(payment, _ref) {
            var _headers;
            var facilitatorAccessToken = _ref.facilitatorAccessToken, partnerAttributionID = _ref.partnerAttributionID;
            Object(lib.getLogger)().info("rest_api_create_payment_id");
            return Object(api.callRestAPI)({
                accessToken: facilitatorAccessToken,
                method: "post",
                eventName: "v1_payments_payment_create",
                url: "" + src_config.PAYMENTS_API_URL,
                data: payment,
                headers: (_headers = {}, _headers[constants.HEADERS.PARTNER_ATTRIBUTION_ID] = partnerAttributionID || "", 
                _headers)
            }).then((function(body) {
                var _getLogger$track;
                var paymentID = body && body.id;
                if (!paymentID) throw new Error("Payment Api response error:\n\n" + JSON.stringify(body, null, 4));
                Object(lib.getLogger)().track(((_getLogger$track = {})[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.CREATE_PAYMENT, 
                _getLogger$track[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = constants.FPTI_CONTEXT_TYPE.PAYMENT_ID, 
                _getLogger$track[sdk_constants_src.FPTI_KEY.TOKEN] = paymentID, _getLogger$track[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = paymentID, 
                _getLogger$track));
                return body;
            }));
        }
        function createPaymentID(payment, _ref2) {
            return createPayment(payment, {
                facilitatorAccessToken: _ref2.facilitatorAccessToken,
                partnerAttributionID: _ref2.partnerAttributionID
            }).then((function(res) {
                return res.id;
            }));
        }
        function createPaymentToken(payment, _ref3) {
            return createPayment(payment, {
                facilitatorAccessToken: _ref3.facilitatorAccessToken,
                partnerAttributionID: _ref3.partnerAttributionID
            }).then((function(res) {
                if (res.links && res.links.length) for (var i = 0; i < res.links.length; i++) if ("REDIRECT" === res.links[i].method && "approval_url" === res.links[i].rel) {
                    var match = res.links[i].href.match(/token=((EC-)?[A-Z0-9]{17})/);
                    if (match) return match[1];
                }
                throw new Error("Could not find payment token");
            }));
        }
        function getPayment(paymentID, _ref4) {
            var _headers2;
            var facilitatorAccessToken = _ref4.facilitatorAccessToken, partnerAttributionID = _ref4.partnerAttributionID;
            return Object(api.callRestAPI)({
                accessToken: facilitatorAccessToken,
                eventName: "v1_payments_payment_get",
                url: src_config.PAYMENTS_API_URL + "/" + paymentID,
                headers: (_headers2 = {}, _headers2[constants.HEADERS.PARTNER_ATTRIBUTION_ID] = partnerAttributionID || "", 
                _headers2)
            });
        }
        function executePayment(paymentID, payerID, _ref5) {
            var _headers3;
            var facilitatorAccessToken = _ref5.facilitatorAccessToken, partnerAttributionID = _ref5.partnerAttributionID;
            return Object(api.callRestAPI)({
                accessToken: facilitatorAccessToken,
                method: "post",
                eventName: "v1_payments_payment_execute",
                url: src_config.PAYMENTS_API_URL + "/" + paymentID + "/execute",
                headers: (_headers3 = {}, _headers3[constants.HEADERS.PARTNER_ATTRIBUTION_ID] = partnerAttributionID || "", 
                _headers3),
                data: {
                    payer_id: payerID
                }
            });
        }
        function patchPayment(paymentID, data, _ref6) {
            var _headers4;
            var facilitatorAccessToken = _ref6.facilitatorAccessToken, partnerAttributionID = _ref6.partnerAttributionID;
            var patchData = Array.isArray(data) ? {
                patch: data
            } : data;
            return Object(api.callRestAPI)({
                accessToken: facilitatorAccessToken,
                method: "patch",
                eventName: "v1_payments_payment_patch",
                url: src_config.PAYMENTS_API_URL + "/" + paymentID,
                data: patchData,
                headers: (_headers4 = {}, _headers4[constants.HEADERS.PARTNER_ATTRIBUTION_ID] = partnerAttributionID || "", 
                _headers4)
            });
        }
        function approveApplePayPayment(orderID, clientID, applePayPayment) {
            var token = applePayPayment.token, billingContact = applePayPayment.billingContact, shippingContact = applePayPayment.shippingContact;
            return Object(api.callGraphQL)({
                name: "ApproveApplePayPayment",
                query: "\n            mutation ApproveApplePayPayment(\n                $token: ApplePayPaymentToken!\n                $orderID: String!\n                $clientID : String!\n                $billingContact: ApplePayPaymentContact!\n                $shippingContact: ApplePayPaymentContact\n                $productFlow: String\n            ) {\n                approveApplePayPayment(\n                    token: $token\n                    orderID: $orderID\n                    clientID: $clientID\n                    billingContact: $billingContact\n                    shippingContact: $shippingContact\n                    productFlow: $productFlow\n                )\n            }\n        ",
                variables: {
                    token: token,
                    orderID: orderID,
                    clientID: clientID,
                    billingContact: billingContact,
                    shippingContact: shippingContact,
                    productFlow: constants.PRODUCT_FLOW.SMART_PAYMENT_BUTTONS
                }
            }).then((function(gqlResult) {
                if (!gqlResult || !gqlResult.approveApplePayPayment) throw new Error("GraphQL GetApplePayPayment returned no applePayment object");
                return gqlResult.approveApplePayPayment;
            }));
        }
        function createRequest(accessToken, subscriptionPayload, partnerAttributionID, eventName) {
            var headers = {
                Authorization: "Bearer " + accessToken,
                "PayPal-Partner-Attribution-Id": partnerAttributionID || ""
            };
            return Object(belter_src.request)({
                method: "post",
                url: src_config.CREATE_SUBSCRIPTIONS_API_URL,
                headers: headers,
                json: subscriptionPayload
            }).then((function(_ref) {
                var body = _ref.body;
                if (!body || !body.id) {
                    Object(lib.getLogger)().warn("rest_api_" + eventName + "_error");
                    throw new Error("Create Subscription Api response error:\n\n" + JSON.stringify(body, null, 4));
                }
                return body.id;
            }));
        }
        function createSubscription(accessToken, subscriptionPayload, _ref2) {
            var partnerAttributionID = _ref2.partnerAttributionID, merchantID = _ref2.merchantID, clientID = _ref2.clientID;
            Object(lib.getLogger)().info("rest_api_create_subscription_id");
            if (!subscriptionPayload) throw new Error("Expected subscription payload to be passed");
            if (merchantID && merchantID[0]) {
                Object(lib.getLogger)().info("rest_api_subscriptions_recreate_access_token");
                return createAccessToken(clientID, {
                    targetSubject: merchantID[0]
                }).then((function(thirdPartyAccessToken) {
                    return createRequest(thirdPartyAccessToken, subscriptionPayload, partnerAttributionID, "v1_billing_subscriptions_recreate");
                }));
            }
            if (!accessToken) throw new Error("Access token not passed");
            return createRequest(accessToken, subscriptionPayload, partnerAttributionID, "v1_billing_subscriptions_create");
        }
        function reviseRequest(accessToken, subscriptionID, subscriptionPayload, partnerAttributionID, eventName) {
            var headers = {
                Authorization: "Bearer " + accessToken,
                "PayPal-Partner-Attribution-Id": partnerAttributionID || ""
            };
            return Object(belter_src.request)({
                method: "post",
                url: src_config.CREATE_SUBSCRIPTIONS_API_URL + "/" + subscriptionID + "/revise",
                headers: headers,
                json: subscriptionPayload
            }).then((function(_ref3) {
                var body = _ref3.body, status = _ref3.status;
                if (200 !== status) {
                    Object(lib.getLogger)().warn("rest_api_" + eventName + "_error");
                    throw new Error("Revise Subscription Api HTTP-" + status + " response: error:\n\n" + JSON.stringify(body, null, 4));
                }
                return subscriptionID;
            }));
        }
        function reviseSubscription(accessToken, subscriptionID, subscriptionPayload, _ref4) {
            var partnerAttributionID = _ref4.partnerAttributionID, merchantID = _ref4.merchantID, clientID = _ref4.clientID;
            Object(lib.getLogger)().info("rest_api_create_subscription_id");
            if (!subscriptionID) throw new Error("Expected subscription id to be passed as first argument to revise subscription api");
            if (!subscriptionPayload) throw new Error("Expected subscription payload to be passed");
            if (merchantID && merchantID[0]) {
                Object(lib.getLogger)().info("rest_api_subscriptions_recreate_access_token");
                return createAccessToken(clientID, {
                    targetSubject: merchantID[0]
                }).then((function(thirdPartyAccessToken) {
                    return reviseRequest(thirdPartyAccessToken, subscriptionID, subscriptionPayload, partnerAttributionID, "v1_billing_subscriptions_revise_recreate");
                }));
            }
            if (!accessToken) throw new Error("Access token not passed");
            return reviseRequest(accessToken, subscriptionID, subscriptionPayload, partnerAttributionID, "v1_billing_subscriptions_revise_create");
        }
        function activateSubscription(subscriptionID, _ref5) {
            var buyerAccessToken = _ref5.buyerAccessToken;
            return Object(api.callSmartAPI)({
                accessToken: buyerAccessToken,
                method: "post",
                eventName: "billagmt_subscriptions_activate",
                url: src_config.SMART_API_URI.SUBSCRIPTION + "/" + subscriptionID + "/activate"
            }).then((function(_ref6) {
                return _ref6.data;
            }));
        }
        function getSubscription(subscriptionID, _ref7) {
            var buyerAccessToken = _ref7.buyerAccessToken;
            return Object(api.callSmartAPI)({
                accessToken: buyerAccessToken,
                eventName: "billagmt_subscriptions_get",
                url: src_config.SMART_API_URI.SUBSCRIPTION + "/" + subscriptionID
            }).then((function(_ref8) {
                return _ref8.data;
            }));
        }
        var util = __webpack_require__("./src/lib/util.js");
        function messageSocket(_ref) {
            var sessionUID = _ref.sessionUID, driver = _ref.driver, sourceApp = _ref.sourceApp, sourceAppVersion = _ref.sourceAppVersion, targetApp = _ref.targetApp, _ref$retry = _ref.retry, retry = void 0 === _ref$retry || _ref$retry;
            var receivedMessages = {};
            var responseListeners = {};
            var activeRequests = [];
            var requestListeners = {};
            var errorListeners = [];
            var triggerError = function(err) {
                for (var _i2 = 0, _errorListeners2 = errorListeners; _i2 < _errorListeners2.length; _i2++) (0, 
                _errorListeners2[_i2])(err);
            };
            var sendMessage = function(socket, data) {
                var messageUID = Object(belter_src.uniqueID)();
                receivedMessages[messageUID] = !0;
                var message = Object(esm_extends.default)({
                    session_uid: sessionUID,
                    message_uid: messageUID,
                    source_app: sourceApp,
                    source_app_version: sourceAppVersion,
                    target_app: targetApp
                }, data);
                socket.send(JSON.stringify(message));
            };
            var sendResponse = function(socket, _ref2) {
                var messageName = _ref2.messageName, responseStatus = _ref2.responseStatus, responseData = _ref2.responseData, requestUID = _ref2.requestUID;
                if (socket.isOpen()) return sendMessage(socket, {
                    request_uid: requestUID,
                    message_name: messageName,
                    message_status: responseStatus,
                    message_type: "response",
                    message_data: responseData
                });
            };
            var closed = !1;
            var retryDelay;
            var socketPromise;
            var retryPromise;
            var init = function init() {
                (socketPromise = src.ZalgoPromise.try((function() {
                    if (retryDelay) return retryPromise = src.ZalgoPromise.delay(retryDelay);
                })).then((function() {
                    retryPromise = null;
                    var instance = driver();
                    var connectionPromise = new src.ZalgoPromise((function(resolve, reject) {
                        instance.onOpen((function() {
                            closed = !1;
                            retryDelay = 0;
                            resolve(instance);
                        }));
                        instance.onClose((function(err) {
                            closed = !0;
                            reject(err || new Error("socket closed"));
                            if (retry) {
                                retry && (retryDelay = retryDelay ? 2 * retryDelay : 1);
                                init();
                            }
                        }));
                        instance.onError((function(err) {
                            reject(err);
                            triggerError(err);
                        }));
                    }));
                    instance.onMessage((function(rawMessage) {
                        connectionPromise.then((function(socket) {
                            return function(socket, rawData) {
                                var parsedData;
                                try {
                                    parsedData = JSON.parse(rawData);
                                } catch (err) {
                                    throw new Error("Could not parse socket message: " + rawData);
                                }
                                if (!parsedData) throw new Error("No data passed from socket message");
                                var messageSessionUID = parsedData.session_uid, requestUID = parsedData.request_uid, messageUID = parsedData.message_uid, messageName = parsedData.message_name, messageType = parsedData.message_type, messageData = parsedData.message_data, responseStatus = parsedData.message_status;
                                requestUID = requestUID || parsedData.request_id;
                                if (!messageUID || !receivedMessages[messageUID]) {
                                    if (!(messageUID && requestUID && messageName && messageType && parsedData.target_app)) throw new Error("Incomplete message: " + rawData);
                                    receivedMessages[messageUID] = !0;
                                    if ("request" === messageType) return function(socket, _ref3) {
                                        var messageSessionUID = _ref3.messageSessionUID, requestUID = _ref3.requestUID, messageName = _ref3.messageName, messageData = _ref3.messageData;
                                        var activeRequest = new src.ZalgoPromise;
                                        activeRequests.push(activeRequest);
                                        return src.ZalgoPromise.try((function() {
                                            var requestListener = requestListeners[messageName];
                                            if (!requestListener) throw new Error("No listener found for name: " + messageName);
                                            var handler = requestListener.handler;
                                            if (requestListener.requireSessionUID && messageSessionUID !== sessionUID) throw new Error("Incorrect sessionUID: " + (messageSessionUID || "undefined"));
                                            return handler({
                                                data: messageData
                                            });
                                        })).then((function(res) {
                                            sendResponse(socket, {
                                                responseStatus: "success",
                                                responseData: res,
                                                messageName: messageName,
                                                requestUID: requestUID
                                            });
                                        }), (function(err) {
                                            sendResponse(socket, {
                                                responseStatus: "error",
                                                responseData: {
                                                    message: err && err.message ? err.message : "Unknown error"
                                                },
                                                messageName: messageName,
                                                messageSessionUID: messageSessionUID,
                                                requestUID: requestUID
                                            });
                                        })).finally((function() {
                                            activeRequest.resolve();
                                            activeRequests.splice(activeRequests.indexOf(activeRequest), 1);
                                        }));
                                    }(socket, {
                                        messageSessionUID: messageSessionUID,
                                        requestUID: requestUID,
                                        messageName: messageName,
                                        messageData: messageData
                                    });
                                    if ("response" === messageType) return function(_ref4) {
                                        var requestUID = _ref4.requestUID, messageSessionUID = _ref4.messageSessionUID, responseStatus = _ref4.responseStatus, messageData = _ref4.messageData;
                                        var _ref5 = responseListeners[requestUID] || {}, listenerPromise = _ref5.listenerPromise, requireSessionUID = _ref5.requireSessionUID;
                                        if (!listenerPromise) return triggerError(new Error("Could not find response listener for " + _ref4.messageName + " with id: " + requestUID));
                                        if (requireSessionUID && messageSessionUID !== sessionUID) return triggerError(new Error("Incorrect sessionUID: " + (messageSessionUID || "undefined")));
                                        delete responseListeners[requestUID];
                                        "success" === responseStatus ? listenerPromise.resolve({
                                            data: messageData
                                        }) : listenerPromise.reject("error" === responseStatus ? new Error(messageData.message) : new Error("Can not handle response status: " + (status || "undefined")));
                                    }({
                                        messageName: messageName,
                                        requestUID: requestUID,
                                        messageSessionUID: messageSessionUID,
                                        responseStatus: responseStatus,
                                        messageData: messageData
                                    });
                                    throw new Error("Unhandleable message type: " + messageType);
                                }
                            }(socket, rawMessage);
                        }));
                    }));
                    return connectionPromise;
                }))).catch(belter_src.noop);
            };
            init();
            return {
                on: function(name, handler, _temp) {
                    var _ref6$requireSessionU = (void 0 === _temp ? {} : _temp).requireSessionUID, requireSessionUID = void 0 === _ref6$requireSessionU || _ref6$requireSessionU;
                    if (requestListeners[name]) throw new Error("Listener already registered for name: " + name);
                    requestListeners[name] = {
                        handler: handler,
                        requireSessionUID: requireSessionUID
                    };
                    return {
                        cancel: function() {
                            delete requestListeners[name];
                        }
                    };
                },
                send: function(messageName, messageData, _temp2) {
                    var _ref7 = void 0 === _temp2 ? {} : _temp2, _ref7$requireSessionU = _ref7.requireSessionUID, requireSessionUID = void 0 === _ref7$requireSessionU || _ref7$requireSessionU, _ref7$timeout = _ref7.timeout, timeout = void 0 === _ref7$timeout ? 0 : _ref7$timeout;
                    return socketPromise.then((function(socket) {
                        var requestUID = Object(belter_src.uniqueID)();
                        var listenerPromise = new src.ZalgoPromise;
                        responseListeners[requestUID] = {
                            listenerPromise: listenerPromise,
                            requireSessionUID: requireSessionUID
                        };
                        sendMessage(socket, {
                            request_uid: requestUID,
                            message_name: messageName,
                            message_type: "request",
                            message_data: messageData
                        });
                        timeout && setTimeout((function() {
                            listenerPromise.reject(new Error("Timeoued out waiting for " + messageName + " response after " + timeout + "ms"));
                        }), timeout);
                        return listenerPromise;
                    }));
                },
                onError: function(handler) {
                    errorListeners.push(handler);
                },
                reconnect: function() {
                    return src.ZalgoPromise.try((function() {
                        if (!closed) return socketPromise;
                        if (retryPromise) {
                            retryPromise.resolve();
                            return socketPromise;
                        }
                        retryDelay = 0;
                        return init();
                    })).then(belter_src.noop);
                },
                close: function() {
                    retry = !1;
                    requestListeners = {};
                    errorListeners = [];
                    for (var _i4 = 0, _Object$keys2 = Object.keys(responseListeners); _i4 < _Object$keys2.length; _i4++) responseListeners[_Object$keys2[_i4]].listenerPromise.asyncReject(new Error("Socket closed"));
                    src.ZalgoPromise.all(activeRequests).then((function() {
                        return socketPromise.then((function(socket) {
                            return socket.close();
                        }), belter_src.noop);
                    }));
                }
            };
        }
        function webSocket(_ref8) {
            var url = _ref8.url;
            return messageSocket({
                sessionUID: _ref8.sessionUID,
                driver: function() {
                    var socket = new WebSocket(url);
                    return {
                        send: function(data) {
                            socket.send(data);
                        },
                        close: function() {
                            socket.close();
                        },
                        onMessage: function(handler) {
                            socket.onmessage = function(event) {
                                var data = event.data;
                                if ("string" != typeof data || !data) throw new TypeError("Expected string data from web socket");
                                handler(data);
                            };
                        },
                        onError: function(handler) {
                            socket.onerror = function() {
                                handler(new Error("The socket encountered an error"));
                            };
                        },
                        onOpen: function(handler) {
                            socket.onopen = function() {
                                return handler();
                            };
                        },
                        onClose: function(handler) {
                            socket.onclose = function() {
                                return handler(new Error("Websocket connection closed"));
                            };
                        },
                        isOpen: function() {
                            return socket.readyState === WebSocket.OPEN;
                        }
                    };
                },
                sourceApp: _ref8.sourceApp,
                sourceAppVersion: _ref8.sourceAppVersion,
                targetApp: _ref8.targetApp
            });
        }
        var loadFirebaseSDK = Object(belter_src.memoize)((function(config) {
            return src.ZalgoPromise.try((function() {
                if (!window.firebase || !window.firebase.auth || !window.firebase.database) return Object(util.loadScript)(src_config.FIREBASE_SCRIPTS.APP).then((function() {
                    return src.ZalgoPromise.all([ Object(util.loadScript)(src_config.FIREBASE_SCRIPTS.AUTH), Object(util.loadScript)(src_config.FIREBASE_SCRIPTS.DATABASE) ]);
                }));
            })).then((function() {
                var firebase = window.firebase;
                if (!firebase) throw new Error("Firebase failed to load");
                firebase.initializeApp(config);
                return firebase;
            }));
        }));
        function firebaseSocket(_ref9) {
            var sessionUID = _ref9.sessionUID, config = _ref9.config;
            return messageSocket({
                sessionUID: sessionUID,
                driver: function() {
                    var open = !1;
                    var onMessageHandlers = [];
                    var onErrorHandlers = [];
                    var onCloseHandlers = [];
                    var onOpenHandlers = [];
                    var error = function(err) {
                        for (var _i6 = 0; _i6 < onErrorHandlers.length; _i6++) (0, onErrorHandlers[_i6])(err);
                    };
                    var databasePromise = src.ZalgoPromise.hash({
                        firebase: loadFirebaseSDK(config),
                        sessionToken: getFirebaseSessionToken(sessionUID)
                    }).then((function(_ref10) {
                        var firebase = _ref10.firebase, sessionToken = _ref10.sessionToken;
                        var valueCallback = function(res) {
                            var messages = res.val() || {};
                            for (var _i8 = 0, _Object$keys4 = Object.keys(messages); _i8 < _Object$keys4.length; _i8++) {
                                var message = messages[_Object$keys4[_i8]];
                                for (var _i10 = 0; _i10 < onMessageHandlers.length; _i10++) (0, onMessageHandlers[_i10])(message);
                            }
                        };
                        return firebase.auth().signInWithCustomToken(sessionToken).then((function() {
                            var _getLogger$info$track;
                            var database = firebase.database();
                            firebase.database.INTERNAL.forceWebSockets();
                            open = !0;
                            Object(lib.getLogger)().info("firebase_connection_opened").track((_getLogger$info$track = {}, 
                            _getLogger$info$track[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                            _getLogger$info$track[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.FIREBASE_CONNECTION_OPENED, 
                            _getLogger$info$track)).flush();
                            for (var _i12 = 0; _i12 < onOpenHandlers.length; _i12++) (0, onOpenHandlers[_i12])();
                            database.ref("users/" + sessionUID + "/messages").on("value", valueCallback, (function(err) {
                                error(err);
                            }));
                            database.goOnline();
                            return database;
                        }));
                    }));
                    databasePromise.catch((function(err) {
                        var _getLogger$warn$track;
                        Object(lib.getLogger)().warn("firebase_connection_errored", {
                            err: Object(belter_src.stringifyError)(err)
                        }).track((_getLogger$warn$track = {}, _getLogger$warn$track[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                        _getLogger$warn$track[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.FIREBASE_CONNECTION_ERRORED, 
                        _getLogger$warn$track[constants.FPTI_CUSTOM_KEY.ERR_DESC] = Object(belter_src.stringifyError)(err), 
                        _getLogger$warn$track)).flush();
                    }));
                    return {
                        send: function(data) {
                            databasePromise.then((function(database) {
                                return database.ref("users/" + sessionUID + "/messages/" + Object(belter_src.uniqueID)()).set(data);
                            })).catch(error);
                        },
                        close: function() {
                            databasePromise.then((function(database) {
                                database.goOffline();
                            }));
                        },
                        onMessage: function(handler) {
                            onMessageHandlers.push(handler);
                        },
                        onError: function(handler) {
                            onErrorHandlers.push(handler);
                        },
                        onOpen: function(handler) {
                            open ? handler() : onOpenHandlers.push(handler);
                        },
                        onClose: function(handler) {
                            onCloseHandlers.push(handler);
                        },
                        isOpen: function() {
                            return open;
                        }
                    };
                },
                sourceApp: _ref9.sourceApp,
                sourceAppVersion: _ref9.sourceAppVersion,
                targetApp: _ref9.targetApp
            });
        }
        var _FRAUDNET_URL;
        var FRAUDNET_URL = ((_FRAUDNET_URL = {})[sdk_constants_src.ENV.LOCAL] = "https://www.msmaster.qa.paypal.com/en_US/m/fb-raw.js", 
        _FRAUDNET_URL[sdk_constants_src.ENV.STAGE] = "https://stage2mb044.qa.paypal.com/fraudnetjsnodeweb/automate/develop/stage_raw.js", 
        _FRAUDNET_URL[sdk_constants_src.ENV.SANDBOX] = "https://c.paypal.com/da/r/fb.js", 
        _FRAUDNET_URL[sdk_constants_src.ENV.PRODUCTION] = "https://c.paypal.com/da/r/fb.js", 
        _FRAUDNET_URL[sdk_constants_src.ENV.TEST] = "https://c.paypal.com/da/r/fb.js", _FRAUDNET_URL);
        var FRAUDNET_FNCLS = "fnparams-dede7cc5-15fd-4c75-a9f4-36c430ee3a99";
        var FRAUDNET_APP_NAME = "SMART_PAYMENT_BUTTONS";
        var loadFraudnet = Object(belter_src.memoize)((function(_ref) {
            var env = _ref.env, clientMetadataID = _ref.clientMetadataID, cspNonce = _ref.cspNonce, _ref$timeout = _ref.timeout, timeout = void 0 === _ref$timeout ? 1e3 : _ref$timeout, _ref$queryStringParam = _ref.queryStringParams, queryStringParams = void 0 === _ref$queryStringParam ? {} : _ref$queryStringParam;
            return new src.ZalgoPromise((function(resolve) {
                var config = {
                    f: clientMetadataID,
                    s: FRAUDNET_APP_NAME,
                    u: window.xprops.buttonLocation,
                    cb1: "fnCallback"
                };
                env === sdk_constants_src.ENV.SANDBOX && (config.sandbox = !0);
                var configScript = document.createElement("script");
                configScript.setAttribute("nonce", cspNonce || "");
                configScript.setAttribute("type", "application/json");
                configScript.setAttribute("id", "fconfig");
                configScript.setAttribute("fncls", FRAUDNET_FNCLS);
                configScript.textContent = JSON.stringify(config);
                var fraudnetScript = document.createElement("script");
                var queryString = Object.keys(queryStringParams).map((function(key) {
                    return key + "=" + encodeURIComponent(String(queryStringParams[key]));
                })).join("&");
                var fraudnetUrl = queryString.length ? FRAUDNET_URL[env] + "?" + queryString : FRAUDNET_URL[env];
                fraudnetScript.setAttribute("nonce", cspNonce || "");
                fraudnetScript.setAttribute("src", fraudnetUrl);
                fraudnetScript.addEventListener("error", (function() {
                    return resolve();
                }));
                window.fnCallback = resolve;
                setTimeout(resolve, timeout);
                var body = Object(lib.getBody)();
                body.appendChild(configScript);
                body.appendChild(fraudnetScript);
            }));
        }));
        var getSmartWallet = Object(belter_src.memoize)((function(_ref) {
            var clientID = _ref.clientID, merchantID = _ref.merchantID, currency = _ref.currency, _ref$amount = _ref.amount, amount = void 0 === _ref$amount ? "0" : _ref$amount, clientMetadataID = _ref.clientMetadataID, userIDToken = _ref.userIDToken, _ref$vetted = _ref.vetted, vetted = void 0 === _ref$vetted || _ref$vetted, paymentMethodToken = _ref.paymentMethodToken, branded = _ref.branded, _ref$allowBillingPaym = _ref.allowBillingPayments, allowBillingPayments = void 0 === _ref$allowBillingPaym || _ref$allowBillingPaym, _ref$headers = _ref.headers, headers = void 0 === _ref$headers ? {} : _ref$headers;
            clientMetadataID && (headers[constants.HEADERS.CLIENT_METADATA_ID] = String(clientMetadataID));
            return Object(api.callGraphQL)({
                name: "GetSmartWallet",
                query: "\n            query GetSmartWallet(\n                $clientID: String!\n                $merchantID: [String!]\n                $currency: String\n                $amount: String\n                $userIDToken: String\n                $vetted: Boolean\n                $paymentMethodToken: String\n                $branded: Boolean,\n                $allowBillingPayments: Boolean\n            ) {\n                smartWallet(\n                    clientId: $clientID\n                    merchantId: $merchantID\n                    currency: $currency\n                    amount: $amount\n                    userIdToken: $userIDToken\n                    vetted: $vetted\n                    paymentMethodNonce: $paymentMethodToken\n                    branded: $branded,\n                    allowBillingPayments: $allowBillingPayments\n                ) {\n                    paypal {\n                        instruments {\n                            type\n                            label\n                            logoUrl\n                            instrumentID\n                            tokenID\n                            vendor\n                            oneClick\n                            accessToken\n                        }\n                    }\n                    credit {\n                        instruments {\n                            type\n                            label\n                            logoUrl\n                            instrumentID\n                            tokenID\n                            vendor\n                            oneClick\n                            accessToken\n                        }\n                    }\n                    card {\n                        instruments {\n                            type\n                            label\n                            logoUrl\n                            instrumentID\n                            tokenID\n                            vendor\n                            oneClick\n                        }\n                    }\n                    venmo {\n                        instruments {\n                            type\n                            label\n                            logoUrl\n                            instrumentID\n                            tokenID\n                            oneClick\n                        }\n                    }\n                }\n            }\n        ",
                variables: {
                    clientID: clientID,
                    merchantID: merchantID,
                    currency: currency,
                    amount: amount,
                    userIDToken: userIDToken,
                    vetted: vetted,
                    paymentMethodToken: paymentMethodToken,
                    branded: branded,
                    allowBillingPayments: allowBillingPayments
                },
                headers: headers
            }).then((function(_ref2) {
                return _ref2.smartWallet;
            }));
        }));
        function getFundingEligibility(query, _ref) {
            var _headers;
            var accessToken = _ref.accessToken, clientID = _ref.clientID, merchantID = _ref.merchantID, currency = _ref.currency, buyerCountry = _ref.buyerCountry, intent = _ref.intent, commit = _ref.commit, vault = _ref.vault, disableFunding = _ref.disableFunding, disableCard = _ref.disableCard;
            return Object(api.callGraphQL)({
                name: "GetFundingEligibility",
                query: "\n            query GetFundingEligibility(\n                $clientID:String,\n                $merchantID:[ String ],\n                $buyerCountry:CountryCodes,\n                $currency:SupportedCountryCurrencies,\n                $intent:FundingEligibilityIntent,\n                $commit:Boolean,\n                $vault:Boolean,\n                $disableFunding:[ SupportedPaymentMethodsType ],\n                $disableCard:[ SupportedCardsType ]\n            ) {\n            fundingEligibility(\n                clientId: $clientID,\n                buyerCountry: $buyerCountry,\n                currency: $currency,\n                intent: $intent,\n                commit: $commit,\n                vault: $vault,\n                disableFunding: $disableFunding,\n                disableCard: $disableCard,\n                merchantId: $merchantID\n            ) {\n                " + query + "\n            }\n          }\n        ",
                variables: {
                    clientID: clientID,
                    merchantID: merchantID,
                    buyerCountry: buyerCountry,
                    currency: currency,
                    commit: commit,
                    vault: vault,
                    intent: intent ? intent.toUpperCase() : intent,
                    disableFunding: disableFunding ? disableFunding.map((function(f) {
                        return f && f.toUpperCase();
                    })) : disableFunding,
                    disableCard: disableCard ? disableCard.map((function(f) {
                        return f && f.toUpperCase();
                    })) : disableCard
                },
                headers: (_headers = {}, _headers[constants.HEADERS.ACCESS_TOKEN] = accessToken || "", 
                _headers)
            }).then((function(gqlResult) {
                if (!gqlResult || !gqlResult.fundingEligibility) throw new Error("GraphQL fundingEligibility returned no fundingEligibility object");
                return gqlResult && gqlResult.fundingEligibility;
            }));
        }
        function getGuestEnabledStatus(merchantID) {
            return Object(api.callGraphQL)({
                name: "GetFundingEligibility",
                query: "\n            query GetFundingEligibility(\n                $merchantID:[ String ]\n            ) {\n            fundingEligibility(\n                merchantId: $merchantID\n            ) {\n                card {\n                    guestEnabled\n                }\n            }\n          }\n        ",
                variables: {
                    merchantID: merchantID
                }
            }).then((function(gqlResult) {
                if (!gqlResult || !gqlResult.fundingEligibility) throw new Error("GraphQL fundingEligibility returned no fundingEligibility object");
                return gqlResult && gqlResult.fundingEligibility && gqlResult.fundingEligibility.card && gqlResult.fundingEligibility.card.guestEnabled;
            }));
        }
        function getNativeEligibility(_ref2) {
            var vault = _ref2.vault, shippingCallbackEnabled = _ref2.shippingCallbackEnabled, merchantID = _ref2.merchantID, clientID = _ref2.clientID, buyerCountry = _ref2.buyerCountry, currency = _ref2.currency, buttonSessionID = _ref2.buttonSessionID, cookies = _ref2.cookies, orderID = _ref2.orderID, enableFunding = _ref2.enableFunding, stickinessID = _ref2.stickinessID, domain = _ref2.domain, _ref2$headers = _ref2.headers, headers = void 0 === _ref2$headers ? {} : _ref2$headers, _ref2$skipElmo = _ref2.skipElmo, skipElmo = void 0 !== _ref2$skipElmo && _ref2$skipElmo;
            var userAgent = Object(belter_src.getUserAgent)();
            return Object(api.callGraphQL)({
                name: "GetNativeEligibility",
                query: "\n            query GetNativeEligibility(\n                $vault : Boolean,\n                $shippingCallbackEnabled : Boolean,\n                $merchantID : String,\n                $clientID : String,\n                $buyerCountry : String,\n                $currency : String,\n                $userAgent : String,\n                $buttonSessionID : String,\n                $cookies : String,\n                $orderID : String,\n                $enableFunding : [String],\n                $stickinessID : String,\n                $domain : String,\n                $skipElmo : Boolean\n            ) {\n                mobileSDKEligibility(\n                    vault: $vault,\n                    shippingCallbackEnabled: $shippingCallbackEnabled,\n                    merchantID: $merchantID,\n                    facilitatorClientID: $clientID,\n                    buyerCountry: $buyerCountry,\n                    currency: $currency,\n                    userAgent: $userAgent,\n                    buttonSessionID: $buttonSessionID,\n                    cookies: $cookies,\n                    token: $orderID,\n                    enableFunding: $enableFunding,\n                    stickinessID: $stickinessID,\n                    domain: $domain,\n                    skipElmo: $skipElmo\n                ) {\n                    paypal {\n                        eligibility\n                        ineligibilityReason\n                    }\n                    venmo {\n                        eligibility\n                        ineligibilityReason\n                    }\n                }\n            }\n        ",
                variables: {
                    vault: vault,
                    shippingCallbackEnabled: shippingCallbackEnabled,
                    merchantID: merchantID,
                    clientID: clientID,
                    buyerCountry: buyerCountry,
                    currency: currency,
                    userAgent: userAgent,
                    buttonSessionID: buttonSessionID,
                    cookies: cookies,
                    orderID: orderID,
                    enableFunding: enableFunding,
                    stickinessID: stickinessID,
                    domain: domain,
                    skipElmo: skipElmo
                },
                headers: headers
            }).then((function(gqlResult) {
                if (!gqlResult || !gqlResult.mobileSDKEligibility) throw new Error("GraphQL GetNativeEligibility returned no mobileSDKEligibility object");
                return gqlResult.mobileSDKEligibility;
            }));
        }
        function getApplePayMerchantSession(_ref3) {
            var url = _ref3.url, clientID = _ref3.clientID, orderID = _ref3.orderID, merchantDomain = _ref3.merchantDomain;
            var domain = -1 !== merchantDomain.indexOf("://") ? merchantDomain.split("://")[1] : merchantDomain;
            return Object(api.callGraphQL)({
                name: "GetApplePayMerchantSession",
                query: "\n            query GetApplePayMerchantSession(\n                $url : String!\n                $orderID : String!\n                $clientID : String!\n                $merchantDomain : String!\n            ) {\n                applePayMerchantSession(\n                    url: $url\n                    orderID: $orderID\n                    clientID: $clientID\n                    merchantDomain: $merchantDomain\n                ) {\n                    session\n                }\n            }\n        ",
                variables: {
                    url: url,
                    clientID: clientID,
                    orderID: orderID,
                    merchantDomain: domain
                }
            }).then((function(gqlResult) {
                if (!gqlResult || !gqlResult.applePayMerchantSession) throw new Error("GraphQL GetApplePayMerchantSession returned no applePayMerchantSession object");
                return gqlResult.applePayMerchantSession;
            }));
        }
        var config_getApplepayConfig = function(_ref) {
            var buyerCountry = _ref.buyerCountry, clientId = _ref.clientId, merchantId = _ref.merchantId, _ref$headers = _ref.headers, headers = void 0 === _ref$headers ? {} : _ref$headers;
            return Object(api.callGraphQL)({
                name: "GetApplepayConfig",
                query: "\n        query GetApplepayConfig(\n            $buyerCountry: CountryCodes!\n            $clientId: String!\n            $merchantId: [String]!\n          ) {\n            applepayConfig(\n              buyerCountry: $buyerCountry\n              clientId: $clientId\n              merchantId: $merchantId\n            ) {\n              merchantCountry,\n              supportedNetworks\n            }\n          }\n        ",
                variables: {
                    buyerCountry: buyerCountry,
                    clientId: clientId,
                    merchantId: merchantId
                },
                headers: headers
            });
        };
    },
    "./src/api/vault.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "getVaultSetupToken", (function() {
            return getVaultSetupToken;
        }));
        __webpack_require__.d(__webpack_exports__, "updateVaultSetupToken", (function() {
            return updateVaultSetupToken;
        }));
        __webpack_require__.d(__webpack_exports__, "vaultApprovalSessionIdToOrderId", (function() {
            return vaultApprovalSessionIdToOrderId;
        }));
        __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/config.js");
        var _api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/api/api.js");
        var getVaultSetupToken = function(_ref) {
            var vaultSetupToken = _ref.vaultSetupToken, facilitatorAccessToken = _ref.facilitatorAccessToken;
            return Object(_api__WEBPACK_IMPORTED_MODULE_2__.callRestAPI)({
                accessToken: facilitatorAccessToken,
                url: _config__WEBPACK_IMPORTED_MODULE_1__.VAULT_SETUP_TOKENS_API_URL + "/" + vaultSetupToken,
                eventName: "v3_vault_setup_tokens_get"
            });
        };
        var updateVaultSetupToken = function(_ref2) {
            var clientID = _ref2.clientID, vaultSetupToken = _ref2.vaultSetupToken, paymentSource = _ref2.paymentSource, idToken = _ref2.idToken;
            return Object(_api__WEBPACK_IMPORTED_MODULE_2__.callGraphQL)({
                name: "UpdateVaultSetupToken",
                query: "\n      mutation UpdateVaultSetupToken(\n        $clientID: String!\n        $vaultSetupToken: String!\n        $paymentSource: PaymentSource\n        $idToken: String\n      ) {\n        updateVaultSetupToken(\n          clientId: $clientID\n          vaultSetupToken: $vaultSetupToken\n          paymentSource: $paymentSource\n          idToken: $idToken\n        ) {\n          id,\n          status,\n          links {\n            rel, href\n          }\n        }\n      }",
                variables: {
                    clientID: clientID,
                    vaultSetupToken: vaultSetupToken,
                    paymentSource: paymentSource,
                    idToken: idToken
                }
            });
        };
        function vaultApprovalSessionIdToOrderId(approvalSessionId) {
            return Object(_api__WEBPACK_IMPORTED_MODULE_2__.callSmartAPI)({
                authenticated: !1,
                method: "post",
                eventName: "vault_ectoken",
                url: _config__WEBPACK_IMPORTED_MODULE_1__.SMART_API_URI.VAULT + "/" + approvalSessionId + "/ectoken"
            }).then((function(_ref3) {
                return _ref3.data.token;
            }));
        }
    },
    "./src/button/index.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "setupButton", (function() {
            return setupButton;
        }));
        __webpack_require__.d(__webpack_exports__, "TYPES", (function() {
            return TYPES;
        }));
        __webpack_require__.d(__webpack_exports__, "getButtonProps", (function() {
            return getButtonProps;
        }));
        __webpack_require__.d(__webpack_exports__, "getComponents", (function() {
            return getComponents;
        }));
        __webpack_require__.d(__webpack_exports__, "getConfig", (function() {
            return getConfig;
        }));
        __webpack_require__.d(__webpack_exports__, "getServiceData", (function() {
            return getServiceData;
        }));
        var src = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        var sdk_constants_src = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var zalgo_promise_src = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var lib = __webpack_require__("./src/lib/index.js");
        var constants = __webpack_require__("./src/constants.js");
        var esm_extends = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/extends.js");
        var props_props = __webpack_require__("./src/props/props.js");
        var props_createBillingAgreement = __webpack_require__("./src/props/createBillingAgreement.js");
        var props_createSubscription = __webpack_require__("./src/props/createSubscription.js");
        var props_createOrder = __webpack_require__("./src/props/createOrder.js");
        var props_onApprove = __webpack_require__("./src/props/onApprove.js");
        var props_onComplete = __webpack_require__("./src/props/onComplete.js");
        var props_onCancel = __webpack_require__("./src/props/onCancel.js");
        var props_onShippingChange = __webpack_require__("./src/props/onShippingChange.js");
        var props_onShippingAddressChange = __webpack_require__("./src/props/onShippingAddressChange.js");
        var props_onShippingOptionsChange = __webpack_require__("./src/props/onShippingOptionsChange.js");
        var props_onAuth = __webpack_require__("./src/props/onAuth.js");
        var props_createVaultSetupToken = __webpack_require__("./src/props/createVaultSetupToken.js");
        var TYPES = !0;
        function getButtonProps(_ref) {
            var _branded;
            var facilitatorAccessToken = _ref.facilitatorAccessToken, paymentSource = _ref.paymentSource, experiments = _ref.experiments, featureFlags = _ref.featureFlags;
            var xprops = window.xprops;
            var buttonSessionID = xprops.buttonSessionID, style = xprops.style, branded = xprops.branded, intent = xprops.intent, partnerAttributionID = xprops.partnerAttributionID, merchantID = xprops.merchantID, clientID = xprops.clientID, clientAccessToken = xprops.clientAccessToken, _xprops$vault = xprops.vault, vault = void 0 !== _xprops$vault && _xprops$vault, currency = xprops.currency, flow = xprops.flow;
            branded = null != (_branded = branded) ? _branded : _ref.brandedDefault;
            if (xprops.createVaultSetupToken) {
                if (!experiments.payPalWalletVaultWithoutPurchase) throw new Error("You are not currently eligible to save a PayPal wallet without purchase.");
                if (xprops.createOrder) throw new Error("Do not pass both createVaultSetupToken and createOrder");
            }
            if (xprops.createBillingAgreement) {
                if (xprops.createOrder) throw new Error("Do not pass both createBillingAgreement and createOrder");
                if (!xprops.vault) throw new Error("Must pass vault=true to sdk to use createBillingAgreement");
            }
            if (xprops.createSubscription) {
                if (xprops.createOrder) throw new Error("Do not pass both createSubscription and createOrder");
                if (xprops.createBillingAgreement) throw new Error("Do not pass both createSubscription and createBillingAgreement");
                if (!xprops.vault) throw new Error("Must pass vault=true to sdk to use createSubscription");
            }
            if (intent === sdk_constants_src.INTENT.TOKENIZE) {
                if (!xprops.createBillingAgreement) throw new Error("Must pass createBillingAgreement with intent=tokenize");
                if (xprops.createOrder || xprops.createSubscription) throw new Error("Must not pass createOrder or createSubscription with intent=tokenize");
            }
            if (intent === sdk_constants_src.INTENT.SUBSCRIPTION) {
                if (!xprops.createSubscription) throw new Error("Must pass createSubscription with intent=subscription");
                if (xprops.createOrder || xprops.createBillingAgreement) throw new Error("Must not pass createOrder or createBillingAgreement with intent=tokenize");
            }
            var props = Object(props_props.getProps)({
                branded: branded
            });
            var callbackProps = function(_ref) {
                var paymentSource = _ref.paymentSource, partnerAttributionID = _ref.partnerAttributionID, merchantID = _ref.merchantID, clientID = _ref.clientID, facilitatorAccessToken = _ref.facilitatorAccessToken, currency = _ref.currency, intent = _ref.intent, branded = _ref.branded, clientAccessToken = _ref.clientAccessToken, _ref$vault = _ref.vault, vault = void 0 !== _ref$vault && _ref$vault, _ref$experiments = _ref.experiments, experiments = void 0 === _ref$experiments ? {} : _ref$experiments, featureFlags = _ref.featureFlags, inputCreateBillingAgreement = _ref.createBillingAgreement, inputCreateSubscription = _ref.createSubscription, inputCreateOrder = _ref.createOrder, onError = _ref.onError, inputOnApprove = _ref.onApprove, inputOnComplete = _ref.onComplete, inputOnCancel = _ref.onCancel, inputOnShippingChange = _ref.onShippingChange, inputOnShippingAddressChange = _ref.onShippingAddressChange, inputOnShippingOptionsChange = _ref.onShippingOptionsChange, inputCreateVaultSetupToken = _ref.createVaultSetupToken, flow = _ref.flow;
                var createBillingAgreement = Object(props_createBillingAgreement.getCreateBillingAgreement)({
                    createBillingAgreement: inputCreateBillingAgreement,
                    paymentSource: paymentSource
                });
                var createSubscription = Object(props_createSubscription.getCreateSubscription)({
                    createSubscription: inputCreateSubscription,
                    partnerAttributionID: partnerAttributionID,
                    merchantID: merchantID,
                    clientID: clientID,
                    paymentSource: paymentSource
                }, {
                    facilitatorAccessToken: facilitatorAccessToken
                });
                var createVaultSetupToken = Object(props_createVaultSetupToken.getCreateVaultSetupToken)({
                    createVaultSetupToken: inputCreateVaultSetupToken,
                    paymentSource: paymentSource
                });
                var createOrder = Object(props_createOrder.getCreateOrder)({
                    createOrder: inputCreateOrder,
                    currency: currency,
                    intent: intent,
                    merchantID: merchantID,
                    partnerAttributionID: partnerAttributionID,
                    paymentSource: paymentSource,
                    experiments: experiments
                }, {
                    facilitatorAccessToken: facilitatorAccessToken,
                    createBillingAgreement: createBillingAgreement,
                    createSubscription: createSubscription,
                    createVaultSetupToken: createVaultSetupToken,
                    flow: flow
                });
                return {
                    createBillingAgreement: createBillingAgreement,
                    createSubscription: createSubscription,
                    createOrder: createOrder,
                    onApprove: Object(props_onApprove.getOnApprove)({
                        onApprove: inputOnApprove,
                        createBillingAgreement: createBillingAgreement,
                        createSubscription: createSubscription,
                        intent: intent,
                        onError: onError,
                        partnerAttributionID: partnerAttributionID,
                        clientAccessToken: clientAccessToken,
                        vault: vault,
                        clientID: clientID,
                        facilitatorAccessToken: facilitatorAccessToken,
                        branded: branded,
                        createOrder: createOrder,
                        paymentSource: paymentSource,
                        featureFlags: featureFlags,
                        createVaultSetupToken: createVaultSetupToken,
                        flow: flow,
                        experiments: experiments
                    }),
                    onComplete: Object(props_onComplete.getOnComplete)({
                        intent: intent,
                        onComplete: inputOnComplete,
                        partnerAttributionID: partnerAttributionID,
                        onError: onError,
                        clientID: clientID,
                        facilitatorAccessToken: facilitatorAccessToken,
                        createOrder: createOrder,
                        featureFlags: featureFlags,
                        experiments: experiments
                    }),
                    onCancel: Object(props_onCancel.getOnCancel)({
                        onCancel: inputOnCancel,
                        onError: onError
                    }, {
                        createOrder: createOrder
                    }),
                    onShippingChange: Object(props_onShippingChange.getOnShippingChange)({
                        onShippingChange: inputOnShippingChange,
                        partnerAttributionID: partnerAttributionID,
                        experiments: experiments,
                        featureFlags: featureFlags,
                        clientID: clientID,
                        paymentSource: paymentSource
                    }, {
                        facilitatorAccessToken: facilitatorAccessToken,
                        createOrder: createOrder
                    }),
                    onShippingAddressChange: Object(props_onShippingAddressChange.getOnShippingAddressChange)({
                        onShippingAddressChange: inputOnShippingAddressChange
                    }, {
                        createOrder: createOrder
                    }),
                    onShippingOptionsChange: Object(props_onShippingOptionsChange.getOnShippingOptionsChange)({
                        onShippingOptionsChange: inputOnShippingOptionsChange
                    }, {
                        createOrder: createOrder
                    }),
                    onAuth: Object(props_onAuth.getOnAuth)({
                        facilitatorAccessToken: facilitatorAccessToken,
                        createOrder: createOrder,
                        createSubscription: createSubscription,
                        featureFlags: featureFlags,
                        experiments: experiments
                    })
                };
            }({
                paymentSource: paymentSource,
                partnerAttributionID: partnerAttributionID,
                merchantID: merchantID,
                clientID: clientID,
                facilitatorAccessToken: facilitatorAccessToken,
                currency: currency,
                intent: intent,
                branded: branded,
                clientAccessToken: clientAccessToken,
                vault: vault,
                experiments: experiments,
                featureFlags: featureFlags,
                createBillingAgreement: xprops.createBillingAgreement,
                createSubscription: xprops.createSubscription,
                createOrder: xprops.createOrder,
                onError: props.onError,
                onApprove: xprops.onApprove,
                onComplete: xprops.onComplete,
                onCancel: xprops.onCancel,
                onShippingChange: xprops.onShippingChange,
                onShippingAddressChange: xprops.onShippingAddressChange,
                onShippingOptionsChange: xprops.onShippingOptionsChange,
                createVaultSetupToken: xprops.createVaultSetupToken,
                flow: flow
            });
            return Object(esm_extends.default)({}, props, callbackProps, {
                style: style,
                buttonSessionID: buttonSessionID,
                branded: branded
            });
        }
        function getComponents() {
            var _paypal = paypal;
            return {
                Checkout: _paypal.Checkout,
                CardForm: _paypal.CardForm,
                ThreeDomainSecure: _paypal.ThreeDomainSecure,
                Menu: _paypal.Menu,
                Installments: _paypal.Installments,
                QRCode: _paypal.QRCode,
                PaymentFields: _paypal.PaymentFields,
                Venmo: _paypal.Venmo
            };
        }
        function getConfig(_ref2) {
            var firebaseConfig = _ref2.firebaseConfig;
            var cspNonce = _ref2.serverCSPNonce || Object(lib.getNonce)();
            return {
                sdkVersion: paypal.version,
                cspNonce: cspNonce,
                firebase: firebaseConfig
            };
        }
        function getServiceData(_ref3) {
            var eligibility = _ref3.eligibility;
            return {
                merchantID: _ref3.serverMerchantID,
                buyerCountry: _ref3.buyerGeoCountry || sdk_constants_src.COUNTRY.US,
                fundingEligibility: _ref3.fundingEligibility,
                wallet: _ref3.wallet,
                sdkMeta: _ref3.sdkMeta,
                content: _ref3.content,
                buyerAccessToken: _ref3.buyerAccessToken,
                facilitatorAccessToken: _ref3.facilitatorAccessToken,
                eligibility: {
                    cardForm: eligibility.cardFields || !1,
                    paymentFields: eligibility.inlinePaymentFields || {
                        inlineEligibleAPMs: [],
                        isInlineEnabled: !1
                    },
                    venmoWebEnabled: eligibility.venmoEnableOnShippingChange
                },
                cookies: _ref3.cookies,
                personalization: _ref3.personalization,
                featureFlags: _ref3.featureFlags
            };
        }
        function enableLoadingSpinner(button) {
            button.classList.add(constants.CLASS.LOADING);
        }
        function disableLoadingSpinner(button) {
            button.classList.remove(constants.CLASS.LOADING);
        }
        var api = __webpack_require__("./src/api/index.js");
        function isZeroAmount(value) {
            return "0.00" === parseFloat(value).toFixed(2);
        }
        function getApplePayShippingMethods(shippingMethods) {
            void 0 === shippingMethods && (shippingMethods = []);
            return [].concat(shippingMethods).sort((function(method) {
                return method.selected ? -1 : 0;
            })).map((function(method) {
                var _method$amount;
                return {
                    amount: (null == method || null == (_method$amount = method.amount) ? void 0 : _method$amount.currencyValue) || "0.00",
                    detail: method.type,
                    identifier: (null == method ? void 0 : method.id) || "",
                    label: method.label
                };
            }));
        }
        var applepay_config = null;
        var applepay_clean;
        var applepay = {
            name: "applepay",
            setup: function(_ref) {
                var _headers;
                var props = _ref.props;
                return Object(api.getApplepayConfig)({
                    buyerCountry: props.locale.country,
                    clientId: props.clientID,
                    merchantId: props.merchantID,
                    headers: (_headers = {}, _headers[constants.HEADERS.DISABLE_SET_COOKIE] = String(props.disableSetCookie), 
                    _headers)
                }).then((function(data) {
                    applepay_config = data.applepayConfig;
                })).catch((function(error) {
                    var _getLogger$error$trac;
                    Object(lib.getLogger)().error(constants.FPTI_TRANSITION.APPLEPAY_CONFIG_ERROR).track((_getLogger$error$trac = {}, 
                    _getLogger$error$trac[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.APPLEPAY_CONFIG_ERROR, 
                    _getLogger$error$trac[constants.FPTI_CUSTOM_KEY.ERR_DESC] = "Error: " + Object(src.stringifyError)(error), 
                    _getLogger$error$trac)).flush();
                }));
            },
            isEligible: function(_ref2) {
                var fundingEligibility = _ref2.serviceData.fundingEligibility;
                return !!(fundingEligibility && fundingEligibility[sdk_constants_src.FUNDING.APPLEPAY] && fundingEligibility[sdk_constants_src.FUNDING.APPLEPAY].eligible) && fundingEligibility[sdk_constants_src.FUNDING.APPLEPAY].eligible;
            },
            isPaymentEligible: function(_ref3) {
                return _ref3.payment.fundingSource === sdk_constants_src.FUNDING.APPLEPAY;
            },
            init: function(_ref4) {
                var props = _ref4.props;
                var createOrder = props.createOrder, onApprove = props.onApprove, onCancel = props.onCancel, onError = props.onError, onClick = props.onClick, onShippingChange = props.onShippingChange, locale = props.locale, clientID = props.clientID, merchantDomain = props.merchantDomain, currency = props.currency, applePay = props.applePay, partnerAttributionID = props.partnerAttributionID, paymentRequest = props.paymentRequest;
                var facilitatorAccessToken = _ref4.serviceData.facilitatorAccessToken;
                var fundingSource = _ref4.payment.fundingSource;
                applepay_clean && applepay_clean.all();
                applepay_clean = Object(src.cleanup)();
                var close = Object(src.memoize)((function() {
                    return applepay_clean.all();
                }));
                function logApplePayEvent(event, payload) {
                    var _getLogger$info$track;
                    var data = function(json) {
                        try {
                            JSON.parse(JSON.stringify(json));
                            return !0;
                        } catch (_unused) {
                            return !1;
                        }
                    }(payload) ? payload : {};
                    Object(lib.getLogger)().info(constants.FPTI_TRANSITION.APPLEPAY_EVENT + "_" + event, data).track((_getLogger$info$track = {}, 
                    _getLogger$info$track[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.APPLEPAY_EVENT + "_" + event, 
                    _getLogger$info$track[constants.FPTI_CUSTOM_KEY.INFO_MSG] = JSON.stringify(data), 
                    _getLogger$info$track)).flush();
                }
                function handleApplePayError(eventName, error) {
                    var _getLogger$error$trac2;
                    Object(lib.getLogger)().error(eventName).track((_getLogger$error$trac2 = {}, _getLogger$error$trac2[sdk_constants_src.FPTI_KEY.TRANSITION] = eventName, 
                    _getLogger$error$trac2[constants.FPTI_CUSTOM_KEY.ERR_DESC] = "Error: " + Object(src.stringifyError)(error), 
                    _getLogger$error$trac2)).flush();
                    return close().then((function() {
                        return onError(error);
                    }));
                }
                function updateNewLineItems(_ref5) {
                    var subtotal = _ref5.subtotal, tax = _ref5.tax, shipping = _ref5.shipping, shippingLabel = _ref5.shippingLabel, shippingDetail = _ref5.shippingDetail;
                    var newLineItems = [];
                    subtotal && !isZeroAmount(subtotal) && newLineItems.push({
                        label: "Subtotal",
                        amount: subtotal
                    });
                    tax && !isZeroAmount(tax) && newLineItems.push({
                        label: "Sales Tax",
                        amount: tax
                    });
                    var isPickup = "PICKUP" === shippingDetail;
                    (shipping && !isZeroAmount(shipping) || isPickup) && newLineItems.push({
                        label: shippingLabel || "Shipping",
                        amount: shipping || "0.00"
                    });
                    return newLineItems;
                }
                return {
                    click: function() {
                        return zalgo_promise_src.ZalgoPromise.try((function() {
                            return onShippingChangeCallback = function(_ref6) {
                                var orderID = _ref6.orderID, shippingContact = _ref6.shippingContact, _ref6$shippingMethod = _ref6.shippingMethod, shippingMethod = void 0 === _ref6$shippingMethod ? null : _ref6$shippingMethod, callbackTrigger = _ref6.callbackTrigger;
                                if (!onShippingChange) {
                                    var _currentShippingMetho, _currentShippingMetho2;
                                    var update = {
                                        newTotal: {
                                            label: merchantName,
                                            amount: currentTotalAmount
                                        },
                                        newLineItems: []
                                    };
                                    update.newLineItems = updateNewLineItems({
                                        shipping: currentShippingAmount,
                                        subtotal: currentSubtotalAmount,
                                        tax: currentTaxAmount,
                                        shippingLabel: null == (_currentShippingMetho = currentShippingMethod) ? void 0 : _currentShippingMetho.label,
                                        shippingDetail: null == (_currentShippingMetho2 = currentShippingMethod) ? void 0 : _currentShippingMetho2.detail
                                    });
                                    return zalgo_promise_src.ZalgoPromise.resolve(update);
                                }
                                var _validateShippingCont = function(contact) {
                                    var errors = [];
                                    null != contact && contact.locality || errors.push({
                                        code: "shippingContactInvalid",
                                        contactField: "locality",
                                        message: "City is invalid"
                                    });
                                    var country_code = null != contact && contact.countryCode ? sdk_constants_src.COUNTRY[contact.countryCode.toUpperCase()] : null;
                                    country_code || errors.push({
                                        code: "shippingContactInvalid",
                                        contactField: "countryCode",
                                        message: "Country code is invalid"
                                    });
                                    country_code !== sdk_constants_src.COUNTRY.US || null != contact && contact.administrativeArea || errors.push({
                                        code: "shippingContactInvalid",
                                        contactField: "administrativeArea",
                                        message: "State is invalid"
                                    });
                                    null != contact && contact.postalCode || errors.push({
                                        code: "shippingContactInvalid",
                                        contactField: "postalCode",
                                        message: "Postal code is invalid"
                                    });
                                    return {
                                        errors: errors,
                                        shipping_address: {
                                            city: null == contact ? void 0 : contact.locality,
                                            state: null == contact ? void 0 : contact.administrativeArea,
                                            country_code: country_code,
                                            postal_code: null == contact ? void 0 : contact.postalCode
                                        }
                                    };
                                }(shippingContact), errors = _validateShippingCont.errors, shipping_address = _validateShippingCont.shipping_address;
                                if (errors && errors.length) {
                                    var _currentShippingMetho3, _currentShippingMetho4;
                                    var _update = {
                                        errors: errors,
                                        newTotal: {
                                            label: merchantName,
                                            amount: currentTotalAmount
                                        },
                                        newLineItems: []
                                    };
                                    _update.newLineItems = updateNewLineItems({
                                        shipping: currentShippingAmount,
                                        subtotal: currentSubtotalAmount,
                                        tax: currentTaxAmount,
                                        shippingLabel: null == (_currentShippingMetho3 = currentShippingMethod) ? void 0 : _currentShippingMetho3.label,
                                        shippingDetail: null == (_currentShippingMetho4 = currentShippingMethod) ? void 0 : _currentShippingMetho4.detail
                                    });
                                    return zalgo_promise_src.ZalgoPromise.resolve(_update);
                                }
                                var data = {
                                    callbackTrigger: callbackTrigger,
                                    amount: {
                                        currency_code: currency,
                                        value: "0.00"
                                    },
                                    orderID: orderID,
                                    shipping_address: shipping_address
                                };
                                if (shippingMethod) {
                                    var _currentShippingMetho5;
                                    data.selected_shipping_option = {
                                        label: shippingMethod.label || (null == (_currentShippingMetho5 = currentShippingMethod) ? void 0 : _currentShippingMetho5.label) || "Shipping",
                                        id: shippingMethod.identifier,
                                        amount: {
                                            currency_code: currency,
                                            value: shippingMethod.amount
                                        }
                                    };
                                } else {
                                    var _currentShippingMetho6;
                                    data.selected_shipping_option = {
                                        label: "Shipping",
                                        id: null == (_currentShippingMetho6 = currentShippingMethod) ? void 0 : _currentShippingMetho6.identifier,
                                        amount: {
                                            currency_code: currency,
                                            value: currentShippingAmount
                                        }
                                    };
                                }
                                var actions = {
                                    resolve: function() {
                                        return zalgo_promise_src.ZalgoPromise.resolve();
                                    },
                                    reject: function(err) {
                                        return zalgo_promise_src.ZalgoPromise.reject(err);
                                    }
                                };
                                return onShippingChange(Object(esm_extends.default)({}, data, {
                                    facilitatorAccessToken: facilitatorAccessToken,
                                    partnerAttributionID: partnerAttributionID,
                                    forceRestAPI: !0
                                }), actions).then((function() {
                                    currentShippingContact = shippingContact;
                                    shippingMethod && (currentShippingMethod = shippingMethod);
                                    return Object(api.getDetailedOrderInfo)(orderID, locale.country).then((function(updatedOrder) {
                                        var _currentShippingMetho7, _updatedOrder$checkou3, _currentShippingMetho8, _currentShippingMetho9;
                                        var _updatedOrder$checkou = updatedOrder.checkoutSession.cart, _updatedOrder$checkou2 = _updatedOrder$checkou.amounts, updatedTaxValue = _updatedOrder$checkou2.tax.currencyValue, updatedSubtotalValue = _updatedOrder$checkou2.subtotal.currencyValue, updatedTotalValue = _updatedOrder$checkou2.total.currencyValue;
                                        currentShippingAmount = (null == (_currentShippingMetho7 = currentShippingMethod) ? void 0 : _currentShippingMetho7.amount) || currentShippingAmount || "0.00";
                                        currentTaxAmount = "0.00" === updatedTaxValue ? currentTaxAmount : updatedTaxValue;
                                        currentSubtotalAmount = "0.00" === updatedSubtotalValue ? currentSubtotalAmount : updatedSubtotalValue;
                                        currentTotalAmount = updatedTotalValue;
                                        var update = {
                                            newTotal: {
                                                label: merchantName = (null == updatedOrder || null == (_updatedOrder$checkou3 = updatedOrder.checkoutSession) || null == (_updatedOrder$checkou3 = _updatedOrder$checkou3.merchant) ? void 0 : _updatedOrder$checkou3.name) || "Total",
                                                amount: updatedTotalValue
                                            },
                                            newLineItems: [],
                                            newShippingMethods: getApplePayShippingMethods(_updatedOrder$checkou.shippingMethods)
                                        };
                                        update.newLineItems = updateNewLineItems({
                                            shipping: currentShippingAmount,
                                            subtotal: currentSubtotalAmount,
                                            tax: currentTaxAmount,
                                            shippingLabel: null == (_currentShippingMetho8 = currentShippingMethod) ? void 0 : _currentShippingMetho8.label,
                                            shippingDetail: null == (_currentShippingMetho9 = currentShippingMethod) ? void 0 : _currentShippingMetho9.detail
                                        });
                                        return zalgo_promise_src.ZalgoPromise.resolve(update);
                                    }));
                                }));
                            }, function setupApplePaySession() {
                                var _paymentRequest$apple, _config, _config2, _paymentRequest$apple2;
                                var requiredShippingContactFields = (null == paymentRequest || null == (_paymentRequest$apple = paymentRequest.applepay) ? void 0 : _paymentRequest$apple.requiredShippingContactFields) || [];
                                var applePayRequest = {
                                    countryCode: null == (_config = applepay_config) ? void 0 : _config.merchantCountry,
                                    currencyCode: currency,
                                    merchantCapabilities: [ "supports3DS", "supportsCredit", "supportsDebit" ],
                                    supportedNetworks: null == (_config2 = applepay_config) ? void 0 : _config2.supportedNetworks,
                                    requiredBillingContactFields: [ "postalAddress" ],
                                    requiredShippingContactFields: requiredShippingContactFields,
                                    shippingContact: (null == paymentRequest || null == (_paymentRequest$apple2 = paymentRequest.applepay) ? void 0 : _paymentRequest$apple2.shippingContact) || {},
                                    shippingMethods: [],
                                    lineItems: [],
                                    total: {
                                        label: "",
                                        amount: "0.00",
                                        type: "pending"
                                    }
                                };
                                return applePay(4, applePayRequest).then((function(response) {
                                    var begin = response.begin, abort = response.abort, addEventListener = response.addEventListener, completeMerchantValidation = response.completeMerchantValidation, completeShippingContactSelection = response.completeShippingContactSelection, completePaymentMethodSelection = response.completePaymentMethodSelection, completeShippingMethodSelection = response.completeShippingMethodSelection, completePayment = response.completePayment;
                                    zalgo_promise_src.ZalgoPromise.all([ addEventListener("validatemerchant", (function(_ref7) {
                                        var validationURL = _ref7.validationURL;
                                        logApplePayEvent("validatemerchant", {
                                            validationURL: validationURL
                                        });
                                        return zalgo_promise_src.ZalgoPromise.try((function() {
                                            return !onClick || onClick({
                                                fundingSource: fundingSource
                                            }).then((function(valid) {
                                                valid || abort();
                                                return valid;
                                            }));
                                        })).then((function(valid) {
                                            if (!valid) {
                                                var _getLogger$info$track2;
                                                Object(lib.getLogger)().info("applepay_onclick_invalid").track((_getLogger$info$track2 = {}, 
                                                _getLogger$info$track2[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                                                _getLogger$info$track2[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.APPLEPAY_ON_CLICK_INVALID, 
                                                _getLogger$info$track2)).flush();
                                            }
                                            return valid;
                                        })).then((function(valid) {
                                            return valid ? createOrder() : Object(lib.unresolvedPromise)();
                                        })).then((function(orderID) {
                                            return Object(api.getDetailedOrderInfo)(orderID, locale.country).then((function(order) {
                                                var _order$checkoutSessio = order.checkoutSession, merchant = _order$checkoutSessio.merchant, _order$checkoutSessio2 = _order$checkoutSessio.cart, _order$checkoutSessio3 = _order$checkoutSessio2.amounts, taxValue = _order$checkoutSessio3.tax.currencyValue, subtotalValue = _order$checkoutSessio3.subtotal.currencyValue, totalValue = _order$checkoutSessio3.total.currencyValue, shippingAddress = _order$checkoutSessio2.shippingAddress;
                                                currentShippingAmount = _order$checkoutSessio3.shippingAndHandling.currencyValue;
                                                var appleShippingMethods = getApplePayShippingMethods(_order$checkoutSessio2.shippingMethods);
                                                currentShippingContact = function(shippingAddress) {
                                                    if (!shippingAddress) return {
                                                        givenName: "",
                                                        familyName: "",
                                                        addressLines: [],
                                                        locality: "",
                                                        administrativeArea: "",
                                                        postalCode: "",
                                                        country: "",
                                                        countryCode: ""
                                                    };
                                                    var country = shippingAddress.country;
                                                    return {
                                                        givenName: shippingAddress.firstName,
                                                        familyName: shippingAddress.lastName,
                                                        addressLines: [ shippingAddress.line1, shippingAddress.line2 ],
                                                        locality: shippingAddress.city,
                                                        administrativeArea: shippingAddress.state,
                                                        postalCode: shippingAddress.postalCode,
                                                        country: country,
                                                        countryCode: country
                                                    };
                                                }(shippingAddress);
                                                currentShippingMethod = (appleShippingMethods || []).find((function() {
                                                    return !0;
                                                }));
                                                currentTaxAmount = taxValue;
                                                currentSubtotalAmount = subtotalValue;
                                                currentTotalAmount = totalValue;
                                                merchantName = (null == merchant ? void 0 : merchant.name) || "Total";
                                                return Object(api.getApplePayMerchantSession)({
                                                    url: validationURL,
                                                    clientID: clientID,
                                                    orderID: orderID,
                                                    merchantDomain: merchantDomain
                                                }).then((function(merchantSession) {
                                                    try {
                                                        var session = atob(merchantSession.session);
                                                        completeMerchantValidation(JSON.parse(session));
                                                    } catch (err) {
                                                        handleApplePayError(constants.FPTI_TRANSITION.APPLEPAY_MERCHANT_VALIDATION_COMPLETION_ERROR, err);
                                                        abort();
                                                    }
                                                })).catch((function(err) {
                                                    handleApplePayError(constants.FPTI_TRANSITION.APPLEPAY_MERCHANT_VALIDATION_ERROR, err);
                                                    abort();
                                                }));
                                            })).catch((function(err) {
                                                handleApplePayError(constants.FPTI_TRANSITION.APPLEPAY_GET_DETAILS_ERROR, err);
                                                abort();
                                            }));
                                        })).catch((function(err) {
                                            handleApplePayError(constants.FPTI_TRANSITION.APPLEPAY_GET_DETAILS_ERROR, err);
                                            abort();
                                        }));
                                    })), addEventListener("paymentmethodselected", (function(_ref8) {
                                        var _currentShippingMetho10, _currentShippingMetho11;
                                        logApplePayEvent("paymentmethodselected", _ref8.paymentMethod);
                                        var update = {
                                            newTotal: {
                                                label: merchantName,
                                                amount: currentTotalAmount || "0.00"
                                            },
                                            newLineItems: []
                                        };
                                        update.newLineItems = updateNewLineItems({
                                            shipping: currentShippingAmount,
                                            subtotal: currentSubtotalAmount,
                                            tax: currentTaxAmount,
                                            shippingLabel: null == (_currentShippingMetho10 = currentShippingMethod) ? void 0 : _currentShippingMetho10.label,
                                            shippingDetail: null == (_currentShippingMetho11 = currentShippingMethod) ? void 0 : _currentShippingMetho11.detail
                                        });
                                        completePaymentMethodSelection(update);
                                    })), addEventListener("shippingmethodselected", (function(_ref9) {
                                        var shippingMethod = _ref9.shippingMethod;
                                        logApplePayEvent("shippingmethodselected");
                                        return createOrder().then((function(orderID) {
                                            return onShippingChangeCallback({
                                                orderID: orderID,
                                                shippingContact: currentShippingContact,
                                                shippingMethod: shippingMethod,
                                                callbackTrigger: "SHIPPING_OPTION"
                                            }).then((function(update) {
                                                currentShippingMethod = shippingMethod;
                                                completeShippingMethodSelection(update);
                                            })).catch((function() {
                                                var _currentShippingMetho12;
                                                var update = {
                                                    newTotal: {
                                                        label: merchantName,
                                                        amount: currentTotalAmount || "0.00"
                                                    },
                                                    newLineItems: []
                                                };
                                                update.newLineItems = updateNewLineItems({
                                                    shipping: currentShippingAmount,
                                                    subtotal: currentSubtotalAmount,
                                                    tax: currentTaxAmount,
                                                    shippingLabel: null == shippingMethod ? void 0 : shippingMethod.label,
                                                    shippingDetail: null == (_currentShippingMetho12 = currentShippingMethod) ? void 0 : _currentShippingMetho12.detail
                                                });
                                                completeShippingMethodSelection(update);
                                            }));
                                        }));
                                    })), addEventListener("shippingcontactselected", (function(_ref10) {
                                        var shippingContact = _ref10.shippingContact;
                                        logApplePayEvent("shippingcontactselected", shippingContact);
                                        return createOrder().then((function(orderID) {
                                            return onShippingChangeCallback({
                                                orderID: orderID,
                                                shippingContact: shippingContact,
                                                shippingMethod: currentShippingMethod,
                                                callbackTrigger: "SHIPPING_ADDRESS"
                                            }).then((function(update) {
                                                completeShippingContactSelection(update);
                                            })).catch((function(err) {
                                                handleApplePayError("shippingContactSelected", err);
                                            }));
                                        }));
                                    })), addEventListener("paymentauthorized", (function(_ref11) {
                                        var _applePayPayment$ship, _applePayPayment$bill;
                                        var applePayPayment = _ref11.payment;
                                        logApplePayEvent("paymentauthorized");
                                        if (!applePayPayment) throw new Error("No payment received from Apple.");
                                        null != applePayPayment && null != (_applePayPayment$ship = applePayPayment.shippingContact) && _applePayPayment$ship.countryCode && (applePayPayment.shippingContact.countryCode = applePayPayment.shippingContact.countryCode.toUpperCase());
                                        null != applePayPayment && null != (_applePayPayment$bill = applePayPayment.billingContact) && _applePayPayment$bill.countryCode && (applePayPayment.billingContact.countryCode = applePayPayment.billingContact.countryCode.toUpperCase());
                                        return createOrder().then((function(orderID) {
                                            return Object(api.approveApplePayPayment)(orderID, clientID, applePayPayment).then((function(validatedPayment) {
                                                if (validatedPayment) {
                                                    completePayment({
                                                        status: window.ApplePaySession.STATUS_SUCCESS
                                                    });
                                                    var actions = {
                                                        restart: function() {
                                                            return zalgo_promise_src.ZalgoPromise.try(setupApplePaySession);
                                                        }
                                                    };
                                                    return zalgo_promise_src.ZalgoPromise.all([ onApprove({}, actions), close() ]).then(src.noop);
                                                }
                                            })).catch((function(err) {
                                                completePayment({
                                                    status: window.ApplePaySession.STATUS_FAILURE
                                                });
                                                handleApplePayError(constants.FPTI_TRANSITION.APPLEPAY_PAYMENT_ERROR, err);
                                            }));
                                        }));
                                    })), addEventListener("oncancel", (function() {
                                        logApplePayEvent("oncancel");
                                        onCancel && onCancel();
                                    })) ]).then((function() {
                                        begin();
                                    }));
                                }));
                            }();
                            var currentTotalAmount, currentSubtotalAmount, currentTaxAmount, currentShippingAmount, currentShippingContact, currentShippingMethod, merchantName, onShippingChangeCallback;
                        })).catch((function(err) {
                            return close().then((function() {
                                var _getLogger$error$trac3;
                                Object(lib.getLogger)().error("applepay_flow_error", {
                                    err: Object(src.stringifyError)(err)
                                }).track((_getLogger$error$trac3 = {}, _getLogger$error$trac3[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.APPLEPAY_FLOW_ERROR, 
                                _getLogger$error$trac3[sdk_constants_src.FPTI_KEY.ERROR_CODE] = "applepay_error", 
                                _getLogger$error$trac3[sdk_constants_src.FPTI_KEY.ERROR_DESC] = Object(src.stringifyErrorMessage)(err), 
                                _getLogger$error$trac3)).flush();
                                throw err;
                            }));
                        }));
                    },
                    start: lib.promiseNoop,
                    close: close
                };
            },
            spinner: !0
        };
        var cross_domain_utils_src = __webpack_require__("./node_modules/@krakenjs/cross-domain-utils/src/index.js");
        function _renderChildren(children, renderer) {
            var result = [];
            for (var _i2 = 0; _i2 < children.length; _i2++) {
                var renderedChild = children[_i2].render(renderer);
                if (renderedChild) if (Array.isArray(renderedChild)) for (var _i4 = 0; _i4 < renderedChild.length; _i4++) {
                    var subchild = renderedChild[_i4];
                    subchild && result.push(subchild);
                } else result.push(renderedChild);
            }
            return result;
        }
        var node_ElementNode = function() {
            function ElementNode(name, props, children) {
                this.type = "element";
                this.name = void 0;
                this.props = void 0;
                this.children = void 0;
                this.onRender = void 0;
                this.name = name;
                this.props = props || {};
                this.children = children;
                var onRender = this.props.onRender;
                if ("function" == typeof onRender) {
                    this.onRender = onRender;
                    delete props.onRender;
                }
            }
            var _proto = ElementNode.prototype;
            _proto.render = function(renderer) {
                var el = renderer(this);
                this.onRender && this.onRender(el);
                return el;
            };
            _proto.renderChildren = function(renderer) {
                return _renderChildren(this.children, renderer);
            };
            return ElementNode;
        }();
        var node_FragmentNode = function() {
            function FragmentNode(children) {
                this.type = "fragment";
                this.children = void 0;
                this.children = children;
            }
            FragmentNode.prototype.render = function(renderer) {
                return _renderChildren(this.children, renderer);
            };
            return FragmentNode;
        }();
        var node_TextNode = function() {
            function TextNode(text) {
                this.type = "text";
                this.text = void 0;
                this.text = text;
            }
            TextNode.prototype.render = function(renderer) {
                return renderer(this);
            };
            return TextNode;
        }();
        var node_ComponentNode = function() {
            function ComponentNode(component, props, children) {
                this.type = "component";
                this.component = void 0;
                this.props = void 0;
                this.children = void 0;
                this.component = component;
                this.props = props || {};
                this.children = children;
                this.props.children = children;
            }
            var _proto4 = ComponentNode.prototype;
            _proto4.renderComponent = function(renderer) {
                var child = function(child) {
                    var children = normalizeChildren(Array.isArray(child) ? child : [ child ]);
                    return 1 === children.length ? children[0] : children.length > 1 ? new node_FragmentNode(children) : void 0;
                }(this.component(this.props, this.children));
                if (child) return child.render(renderer);
            };
            _proto4.render = function(renderer) {
                return renderer(this);
            };
            _proto4.renderChildren = function(renderer) {
                return _renderChildren(this.children, renderer);
            };
            return ComponentNode;
        }();
        function normalizeChildren(children) {
            var result = [];
            for (var _i6 = 0; _i6 < children.length; _i6++) {
                var child = children[_i6];
                if (child) if ("string" == typeof child || "number" == typeof child) result.push(new node_TextNode(child.toString())); else {
                    if ("boolean" == typeof child) continue;
                    if (Array.isArray(child)) for (var _i8 = 0, _normalizeChildren2 = normalizeChildren(child); _i8 < _normalizeChildren2.length; _i8++) result.push(_normalizeChildren2[_i8]); else {
                        if (!child || "element" !== child.type && "text" !== child.type && "component" !== child.type) throw new TypeError("Unrecognized node type: " + typeof child);
                        result.push(child);
                    }
                }
            }
            return result;
        }
        var node_node = function(element, props) {
            for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) children[_key - 2] = arguments[_key];
            children = normalizeChildren(children);
            if ("string" == typeof element) return new node_ElementNode(element, props, children);
            if ("function" == typeof element) return new node_ComponentNode(element, props, children);
            throw new TypeError("Expected jsx element to be a string or a function");
        };
        var _ELEMENT_DEFAULT_XML_, _ATTRIBUTE_DEFAULT_XM, _ADD_CHILDREN;
        var ELEMENT_DEFAULT_XML_NAMESPACE = ((_ELEMENT_DEFAULT_XML_ = {}).svg = "http://www.w3.org/2000/svg", 
        _ELEMENT_DEFAULT_XML_);
        var ATTRIBUTE_DEFAULT_XML_NAMESPACE = ((_ATTRIBUTE_DEFAULT_XM = {})["xlink:href"] = "http://www.w3.org/1999/xlink", 
        _ATTRIBUTE_DEFAULT_XM);
        function createTextElement(doc, node) {
            return doc.createTextNode(node.text);
        }
        function addProps(el, node) {
            var props = node.props;
            for (var _i4 = 0, _Object$keys2 = Object.keys(props); _i4 < _Object$keys2.length; _i4++) {
                var prop = _Object$keys2[_i4];
                var val = props[prop];
                if (null != val && "el" !== prop && "innerHTML" !== prop) if (prop.match(/^on[A-Z][a-z]/) && "function" == typeof val) el.addEventListener(prop.slice(2).toLowerCase(), val); else if ("string" == typeof val || "number" == typeof val) {
                    var xmlNamespace = ATTRIBUTE_DEFAULT_XML_NAMESPACE[prop];
                    xmlNamespace ? el.setAttributeNS(xmlNamespace, prop, val.toString()) : el.setAttribute(prop, val.toString());
                } else "boolean" == typeof val && !0 === val && el.setAttribute(prop, "");
            }
            "iframe" !== el.tagName.toLowerCase() || props.id || el.setAttribute("id", "jsx-iframe-" + "xxxxxxxxxx".replace(/./g, (function() {
                return "0123456789abcdef".charAt(Math.floor(Math.random() * "0123456789abcdef".length));
            })));
        }
        var ADD_CHILDREN = ((_ADD_CHILDREN = {}).iframe = function(el, node) {
            var firstChild = node.children[0];
            if (1 !== node.children.length || !firstChild || "element" !== firstChild.type || "html" !== firstChild.name) throw new Error("Expected only single html element node as child of iframe element");
            el.addEventListener("load", (function() {
                var win = el.contentWindow;
                if (!win) throw new Error("Expected frame to have contentWindow");
                var doc = win.document;
                var docElement = doc.documentElement;
                for (;docElement.children && docElement.children.length; ) docElement.removeChild(docElement.children[0]);
                var child = firstChild.render(dom({
                    doc: doc
                }));
                for (;child.children.length; ) docElement.appendChild(child.children[0]);
            }));
        }, _ADD_CHILDREN.script = function(el, node) {
            var firstChild = node.children[0];
            if (1 !== node.children.length || !firstChild || "text" !== firstChild.type) throw new Error("Expected only single text node as child of script element");
            el.text = firstChild.text;
        }, _ADD_CHILDREN.default = function(el, node, renderer) {
            for (var _i6 = 0, _node$renderChildren2 = node.renderChildren(renderer); _i6 < _node$renderChildren2.length; _i6++) el.appendChild(_node$renderChildren2[_i6]);
        }, _ADD_CHILDREN);
        function addChildren(el, node, doc, renderer) {
            if (node.props.hasOwnProperty("innerHTML")) {
                if (node.children.length) throw new Error("Expected no children to be passed when innerHTML prop is set");
                var html = node.props.innerHTML;
                if ("string" != typeof html) throw new TypeError("innerHTML prop must be string");
                if ("script" === node.name) el.text = html; else {
                    el.innerHTML = html;
                    !function(el, doc) {
                        void 0 === doc && (doc = window.document);
                        for (var _i2 = 0, _el$querySelectorAll2 = el.querySelectorAll("script"); _i2 < _el$querySelectorAll2.length; _i2++) {
                            var script = _el$querySelectorAll2[_i2];
                            var parentNode = script.parentNode;
                            if (parentNode) {
                                var newScript = doc.createElement("script");
                                newScript.text = script.textContent;
                                parentNode.replaceChild(newScript, script);
                            }
                        }
                    }(el, doc);
                }
            } else (ADD_CHILDREN[node.name] || ADD_CHILDREN.default)(el, node, renderer);
        }
        function dom(opts) {
            void 0 === opts && (opts = {});
            var _opts$doc = opts.doc, doc = void 0 === _opts$doc ? document : _opts$doc;
            return function domRenderer(node) {
                if ("component" === node.type) return node.renderComponent(domRenderer);
                if ("text" === node.type) return createTextElement(doc, node);
                if ("element" === node.type) {
                    var xmlNamespace = ELEMENT_DEFAULT_XML_NAMESPACE[node.name.toLowerCase()];
                    if (xmlNamespace) return function xmlNamespaceDomRenderer(node, xmlNamespace) {
                        if ("component" === node.type) return node.renderComponent((function(childNode) {
                            return xmlNamespaceDomRenderer(childNode, xmlNamespace);
                        }));
                        if ("text" === node.type) return createTextElement(doc, node);
                        if ("element" === node.type) {
                            var el = function(doc, node, xmlNamespace) {
                                return doc.createElementNS(xmlNamespace, node.name);
                            }(doc, node, xmlNamespace);
                            addProps(el, node);
                            addChildren(el, node, doc, (function(childNode) {
                                return xmlNamespaceDomRenderer(childNode, xmlNamespace);
                            }));
                            return el;
                        }
                        throw new TypeError("Unhandleable node");
                    }(node, xmlNamespace);
                    var el = function(doc, node) {
                        return node.props.el ? node.props.el : doc.createElement(node.name);
                    }(doc, node);
                    addProps(el, node);
                    addChildren(el, node, doc, domRenderer);
                    return el;
                }
                throw new TypeError("Unhandleable node");
            };
        }
        __webpack_require__("./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
        function Spinner(_ref) {
            return node_node("div", {
                class: "preloader spinner"
            }, node_node("style", {
                nonce: _ref.nonce,
                innerHTML: "\n\n    body {\n        width: 100%;\n        height: 100%;\n        overflow: hidden;\n        position: fixed;\n        top: 0;\n        left: 0;\n        margin: 0;\n    }\n\n    .spinner {\n        height: 100%;\n        width: 100%;\n        position: absolute;\n        z-index: 10\n    }\n\n    .spinner .spinWrap {\n        width: 200px;\n        height: 100px;\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        margin-left: -100px;\n        margin-top: -50px\n    }\n\n    .spinner .loader,\n    .spinner .spinnerImage {\n        height: 100px;\n        width: 100px;\n        position: absolute;\n        top: 0;\n        left: 50%;\n        opacity: 1;\n        filter: alpha(opacity=100)\n    }\n\n    .spinner .spinnerImage {\n        margin: 28px 0 0 -25px;\n        background: url(https://www.paypalobjects.com/images/checkout/hermes/icon_ot_spin_lock_skinny.png) no-repeat\n    }\n\n    .spinner .loader {\n        margin: 0 0 0 -55px;\n        background-color: transparent;\n        animation: rotation .7s infinite linear;\n        border-left: 5px solid #cbcbca;\n        border-right: 5px solid #cbcbca;\n        border-bottom: 5px solid #cbcbca;\n        border-top: 5px solid #2380be;\n        border-radius: 100%\n    }\n\n    @keyframes rotation {\n        from {\n            transform: rotate(0deg)\n        }\n        to {\n            transform: rotate(359deg)\n        }\n    }\n"
            }), node_node("div", {
                class: "spinWrap"
            }, node_node("p", {
                class: "spinnerImage"
            }), node_node("p", {
                class: "loader"
            })));
        }
        function SpinnerPage(_ref2, children) {
            var nonce = _ref2.nonce;
            return node_node("html", null, node_node("head", null, node_node("title", null, "PayPal"), node_node("meta", {
                name: "viewport",
                content: "width=device-width, initial-scale=1"
            })), node_node("body", null, node_node(Spinner, {
                nonce: nonce
            }), children));
        }
        function openPopup(_ref) {
            var width = _ref.width, height = _ref.height, _ref$closeOnUnload = _ref.closeOnUnload, closeOnUnload = void 0 === _ref$closeOnUnload ? 1 : _ref$closeOnUnload;
            var win = Object(cross_domain_utils_src.assertSameDomain)(Object(src.popup)("", {
                width: width,
                height: height,
                closeOnUnload: closeOnUnload
            }));
            var doc = win.document;
            var spinner = node_node(SpinnerPage, {
                nonce: Object(lib.getNonce)()
            }).render(dom({
                doc: doc
            }));
            Object(src.writeElementToWindow)(win, spinner);
            return win;
        }
        var src_config = __webpack_require__("./src/config.js");
        var CHECKOUT_POPUP_DIMENSIONS = {
            WIDTH: 500,
            HEIGHT: 590
        };
        var EXPERIMENTAL_POPUP_DIMENSIONS = {
            WIDTH: 568,
            HEIGHT: 750
        };
        var canRenderTop = !1;
        var smokeHash = "";
        var buyerAccessTokenReceivedOnAuth = null;
        var checkout_getDimensions = function(fundingSource, popupIncreaseDimensions) {
            if (Object(src.isWebView)()) {
                Object(lib.getLogger)().info("popup_dimensions_" + fundingSource);
                Object(lib.sendCountMetric)({
                    name: "pp.app.paypal_sdk.checkout_ui.dimension.count",
                    dimensions: {
                        spbPaymentFlow: "checkout",
                        fundingSource: fundingSource,
                        dimensionType: "webview"
                    }
                });
                return {
                    width: window.outerWidth - 4,
                    height: window.outerHeight - 20
                };
            }
            if (-1 !== sdk_constants_src.APM_LIST.indexOf(fundingSource)) {
                Object(lib.getLogger)().info("popup_dimensions_value_" + fundingSource);
                Object(lib.sendCountMetric)({
                    name: "pp.app.paypal_sdk.checkout_ui.dimension.count",
                    dimensions: {
                        spbPaymentFlow: "checkout",
                        fundingSource: fundingSource,
                        dimensionType: "apm"
                    }
                });
                return {
                    width: 1282,
                    height: 720
                };
            }
            if (popupIncreaseDimensions) {
                Object(lib.getLogger)().info("popup_dimensions_value_" + fundingSource);
                Object(lib.sendCountMetric)({
                    name: "pp.app.paypal_sdk.checkout_ui.dimension.count",
                    dimensions: {
                        spbPaymentFlow: "checkout",
                        fundingSource: fundingSource,
                        dimensionType: "experiment_default"
                    }
                });
                return {
                    width: EXPERIMENTAL_POPUP_DIMENSIONS.WIDTH,
                    height: EXPERIMENTAL_POPUP_DIMENSIONS.HEIGHT
                };
            }
            Object(lib.getLogger)().info("popup_dimensions_" + fundingSource);
            Object(lib.sendCountMetric)({
                name: "pp.app.paypal_sdk.checkout_ui.dimension.count",
                dimensions: {
                    spbPaymentFlow: "checkout",
                    fundingSource: fundingSource,
                    dimensionType: "default"
                }
            });
            return {
                width: CHECKOUT_POPUP_DIMENSIONS.WIDTH,
                height: CHECKOUT_POPUP_DIMENSIONS.HEIGHT
            };
        };
        var checkout = {
            name: "checkout",
            setup: function(_ref) {
                var Checkout = _ref.components.Checkout;
                var _ref2 = [ Object(cross_domain_utils_src.getParent)(window), Object(cross_domain_utils_src.getTop)(window) ], parent = _ref2[0], top = _ref2[1];
                var tasks = {};
                top && parent && parent !== top && (tasks.canRenderTo = Checkout.canRenderTo(top).then((function(result) {
                    canRenderTop = result;
                })));
                window.xprops.getPageUrl().then((function(pageUrl) {
                    return -1 !== pageUrl.indexOf("smokeHash") ? Object(src.parseQuery)(pageUrl.split("?")[1]).smokeHash : "";
                })).then((function(hash) {
                    smokeHash = hash;
                }));
                return zalgo_promise_src.ZalgoPromise.hash(tasks).then(src.noop);
            },
            isEligible: function() {
                return !0;
            },
            isPaymentEligible: function() {
                return !0;
            },
            init: function initCheckout(_ref5) {
                var props = _ref5.props, components = _ref5.components, serviceData = _ref5.serviceData, payment = _ref5.payment, config = _ref5.config, fullRestart = _ref5.restart, experiments = _ref5.experiments;
                var Checkout = components.Checkout;
                var sessionID = props.sessionID, buttonSessionID = props.buttonSessionID, _createOrder = props.createOrder, _onApprove = props.onApprove, _onComplete = props.onComplete, _onCancel = props.onCancel, onShippingChange = props.onShippingChange, onShippingAddressChange = props.onShippingAddressChange, onShippingOptionsChange = props.onShippingOptionsChange, locale = props.locale, commit = props.commit, _onError = props.onError, vault = props.vault, clientAccessToken = props.clientAccessToken, createBillingAgreement = props.createBillingAgreement, createSubscription = props.createSubscription, onClick = props.onClick, amount = props.amount, clientID = props.clientID, connect = props.connect, cmid = props.clientMetadataID, _onAuth = props.onAuth, userIDToken = props.userIDToken, env = props.env, currency = props.currency, enableFunding = props.enableFunding, stickinessID = props.stickinessID, standaloneFundingSource = props.standaloneFundingSource, branded = props.branded, paymentMethodToken = props.paymentMethodToken, allowBillingPayments = props.allowBillingPayments, merchantRequestedPopupsDisabled = props.merchantRequestedPopupsDisabled, disableSetCookie = props.disableSetCookie;
                var button = payment.button, win = payment.win, fundingSource = payment.fundingSource, card = payment.card, _payment$buyerAccessT = payment.buyerAccessToken, buyerAccessToken = void 0 === _payment$buyerAccessT ? serviceData.buyerAccessToken : _payment$buyerAccessT, venmoPayloadID = payment.venmoPayloadID, buyerIntent = payment.buyerIntent, checkoutRestart = payment.checkoutRestart;
                var buyerCountry = serviceData.buyerCountry, sdkMeta = serviceData.sdkMeta, merchantID = serviceData.merchantID;
                var cspNonce = config.cspNonce;
                var context = function(_ref4) {
                    var win = _ref4.win, isClick = _ref4.isClick, merchantRequestedPopupsDisabled = _ref4.merchantRequestedPopupsDisabled;
                    var popupSupported = Object(src.supportsPopups)();
                    Object(lib.getLogger)().info("spb_decide_context", {
                        merchantRequestedPopupsDisabled: Boolean(merchantRequestedPopupsDisabled),
                        isClick: Boolean(isClick),
                        popupSupported: Boolean(popupSupported)
                    });
                    return !merchantRequestedPopupsDisabled && win || !merchantRequestedPopupsDisabled && isClick && popupSupported ? constants.CONTEXT.POPUP : constants.CONTEXT.IFRAME;
                }({
                    win: win,
                    isClick: payment.isClick,
                    merchantRequestedPopupsDisabled: merchantRequestedPopupsDisabled
                });
                var connectEligible = function(_ref3) {
                    var fundingSource = _ref3.fundingSource;
                    return !(!_ref3.connect || _ref3.vault || fundingSource !== sdk_constants_src.FUNDING.PAYPAL && fundingSource !== sdk_constants_src.FUNDING.CREDIT || _ref3.createBillingAgreement || _ref3.createSubscription);
                }({
                    connect: connect,
                    createBillingAgreement: createBillingAgreement,
                    createSubscription: createSubscription,
                    vault: vault,
                    fundingSource: fundingSource
                });
                var approved = !1;
                var doApproveOnClose = !1;
                var forceClosed = !1;
                var instance;
                var close = function() {
                    return zalgo_promise_src.ZalgoPromise.try((function() {
                        if (instance) {
                            forceClosed = !0;
                            return instance.close();
                        }
                    }));
                };
                var start = Object(src.memoize)((function() {
                    var _experiments$popupInc;
                    return (instance = Checkout({
                        window: win,
                        sessionID: sessionID,
                        buttonSessionID: buttonSessionID,
                        stickinessID: stickinessID,
                        clientAccessToken: clientAccessToken,
                        venmoPayloadID: venmoPayloadID,
                        smokeHash: smokeHash,
                        createAuthCode: function() {
                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                var fundingSkipLogin = src_config.FUNDING_SKIP_LOGIN[fundingSource];
                                if (payment.createAccessToken) return payment.createAccessToken();
                                if (checkoutRestart && buyerAccessTokenReceivedOnAuth && fundingSkipLogin) return buyerAccessTokenReceivedOnAuth;
                                if (buyerAccessToken) return buyerAccessToken;
                                if (clientID && userIDToken && fundingSkipLogin) {
                                    var clientMetadataID = cmid || sessionID;
                                    var queryStringParams = disableSetCookie ? {
                                        disableSetCookie: disableSetCookie
                                    } : {};
                                    return Object(api.loadFraudnet)({
                                        env: env,
                                        clientMetadataID: clientMetadataID,
                                        cspNonce: cspNonce,
                                        queryStringParams: queryStringParams
                                    }).catch(src.noop).then((function() {
                                        var _headers;
                                        var headers = ((_headers = {})[constants.HEADERS.DISABLE_SET_COOKIE] = String(disableSetCookie), 
                                        _headers);
                                        return Object(api.getSmartWallet)({
                                            clientID: clientID,
                                            merchantID: merchantID,
                                            currency: currency,
                                            amount: amount,
                                            clientMetadataID: clientMetadataID,
                                            userIDToken: userIDToken,
                                            paymentMethodToken: paymentMethodToken,
                                            allowBillingPayments: allowBillingPayments,
                                            branded: branded,
                                            headers: headers
                                        });
                                    })).then((function(wallet) {
                                        var walletInstruments = wallet[fundingSkipLogin] && wallet[fundingSkipLogin].instruments;
                                        if (walletInstruments) for (var _i2 = 0; _i2 < walletInstruments.length; _i2++) {
                                            var instrument = walletInstruments[_i2];
                                            if (instrument.accessToken) return instrument.accessToken;
                                        }
                                    }));
                                }
                            })).then((function(accessToken) {
                                if (accessToken && (buyerIntent === constants.BUYER_INTENT.PAY || buyerIntent === constants.BUYER_INTENT.PAY_WITH_DIFFERENT_FUNDING_SHIPPING)) return Object(api.exchangeAccessTokenForAuthCode)(accessToken);
                            })).catch((function(err) {
                                Object(lib.getLogger)().warn("exchange_access_token_auth_code_error", {
                                    err: Object(src.stringifyError)(err)
                                });
                            }));
                        },
                        getConnectURL: connect && connectEligible ? function(_ref6) {
                            var payerID = _ref6.payerID;
                            if (!clientID) throw new Error("Expected clientID");
                            return _createOrder().then((function(orderID) {
                                return Object(api.getConnectURL)({
                                    orderID: orderID,
                                    payerID: payerID,
                                    clientID: clientID,
                                    fundingSource: fundingSource,
                                    connect: connect
                                }).then((function(connectURL) {
                                    var _getLogger$info$track;
                                    Object(lib.getLogger)().info("connect_redirect", {
                                        connectURL: connectURL
                                    }).track((_getLogger$info$track = {}, _getLogger$info$track[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                                    _getLogger$info$track[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.CONNECT_REDIRECT, 
                                    _getLogger$info$track[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = constants.FPTI_CONTEXT_TYPE.ORDER_ID, 
                                    _getLogger$info$track[sdk_constants_src.FPTI_KEY.TOKEN] = orderID, _getLogger$info$track[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = orderID, 
                                    _getLogger$info$track)).flush();
                                    return Object(src.extendUrl)(connectURL, {
                                        query: {
                                            sdkMeta: sdkMeta
                                        }
                                    });
                                })).catch((function(err) {
                                    Object(lib.getLogger)().error("connect_redirect_error", {
                                        err: Object(src.stringifyError)(err)
                                    });
                                    throw err;
                                }));
                            }));
                        } : null,
                        createOrder: function() {
                            buyerAccessTokenReceivedOnAuth = null;
                            return _createOrder().then((function(orderID) {
                                return orderID;
                            }));
                        },
                        onApprove: function(_temp) {
                            var _ref7 = void 0 === _temp ? {} : _temp, _ref7$approveOnClose = _ref7.approveOnClose, payerID = _ref7.payerID, paymentID = _ref7.paymentID, billingToken = _ref7.billingToken, subscriptionID = _ref7.subscriptionID, authCode = _ref7.authCode;
                            if (void 0 === _ref7$approveOnClose || !_ref7$approveOnClose) {
                                approved = !0;
                                Object(lib.getLogger)().info("spb_onapprove_access_token_" + (buyerAccessToken ? "present" : "not_present")).flush();
                                Object(lib.setBuyerAccessToken)(buyerAccessToken);
                                return _onApprove({
                                    payerID: payerID,
                                    paymentID: paymentID,
                                    billingToken: billingToken,
                                    subscriptionID: subscriptionID,
                                    buyerAccessToken: buyerAccessToken,
                                    authCode: authCode
                                }, {
                                    restart: restart
                                }).finally((function() {
                                    return close().then(src.noop);
                                })).catch(src.noop);
                            }
                            doApproveOnClose = !0;
                        },
                        onComplete: function() {
                            Object(lib.getLogger)().info("spb_oncomplete_access_token_" + (buyerAccessToken ? "present" : "not_present")).flush();
                            Object(lib.setBuyerAccessToken)(buyerAccessToken);
                            return _onComplete({
                                buyerAccessToken: buyerAccessToken
                            }).finally((function() {
                                return close().then(src.noop);
                            })).catch(src.noop);
                        },
                        onAuth: function(_ref8) {
                            return _onAuth({
                                accessToken: buyerAccessTokenReceivedOnAuth = _ref8.accessToken || buyerAccessToken
                            }).then((function(token) {
                                buyerAccessToken = token;
                            }));
                        },
                        onCancel: function() {
                            return close().then((function() {
                                return _onCancel();
                            }));
                        },
                        onShippingChange: onShippingChange ? function(data, actions) {
                            return onShippingChange(Object(esm_extends.default)({
                                buyerAccessToken: buyerAccessToken
                            }, data), actions);
                        } : null,
                        onShippingAddressChange: onShippingAddressChange ? function(data, actions) {
                            if (!data.shippingAddress) throw new Error("Must pass shippingAddress in data to handle changes in shipping address.");
                            return onShippingAddressChange(Object(esm_extends.default)({}, data), actions);
                        } : null,
                        onShippingOptionsChange: onShippingOptionsChange ? function(data, actions) {
                            if (!data.selectedShippingOption) throw new Error("Must pass selectedShippingOption in data to handle changes in shipping options.");
                            return onShippingOptionsChange(Object(esm_extends.default)({}, data), actions);
                        } : null,
                        onClose: function() {
                            return doApproveOnClose && !approved ? _onApprove({
                                forceRestAPI: !0
                            }, {
                                restart: restart
                            }).catch(src.noop) : forceClosed || approved ? void 0 : _onCancel();
                        },
                        onError: function(err) {
                            var _getLogger$info$track2;
                            Object(lib.getLogger)().info("checkout_flow_error ", {
                                err: Object(src.stringifyError)(err)
                            }).track((_getLogger$info$track2 = {}, _getLogger$info$track2[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                            _getLogger$info$track2[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.CHECKOUT_ERROR, 
                            _getLogger$info$track2[sdk_constants_src.FPTI_KEY.EVENT_NAME] = constants.FPTI_TRANSITION.CHECKOUT_ERROR, 
                            _getLogger$info$track2[sdk_constants_src.FPTI_KEY.ERROR_DESC] = Object(src.stringifyError)(err), 
                            _getLogger$info$track2)).flush();
                            return _onError(err);
                        },
                        dimensions: checkout_getDimensions(fundingSource, null != (_experiments$popupInc = null == experiments ? void 0 : experiments.popupIncreaseDimensions) && _experiments$popupInc),
                        fundingSource: fundingSource,
                        card: card,
                        buyerCountry: buyerCountry,
                        locale: locale,
                        commit: commit,
                        cspNonce: cspNonce,
                        clientMetadataID: cmid,
                        enableFunding: enableFunding,
                        standaloneFundingSource: standaloneFundingSource,
                        branded: branded,
                        restart: function() {
                            return fullRestart({
                                payment: Object(esm_extends.default)({}, payment, {
                                    win: win
                                })
                            });
                        }
                    })).renderTo(function() {
                        var top = Object(cross_domain_utils_src.getTop)(window);
                        return canRenderTop && top ? top : Object(cross_domain_utils_src.getParent)() ? Object(cross_domain_utils_src.getParent)() : window;
                    }(), constants.TARGET_ELEMENT.BODY, context);
                }));
                var restart = Object(src.memoize)((function() {
                    return close().finally((function() {
                        return initCheckout({
                            props: props,
                            components: components,
                            serviceData: serviceData,
                            config: config,
                            payment: {
                                button: button,
                                fundingSource: fundingSource,
                                card: card,
                                buyerIntent: buyerIntent,
                                isClick: !1,
                                checkoutRestart: !0
                            },
                            restart: restart
                        }).start().finally(lib.unresolvedPromise);
                    }));
                }));
                return {
                    click: function() {
                        return zalgo_promise_src.ZalgoPromise.try((function() {
                            if (!merchantRequestedPopupsDisabled && !win && Object(src.supportsPopups)()) try {
                                var _experiments$popupInc2;
                                var _getDimensions = checkout_getDimensions(fundingSource, null != (_experiments$popupInc2 = null == experiments ? void 0 : experiments.popupIncreaseDimensions) && _experiments$popupInc2);
                                win = openPopup({
                                    width: _getDimensions.width,
                                    height: _getDimensions.height
                                });
                            } catch (err) {
                                if (!(err instanceof src.PopupOpenError)) {
                                    Object(lib.getLogger)().warn("popup_open_error_blocked", {
                                        err: Object(src.stringifyError)(err)
                                    });
                                    Object(lib.sendCountMetric)({
                                        name: "pp.app.paypal_sdk.buttons.click.error.count",
                                        dimensions: {
                                            errorName: "checkout_blocked"
                                        }
                                    }).flush();
                                    throw err;
                                }
                                Object(lib.getLogger)().warn("popup_open_error_iframe_fallback", {
                                    err: Object(src.stringifyError)(err)
                                });
                                context = constants.CONTEXT.IFRAME;
                            }
                            if (onClick) return zalgo_promise_src.ZalgoPromise.try((function() {
                                return !onClick || onClick({
                                    fundingSource: fundingSource
                                });
                            })).then((function(valid) {
                                if (win && !valid) {
                                    Object(lib.sendCountMetric)({
                                        name: "pp.app.paypal_sdk.buttons.click.error.count",
                                        dimensions: {
                                            errorName: "invalid_funding_click"
                                        }
                                    }).flush();
                                    win.close();
                                }
                            }));
                            start();
                        }));
                    },
                    start: start,
                    close: close
                };
            },
            updateFlowClientConfig: function(_ref9) {
                var orderID = _ref9.orderID, payment = _ref9.payment, userExperienceFlow = _ref9.userExperienceFlow, featureFlags = _ref9.featureFlags;
                return zalgo_promise_src.ZalgoPromise.try((function() {
                    var buyerIntent = payment.buyerIntent, fundingSource = payment.fundingSource;
                    var updateClientConfigPromise = Object(api.updateButtonClientConfig)({
                        fundingSource: fundingSource,
                        orderID: orderID,
                        inline: !1,
                        userExperienceFlow: userExperienceFlow,
                        featureFlags: featureFlags
                    });
                    if (buyerIntent === constants.BUYER_INTENT.PAY_WITH_DIFFERENT_FUNDING_SHIPPING || featureFlags && featureFlags.isButtonClientConfigCallBlocking) return updateClientConfigPromise;
                }));
            }
        };
        var cardFormOpen = !1;
        function highlightCard(card) {
            card && Object(src.querySelectorAll)("[" + constants.DATA_ATTRIBUTES.CARD + "]").forEach((function(el) {
                el.style.opacity = el.getAttribute(constants.DATA_ATTRIBUTES.CARD) === card ? "1" : "0.1";
            }));
        }
        var card_form_getElements = function() {
            var buttonsContainer = document.querySelector("#buttons-container");
            var cardButtonsContainer = document.querySelector("[" + constants.DATA_ATTRIBUTES.FUNDING_SOURCE + '="' + sdk_constants_src.FUNDING.CARD + '"]');
            var cardFormContainer = document.querySelector("#card-fields-container");
            if (!buttonsContainer || !cardButtonsContainer || !cardFormContainer) throw new Error("Did not find card fields elements");
            return {
                buttonsContainer: buttonsContainer,
                cardButtonsContainer: cardButtonsContainer,
                cardFormContainer: cardFormContainer
            };
        };
        var resizeListener;
        var cardForm = {
            name: "card_form",
            setup: function() {},
            isEligible: function(_ref) {
                var props = _ref.props;
                return !props.vault && !props.onShippingChange && _ref.serviceData.eligibility.cardForm;
            },
            isPaymentEligible: function(_ref2) {
                var _ref3 = _ref2.payment || {}, fundingSource = _ref3.fundingSource;
                return !(_ref3.win || fundingSource && fundingSource !== sdk_constants_src.FUNDING.CARD);
            },
            init: function(_ref4) {
                var props = _ref4.props, components = _ref4.components, payment = _ref4.payment, serviceData = _ref4.serviceData, config = _ref4.config;
                var createOrder = props.createOrder, _onApprove = props.onApprove, _onCancel = props.onCancel, locale = props.locale, commit = props.commit, onError = props.onError, sessionID = props.sessionID, buttonSessionID = props.buttonSessionID, _onAuth = props.onAuth;
                var CardForm = components.CardForm;
                var fundingSource = payment.fundingSource, card = payment.card;
                var cspNonce = config.cspNonce;
                var buyerCountry = serviceData.buyerCountry;
                if (cardFormOpen) {
                    highlightCard(card);
                    return {
                        start: lib.promiseNoop,
                        close: lib.promiseNoop
                    };
                }
                var restart = Object(src.memoize)((function() {
                    return checkout.init({
                        props: props,
                        components: components,
                        payment: Object(esm_extends.default)({}, payment, {
                            isClick: !1
                        }),
                        serviceData: serviceData,
                        config: config,
                        restart: restart
                    }).start().finally(lib.unresolvedPromise);
                }));
                var buyerAccessToken;
                var _CardForm = CardForm({
                    createOrder: createOrder,
                    fundingSource: fundingSource,
                    card: card,
                    onApprove: function(_ref6) {
                        var payerID = _ref6.payerID, paymentID = _ref6.paymentID, billingToken = _ref6.billingToken;
                        return close().then((function() {
                            return _onApprove({
                                payerID: payerID,
                                paymentID: paymentID,
                                billingToken: billingToken,
                                buyerAccessToken: buyerAccessToken
                            }, {
                                restart: restart
                            }).catch(src.noop);
                        }));
                    },
                    onAuth: function(_ref7) {
                        return _onAuth({
                            accessToken: _ref7.accessToken || buyerAccessToken
                        }).then((function(token) {
                            buyerAccessToken = token;
                        }));
                    },
                    onCancel: function() {
                        return close().then((function() {
                            return _onCancel();
                        }));
                    },
                    onError: onError,
                    onClose: function() {
                        cardFormOpen = !1;
                    },
                    onCardTypeChange: function(_ref5) {
                        highlightCard(_ref5.card);
                    },
                    sessionID: sessionID,
                    buttonSessionID: buttonSessionID,
                    buyerCountry: buyerCountry,
                    locale: locale,
                    commit: commit,
                    cspNonce: cspNonce
                }), render = _CardForm.render, closeCardForm = _CardForm.close;
                var close = function() {
                    !function() {
                        var buttonsContainer = card_form_getElements().buttonsContainer;
                        Object(src.querySelectorAll)("[" + constants.DATA_ATTRIBUTES.CARD + "]").forEach((function(el) {
                            el.style.opacity = "1";
                        }));
                        window.removeEventListener("resize", resizeListener);
                        buttonsContainer.style.removeProperty("transition-duration");
                        buttonsContainer.style.removeProperty("margin-top");
                    }();
                    return closeCardForm().then((function() {
                        cardFormOpen = !1;
                    }));
                };
                return {
                    start: function() {
                        cardFormOpen = !0;
                        var renderPromise = render("#card-fields-container");
                        !function() {
                            var _getElements = card_form_getElements(), buttonsContainer = _getElements.buttonsContainer, cardButtonsContainer = _getElements.cardButtonsContainer, cardFormContainer = _getElements.cardFormContainer;
                            if (!buttonsContainer || !cardButtonsContainer || !cardFormContainer) throw new Error("Required elements not found");
                            cardFormContainer.style.minHeight = "0px";
                            cardFormContainer.style.display = "block";
                            var recalculateMargin = function() {
                                buttonsContainer.style.marginTop = buttonsContainer.offsetTop - cardButtonsContainer.offsetTop + "px";
                            };
                            resizeListener = Object(src.debounce)((function() {
                                buttonsContainer.style.transitionDuration = "0s";
                                recalculateMargin();
                            }));
                            window.addEventListener("resize", resizeListener);
                            recalculateMargin();
                        }();
                        highlightCard(card);
                        return renderPromise;
                    },
                    close: close
                };
            },
            inline: !0
        };
        var src_props = __webpack_require__("./src/props/index.js");
        var paymentFieldsOpen = !1;
        var payment_fields_getElements = function(fundingSource) {
            var buttonsContainer = document.querySelector("#buttons-container");
            var fundingSourceButtonsContainer;
            fundingSource && (fundingSourceButtonsContainer = document.querySelector("[" + constants.DATA_ATTRIBUTES.FUNDING_SOURCE + '="' + fundingSource + '"]'));
            var paymentFieldsContainer = document.querySelector("#payment-fields-container");
            if (!buttonsContainer || !fundingSourceButtonsContainer || !paymentFieldsContainer) throw new Error("Did not find payment fields elements");
            return {
                buttonsContainer: buttonsContainer,
                fundingSourceButtonsContainer: fundingSourceButtonsContainer,
                paymentFieldsContainer: paymentFieldsContainer
            };
        };
        var payment_fields_resizeListener;
        var payment_fields_slideDownButtons = function(fundingSource) {
            var _getElements2 = payment_fields_getElements(fundingSource), buttonsContainer = _getElements2.buttonsContainer, paymentFieldsContainer = _getElements2.paymentFieldsContainer;
            Object(src.querySelectorAll)("[" + constants.DATA_ATTRIBUTES.FUNDING_SOURCE + "]").forEach((function(el) {
                el.style.display = "";
            }));
            window.removeEventListener("resize", payment_fields_resizeListener);
            buttonsContainer.style.removeProperty("transition-duration");
            buttonsContainer.style.removeProperty("margin-top");
            paymentFieldsContainer.style.removeProperty("transition-duration");
            paymentFieldsContainer.style.removeProperty("margin-top");
        };
        var paymentFields = {
            name: "payment_fields",
            setup: function() {},
            isEligible: function(_ref) {
                var props = _ref.props;
                var eligibility = _ref.serviceData.eligibility;
                var componentsList = window.xprops.components || [];
                return !props.vault && !props.onShippingChange && (!componentsList.includes("marks") || !componentsList.includes("payment-fields")) && eligibility.paymentFields.isInlineEnabled;
            },
            isPaymentEligible: function(_ref2) {
                var _ref3 = _ref2.payment || {}, fundingSource = _ref3.fundingSource;
                return !(_ref3.win || fundingSource && !(_ref2.serviceData.eligibility.paymentFields.inlineEligibleAPMs || []).includes(fundingSource));
            },
            init: function initPaymentFields(_ref4) {
                var props = _ref4.props, components = _ref4.components, payment = _ref4.payment, serviceData = _ref4.serviceData, config = _ref4.config;
                var createOrder = props.createOrder, _onApprove = props.onApprove, _onCancel = props.onCancel, locale = props.locale, commit = props.commit, onError = props.onError, sessionID = props.sessionID, partnerAttributionID = props.partnerAttributionID, buttonSessionID = props.buttonSessionID, _onAuth = props.onAuth, stickinessID = props.stickinessID, onShippingChange = props.onShippingChange, onShippingAddressChange = props.onShippingAddressChange, onShippingOptionsChange = props.onShippingOptionsChange, clientMetadataID = props.clientMetadataID, enableFunding = props.enableFunding, _onComplete = props.onComplete;
                var PaymentFields = components.PaymentFields, Checkout = components.Checkout;
                var fundingSource = payment.fundingSource, card = payment.card;
                var cspNonce = config.cspNonce;
                var buyerCountry = serviceData.buyerCountry, sdkMeta = serviceData.sdkMeta;
                Object(lib.getLogger)().info("spb_payment_flow_init_payment_fields", {
                    buttonSessionID: buttonSessionID,
                    fundingSource: fundingSource
                });
                if (paymentFieldsOpen) return {
                    start: lib.promiseNoop,
                    close: lib.promiseNoop
                };
                var instance;
                var approved = !1;
                var forceClosed = !1;
                var restart = Object(src.memoize)((function() {
                    return close().finally((function() {
                        return initPaymentFields({
                            props: props,
                            components: components,
                            serviceData: serviceData,
                            config: config,
                            payment: Object(esm_extends.default)({}, payment),
                            restart: restart
                        }).start().finally(lib.unresolvedPromise);
                    }));
                }));
                var buyerAccessToken;
                var _PaymentFields = PaymentFields({
                    createOrder: createOrder,
                    fundingSource: fundingSource,
                    onContinue: function(data) {
                        return createOrder().then((function(orderID) {
                            return Object(src_props.getConfirmOrder)({
                                orderID: orderID,
                                payload: data,
                                partnerAttributionID: partnerAttributionID
                            }, {
                                facilitatorAccessToken: serviceData.facilitatorAccessToken
                            }).then((function() {
                                Object(lib.getLogger)().info("spb_payment_fields_rendering_checkout_instance", {
                                    orderID: orderID
                                });
                                (instance = Checkout({
                                    onClose: function() {
                                        if (!forceClosed && !approved) return close().then((function() {
                                            return _onCancel();
                                        }));
                                    },
                                    onApprove: function(_ref5) {
                                        var payerID = _ref5.payerID, paymentID = _ref5.paymentID, billingToken = _ref5.billingToken;
                                        approved = !0;
                                        return close().then((function() {
                                            return _onApprove({
                                                payerID: payerID,
                                                paymentID: paymentID,
                                                billingToken: billingToken,
                                                buyerAccessToken: buyerAccessToken
                                            }, {
                                                restart: restart
                                            }).catch(src.noop);
                                        }));
                                    },
                                    branded: !1,
                                    standaloneFundingSource: fundingSource,
                                    onCancel: function() {
                                        return close().then((function() {
                                            return _onCancel();
                                        }));
                                    },
                                    onAuth: function(_ref6) {
                                        return _onAuth({
                                            accessToken: _ref6.accessToken || buyerAccessToken
                                        }).then((function(token) {
                                            buyerAccessToken = token;
                                        }));
                                    },
                                    buttonSessionID: buttonSessionID,
                                    stickinessID: stickinessID,
                                    onComplete: function() {
                                        return _onComplete({
                                            buyerAccessToken: buyerAccessToken
                                        }).finally((function() {
                                            return close().then(src.noop);
                                        })).catch(src.noop);
                                    },
                                    onShippingChange: onShippingChange,
                                    onShippingAddressChange: onShippingAddressChange,
                                    onShippingOptionsChange: onShippingOptionsChange,
                                    restart: restart,
                                    createOrder: createOrder,
                                    card: card,
                                    clientMetadataID: clientMetadataID,
                                    enableFunding: enableFunding,
                                    dimensions: checkout_getDimensions(fundingSource),
                                    onError: onError,
                                    sessionID: sessionID,
                                    fundingSource: fundingSource,
                                    buyerCountry: buyerCountry,
                                    locale: locale,
                                    commit: commit,
                                    cspNonce: cspNonce,
                                    smokeHash: ""
                                })).renderTo(function() {
                                    Object(cross_domain_utils_src.getTop)(window);
                                    return Object(cross_domain_utils_src.getParent)() ? Object(cross_domain_utils_src.getParent)() : window;
                                }(), constants.TARGET_ELEMENT.BODY, constants.CONTEXT.POPUP);
                            })).catch((function(err) {
                                Object(lib.getLogger)().error("payment_fields_confirm_order_error", {
                                    err: Object(src.stringifyError)(err)
                                });
                                throw err;
                            }));
                        }));
                    },
                    onFieldsClose: function() {
                        return closePaymentFields().then((function() {
                            paymentFieldsOpen = !1;
                            payment_fields_slideDownButtons(fundingSource);
                        }));
                    },
                    onError: onError,
                    onClose: function() {
                        paymentFieldsOpen = !1;
                    },
                    showActionButtons: !0,
                    sdkMeta: sdkMeta,
                    sessionID: sessionID,
                    buttonSessionID: buttonSessionID,
                    buyerCountry: buyerCountry,
                    locale: locale,
                    commit: commit,
                    cspNonce: cspNonce
                }), render = _PaymentFields.render, closePaymentFields = _PaymentFields.close;
                var close = function() {
                    return closePaymentFields().then((function() {
                        forceClosed = !0;
                        paymentFieldsOpen = !1;
                        instance && instance.close();
                        payment_fields_slideDownButtons(fundingSource);
                    }));
                };
                return {
                    start: function() {
                        paymentFieldsOpen = !0;
                        var renderPromise = render("#payment-fields-container");
                        !function(fundingSource) {
                            var _getElements = payment_fields_getElements(fundingSource), buttonsContainer = _getElements.buttonsContainer, fundingSourceButtonsContainer = _getElements.fundingSourceButtonsContainer, paymentFieldsContainer = _getElements.paymentFieldsContainer;
                            if (!buttonsContainer || !fundingSourceButtonsContainer || !paymentFieldsContainer) throw new Error("Required elements not found");
                            paymentFieldsContainer.style.minHeight = "0px";
                            paymentFieldsContainer.style.display = "block";
                            var recalculateMargin = function() {
                                buttonsContainer.style.marginTop = buttonsContainer.offsetTop - fundingSourceButtonsContainer.offsetTop + "px";
                                paymentFieldsContainer.style.marginTop = buttonsContainer.offsetTop - (fundingSourceButtonsContainer.offsetTop + fundingSourceButtonsContainer.offsetHeight) + "px";
                            };
                            payment_fields_resizeListener = Object(src.debounce)((function() {
                                buttonsContainer.style.transitionDuration = "0s";
                                paymentFieldsContainer.style.transitionDuration = "0s";
                                recalculateMargin();
                            }));
                            window.addEventListener("resize", payment_fields_resizeListener);
                            recalculateMargin();
                        }(fundingSource);
                        !function(fundingSource) {
                            fundingSource && Object(src.querySelectorAll)("[" + constants.DATA_ATTRIBUTES.FUNDING_SOURCE + "]").forEach((function(el) {
                                el.getAttribute(constants.DATA_ATTRIBUTES.FUNDING_SOURCE) === fundingSource.toLowerCase() ? el.style.opacity = "1" : el.style.display = "none";
                            }));
                        }(fundingSource);
                        return renderPromise;
                    },
                    close: close
                };
            },
            inline: !0
        };
        var dist = __webpack_require__("./node_modules/card-validator/dist/index.js");
        var dist_default = __webpack_require__.n(dist);
        var _CARD_FIELD_TYPE_TO_F, _VALIDATOR_TO_TYPE_MA;
        var types = dist_default.a.creditCardType.types;
        (_CARD_FIELD_TYPE_TO_F = {}).single = constants.FRAME_NAME.CARD_FIELD, _CARD_FIELD_TYPE_TO_F.number = constants.FRAME_NAME.CARD_NUMBER_FIELD, 
        _CARD_FIELD_TYPE_TO_F.cvv = constants.FRAME_NAME.CARD_CVV_FIELD, _CARD_FIELD_TYPE_TO_F.expiry = constants.FRAME_NAME.CARD_EXPIRY_FIELD, 
        _CARD_FIELD_TYPE_TO_F.name = constants.FRAME_NAME.CARD_NAME_FIELD, _CARD_FIELD_TYPE_TO_F.postal = constants.FRAME_NAME.CARD_POSTAL_FIELD;
        var VALIDATOR_TO_TYPE_MAP = ((_VALIDATOR_TO_TYPE_MA = {})[types.AMERICAN_EXPRESS] = sdk_constants_src.CARD.AMEX, 
        _VALIDATOR_TO_TYPE_MA[types.DISCOVER] = sdk_constants_src.CARD.DISCOVER, _VALIDATOR_TO_TYPE_MA[types.ELO] = sdk_constants_src.CARD.ELO, 
        _VALIDATOR_TO_TYPE_MA[types.HIPER] = sdk_constants_src.CARD.HIPER, _VALIDATOR_TO_TYPE_MA[types.JCB] = sdk_constants_src.CARD.JCB, 
        _VALIDATOR_TO_TYPE_MA[types.MASTERCARD] = sdk_constants_src.CARD.MASTERCARD, _VALIDATOR_TO_TYPE_MA[types.UNIONPAY] = sdk_constants_src.CARD.CUP, 
        _VALIDATOR_TO_TYPE_MA[types.VISA] = sdk_constants_src.CARD.VISA, _VALIDATOR_TO_TYPE_MA);
        __webpack_require__("./node_modules/@krakenjs/belter/index.js");
        function cardExpiryToPaymentSourceExpiry(dateString) {
            if (!dateString || "string" != typeof dateString) throw new Error("can not convert invalid expiry date: " + dateString);
            if (dateString.match("^[0-9]{4}-([1-9]|0[1-9]|1[0-2])$")) return dateString;
            if (dateString.match("^([1-9]|0[1-9]|1[0-2])/?([0-9]{4}|[0-9]{2})$")) {
                var _dateString$split = dateString.split("/"), monthString = _dateString$split[0], yearString = _dateString$split[1];
                return (2 === yearString.length ? "20" + yearString : yearString) + "-" + (1 === monthString.length ? "0" + monthString : monthString);
            }
            throw new Error("can not convert invalid expiry date: " + dateString);
        }
        function convertCardToPaymentSource(card, extraFields) {
            var paymentSource = {
                card: {
                    number: card.number,
                    securityCode: card.cvv,
                    expiry: cardExpiryToPaymentSourceExpiry(card.expiry)
                }
            };
            extraFields && 0 !== Object.keys(extraFields).length && (paymentSource.card.billingAddress = extraFields.billingAddress);
            card.name && (paymentSource.card.name = card.name);
            card.postalCode && (paymentSource.card.billingAddress = {
                postalCode: card.postalCode
            });
            return paymentSource;
        }
        function reformatBillingKeys(str) {
            return str.replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/([a-z\d])(\d)/g, "$1_$2").toLowerCase();
        }
        dist_default.a.creditCardType.addCard({
            code: {
                name: "CVV",
                size: 3
            },
            gaps: [ 4, 8, 12 ],
            lengths: [ 16, 18, 19 ],
            niceType: "Carte Bancaire",
            patterns: [],
            type: "cb-nationale"
        });
        dist_default.a.creditCardType.addCard({
            code: {
                name: "CVV",
                size: 3
            },
            gaps: [ 4, 8, 12, 16 ],
            lengths: [ 19 ],
            niceType: "Carte Aurore",
            patterns: [],
            type: "cetelem"
        });
        dist_default.a.creditCardType.addCard({
            code: {
                name: "",
                size: 0
            },
            gaps: [ 4, 8, 12, 16 ],
            lengths: [ 17 ],
            niceType: "Cofinoga ou Privilège",
            patterns: [],
            type: "cofinoga"
        });
        dist_default.a.creditCardType.addCard({
            code: {
                name: "",
                size: 0
            },
            gaps: [ 4, 8 ],
            lengths: [ 8, 9 ],
            niceType: "4 étoiles",
            patterns: [],
            type: "cofidis"
        });
        function getExportsByFrameName(name) {
            try {
                for (var _i2 = 0, _getAllFramesInWindow2 = Object(cross_domain_utils_src.getAllFramesInWindow)(window); _i2 < _getAllFramesInWindow2.length; _i2++) {
                    var win = _getAllFramesInWindow2[_i2];
                    if (Object(cross_domain_utils_src.isSameDomain)(win) && win.exports && win.exports.name === name) return win.exports;
                }
            } catch (err) {}
        }
        function getCardFrames() {
            return {
                cardFrame: getExportsByFrameName(constants.FRAME_NAME.CARD_FIELD),
                cardNumberFrame: getExportsByFrameName(constants.FRAME_NAME.CARD_NUMBER_FIELD),
                cardCVVFrame: getExportsByFrameName(constants.FRAME_NAME.CARD_CVV_FIELD),
                cardExpiryFrame: getExportsByFrameName(constants.FRAME_NAME.CARD_EXPIRY_FIELD),
                cardNameFrame: getExportsByFrameName(constants.FRAME_NAME.CARD_NAME_FIELD),
                cardPostalFrame: getExportsByFrameName(constants.FRAME_NAME.CARD_POSTAL_FIELD)
            };
        }
        function hasCardFields() {
            var _getCardFrames = getCardFrames();
            return Boolean(_getCardFrames.cardFrame || _getCardFrames.cardNumberFrame && _getCardFrames.cardCVVFrame && _getCardFrames.cardExpiryFrame);
        }
        var createVaultSetupToken_getCreateVaultSetupToken = function(_ref) {
            var createVaultSetupToken = _ref.createVaultSetupToken;
            if (createVaultSetupToken) return Object(src.memoize)((function() {
                return createVaultSetupToken({
                    paymentSource: sdk_constants_src.FUNDING.CARD
                }).then((function(vaultSetupToken) {
                    if (!vaultSetupToken || "string" != typeof vaultSetupToken) throw new Error("Expected a vault setup token to be returned from createVaultSetupToken");
                    return vaultSetupToken;
                }));
            }));
        };
        function getCreateOrder(_ref) {
            var createOrder = _ref.createOrder;
            if (createOrder) return Object(src.memoize)((function() {
                return zalgo_promise_src.ZalgoPromise.try((function() {
                    return createOrder({
                        paymentSource: sdk_constants_src.FUNDING.CARD
                    });
                })).then((function(orderID) {
                    if (!orderID || "string" != typeof orderID) throw new Error("Expected an order id to be passed");
                    if (orderID.includes("PAY-") || orderID.includes("PAYID-")) throw new Error("Do not pass PAY-XXX or PAYID-XXX directly into createOrder. Pass the EC-XXX token instead");
                    return orderID;
                }));
            }));
        }
        function props_getComponents() {
            return {
                ThreeDomainSecure: paypal.ThreeDomainSecure
            };
        }
        var logger_threeDsAuthStatus = function(_ref8) {
            var authStatus = _ref8.authStatus;
            Object(lib.getLogger)().addTrackingBuilder((function() {
                var _ref9;
                return (_ref9 = {})["3ds_auth_status"] = authStatus, _ref9;
            }));
        };
        var lib_logger = __webpack_require__("./src/lib/logger.js");
        function handleThreeDomainSecureRedirect(_ref) {
            var ThreeDomainSecure = _ref.ThreeDomainSecure, vaultToken = _ref.vaultToken, createOrder = _ref.createOrder, action = _ref.action, getParent = _ref.getParent;
            var promise = new zalgo_promise_src.ZalgoPromise;
            var instance = ThreeDomainSecure({
                vaultToken: vaultToken,
                createOrder: createOrder,
                action: action,
                onSuccess: function(data) {
                    logger_threeDsAuthStatus({
                        authStatus: "success"
                    });
                    return promise.resolve(data);
                },
                onCancel: function() {
                    logger_threeDsAuthStatus({
                        authStatus: "cancelled"
                    });
                    return promise.reject(new Error("3DS cancelled"));
                },
                onError: function(err) {
                    logger_threeDsAuthStatus({
                        authStatus: "failure"
                    });
                    return promise.reject(err);
                }
            });
            return instance.renderTo(getParent(), constants.TARGET_ELEMENT.BODY).then((function() {
                return promise;
            })).finally(instance.close);
        }
        function handleThreeDomainSecureContingency(_ref2) {
            var status = _ref2.status, links = _ref2.links, ThreeDomainSecure = _ref2.ThreeDomainSecure, createOrder = _ref2.createOrder, getParent = _ref2.getParent, paymentFlow = _ref2.paymentFlow, fundingSource = _ref2.fundingSource;
            return zalgo_promise_src.ZalgoPromise.try((function() {
                if ("PAYER_ACTION_REQUIRED" === status && links.some((function(link) {
                    return function(link) {
                        return "payer-action" === link.rel && link.href && link.href.includes("flow=3ds");
                    }(link) || function(link) {
                        return "approve" === link.rel && link.href.includes("helios");
                    }(link);
                }))) {
                    var contingency = "confirm_payment_source_three_ds_contingency";
                    "vault-capture" === paymentFlow ? Object(lib_logger.sendCountMetric)({
                        name: "pp.app.paypal_sdk.buttons.vault_capture.contingency.count",
                        dimensions: {
                            fundingSource: fundingSource,
                            contingency: contingency
                        }
                    }) : Object(lib_logger.sendCountMetric)({
                        name: "pp.app.paypal_sdk.card_fields.submit.contingency.count",
                        dimensions: {
                            paymentFlow: paymentFlow,
                            contingency: contingency
                        }
                    });
                    var _getThreeDSParams = function(links) {
                        var helioslink = links.find((function(link) {
                            return link.href.includes("helios");
                        }));
                        var linkUrl = new URL(null == helioslink ? void 0 : helioslink.href);
                        return {
                            vaultToken: linkUrl.searchParams.get("token"),
                            action: linkUrl.searchParams.get("action")
                        };
                    }(links);
                    return handleThreeDomainSecureRedirect({
                        ThreeDomainSecure: ThreeDomainSecure,
                        createOrder: createOrder,
                        vaultToken: _getThreeDSParams.vaultToken,
                        getParent: getParent,
                        action: _getThreeDSParams.action
                    });
                }
            }));
        }
        var api_vault = __webpack_require__("./src/api/vault.js");
        var cardField = {
            name: "card_field",
            setup: function() {},
            isEligible: function(_ref) {
                var props = _ref.props;
                return !props.vault && !(props.onShippingChange || props.onShippingAddressChange || props.onShippingOptionsChange);
            },
            isPaymentEligible: function(_ref2) {
                var _ref3 = _ref2.payment || {}, fundingSource = _ref3.fundingSource;
                return !(_ref3.win || fundingSource && fundingSource !== sdk_constants_src.FUNDING.CARD || !hasCardFields());
            },
            init: function(_ref4) {
                var serviceData = _ref4.serviceData;
                var facilitatorAccessToken = serviceData.facilitatorAccessToken;
                return {
                    click: function() {},
                    start: function() {
                        return function(_ref) {
                            var facilitatorAccessToken = _ref.facilitatorAccessToken, extraFields = _ref.extraFields, experiments = _ref.experiments;
                            var cardProps = function(_ref2) {
                                var _fundingEligibility$c, _fundingEligibility$c2;
                                var facilitatorAccessToken = _ref2.facilitatorAccessToken;
                                if (!_ref2.experiments.hostedCardFields) throw new Error("Not feature flagged to use CardFields");
                                var xprops = window.xprops;
                                var fundingEligibility = xprops.fundingEligibility, _xprops$branded = xprops.branded, branded = void 0 === _xprops$branded ? null == (_fundingEligibility$c = null == fundingEligibility || null == (_fundingEligibility$c2 = fundingEligibility.card) ? void 0 : _fundingEligibility$c2.branded) || _fundingEligibility$c : _xprops$branded, parent = xprops.parent, createVaultSetupToken = xprops.createVaultSetupToken, createOrder = xprops.createOrder;
                                var returnData = {
                                    type: xprops.type,
                                    branded: branded,
                                    style: xprops.style,
                                    placeholder: xprops.placeholder,
                                    minLength: xprops.minLength,
                                    maxLength: xprops.maxLength,
                                    cardSessionID: xprops.cardSessionID,
                                    fundingEligibility: fundingEligibility,
                                    inputEvents: xprops.inputEvents,
                                    export: parent ? parent.export : xprops.export,
                                    facilitatorAccessToken: facilitatorAccessToken,
                                    sdkCorrelationID: xprops.sdkCorrelationID,
                                    partnerAttributionID: xprops.partnerAttributionID,
                                    hcfSessionID: xprops.hcfSessionID,
                                    userIDToken: xprops.userIDToken
                                };
                                var baseProps = Object(src_props.getProps)({
                                    branded: branded
                                });
                                if (createVaultSetupToken && createOrder) throw new Error("Cannot pass both createVaultSetupToken and createOrder");
                                if (!createVaultSetupToken && !createOrder) throw new Error("Must pass either createVaultSetupToken or createOrder");
                                if (createVaultSetupToken && (null == xprops || !xprops.onApprove)) throw new Error("onApprove is required when saving card fields");
                                return Object(esm_extends.default)({}, baseProps, returnData, {
                                    createOrder: getCreateOrder({
                                        createOrder: xprops.createOrder
                                    }),
                                    createVaultSetupToken: createVaultSetupToken_getCreateVaultSetupToken({
                                        createVaultSetupToken: xprops.createVaultSetupToken
                                    }),
                                    onApprove: xprops.onApprove,
                                    onError: xprops.onError,
                                    productAction: (_ref = {
                                        createOrder: xprops.createOrder,
                                        createVaultSetupToken: xprops.createVaultSetupToken
                                    }, _ref.createOrder ? constants.PAYMENT_FLOWS.WITH_PURCHASE : _ref.createVaultSetupToken ? constants.PAYMENT_FLOWS.VAULT_WITHOUT_PURCHASE : "unknown")
                                });
                                var _ref;
                            }({
                                facilitatorAccessToken: facilitatorAccessToken,
                                featureFlags: _ref.featureFlags,
                                experiments: experiments
                            });
                            experiments.useIDToken && (cardProps.userIDToken ? facilitatorAccessToken = cardProps.userIDToken : Object(lib_logger.getLogger)().info("hcf_userIDToken_present_false"));
                            !function(_ref10) {
                                var _getLogger$track5;
                                var cardFlowType = _ref10.cardFlowType, hcfSessionID = _ref10.hcfSessionID;
                                Object(lib.sendCountMetric)({
                                    name: "pp.app.paypal_sdk.card_fields.submit.count",
                                    dimensions: {
                                        cardFieldsFlow: cardFlowType
                                    }
                                });
                                Object(lib.getLogger)().track(((_getLogger$track5 = {})[sdk_constants_src.FPTI_KEY.TRANSITION] = "hcf_fields_submit", 
                                _getLogger$track5[sdk_constants_src.FPTI_KEY.EVENT_NAME] = "hcf_fields_submit", 
                                _getLogger$track5[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = "hosted_session_id", 
                                _getLogger$track5[sdk_constants_src.FPTI_KEY.PAYMENT_FLOW] = cardFlowType, _getLogger$track5[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = hcfSessionID, 
                                _getLogger$track5));
                            }({
                                cardFlowType: cardProps.productAction,
                                hcfSessionID: cardProps.hcfSessionID
                            });
                            !function() {
                                var _getCardFrames = getCardFrames(), cardFrame = _getCardFrames.cardFrame, cardNumberFrame = _getCardFrames.cardNumberFrame, cardExpiryFrame = _getCardFrames.cardExpiryFrame, cardCVVFrame = _getCardFrames.cardCVVFrame;
                                cardFrame && cardFrame.resetGQLErrors();
                                cardNumberFrame && cardNumberFrame.resetGQLErrors();
                                cardExpiryFrame && cardExpiryFrame.resetGQLErrors();
                                cardCVVFrame && cardCVVFrame.resetGQLErrors();
                            }();
                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                if (!hasCardFields()) throw new Error("Card fields not available to submit");
                                var card = function(productAction) {
                                    var card = {};
                                    var cardFrame = getExportsByFrameName(constants.FRAME_NAME.CARD_FIELD);
                                    if (cardFrame && cardFrame.isFieldValid()) return cardFrame.getFieldValue();
                                    var _getCardFrames = getCardFrames(), cardNumberFrame = _getCardFrames.cardNumberFrame, cardCVVFrame = _getCardFrames.cardCVVFrame, cardExpiryFrame = _getCardFrames.cardExpiryFrame, cardNameFrame = _getCardFrames.cardNameFrame, cardPostalFrame = _getCardFrames.cardPostalFrame;
                                    if (!cardNumberFrame || !cardNumberFrame.isFieldValid()) throw new Error("INVALID_NUMBER");
                                    var cardNumber = cardNumberFrame.getFieldValue();
                                    if (!function(cardNumber, cardType, productAction) {
                                        var _fundingEligibility$c;
                                        var fundingEligibility = window.xprops.fundingEligibility;
                                        var type = VALIDATOR_TO_TYPE_MAP[cardType.type];
                                        var isVaultFlow = productAction === constants.PAYMENT_FLOWS.VAULT_WITHOUT_PURCHASE;
                                        if (0 === cardNumber.length) return !0;
                                        if (null != fundingEligibility && null != (_fundingEligibility$c = fundingEligibility.card) && _fundingEligibility$c.eligible && type && fundingEligibility.card.vendors && !fundingEligibility.card.branded) {
                                            var vendor = fundingEligibility.card.vendors[type];
                                            if (isVaultFlow && null != vendor && vendor.vaultable && null != vendor && vendor.eligible) return !0;
                                            if (!isVaultFlow && null != vendor && vendor.eligible) return !0;
                                        }
                                        return !1;
                                    }(cardNumber, cardNumberFrame.getPotentialCardTypes()[0], productAction)) throw new Error("INELIGIBLE_CARD_VENDOR");
                                    card.number = cardNumber;
                                    if (!cardCVVFrame || !cardCVVFrame.isFieldValid()) throw new Error("INVALID_CVV");
                                    card.cvv = cardCVVFrame.getFieldValue();
                                    if (!cardExpiryFrame || !cardExpiryFrame.isFieldValid()) throw new Error("INVALID_EXPIRY");
                                    card.expiry = cardExpiryFrame.getFieldValue();
                                    if (cardNameFrame) {
                                        var cardNameValue = cardNameFrame.getFieldValue();
                                        if (cardNameFrame.isFieldValid()) card.name = cardNameValue; else if (0 !== cardNameValue.length) throw new Error("INVALID_NAME");
                                    }
                                    if (cardPostalFrame) {
                                        var postalCodeValue = cardPostalFrame.getFieldValue();
                                        if (cardPostalFrame.isFieldValid()) card.name = postalCodeValue; else if (0 !== postalCodeValue.length) throw new Error("INVALID_POSTAL");
                                    }
                                    return card;
                                }(cardProps.productAction);
                                switch (cardProps.productAction) {
                                  case constants.PAYMENT_FLOWS.WITH_PURCHASE:
                                    return function(cardProps, card, extraFields, facilitatorAccessToken) {
                                        var orderID;
                                        var ThreeDomainSecure = props_getComponents().ThreeDomainSecure;
                                        var createOrder = cardProps.createOrder, getParent = cardProps.getParent, productAction = cardProps.productAction;
                                        return cardProps.createOrder().then((function(id) {
                                            var payment_source = convertCardToPaymentSource(card, extraFields);
                                            var data = {
                                                payment_source: {
                                                    card: (paymentSource = payment_source.card, Object.keys(paymentSource).reduce((function(newObj, key) {
                                                        var transformedKey = reformatBillingKeys(key);
                                                        if ("billingAddress" === key) {
                                                            if (paymentSource.billingAddress && 0 !== Object.keys(paymentSource.billingAddress).length) {
                                                                newObj.billing_address = {};
                                                                Object.keys(paymentSource.billingAddress).forEach((function(billingKey) {
                                                                    var snakeCaseBillingKey = reformatBillingKeys(billingKey);
                                                                    newObj.billing_address[snakeCaseBillingKey] = paymentSource.billingAddress[billingKey];
                                                                }));
                                                            }
                                                        } else newObj[transformedKey] = paymentSource[key];
                                                        return newObj;
                                                    }), {}))
                                                }
                                            };
                                            var paymentSource;
                                            orderID = id;
                                            return Object(api.confirmOrderAPI)(orderID, data, {
                                                facilitatorAccessToken: facilitatorAccessToken,
                                                partnerAttributionID: "",
                                                experiments: {}
                                            });
                                        })).then((function(res) {
                                            return handleThreeDomainSecureContingency({
                                                status: res.status,
                                                links: res.links,
                                                ThreeDomainSecure: ThreeDomainSecure,
                                                createOrder: createOrder,
                                                getParent: getParent,
                                                paymentFlow: productAction
                                            });
                                        })).then((function(threeDsResponse) {
                                            return cardProps.onApprove({
                                                orderID: orderID,
                                                liabilityShift: null == threeDsResponse ? void 0 : threeDsResponse.liability_shift
                                            }, {});
                                        })).then((function() {
                                            !function(_ref4) {
                                                var _getLogger$track;
                                                var orderID = _ref4.orderID;
                                                Object(lib.sendCountMetric)({
                                                    name: "pp.app.paypal_sdk.card_fields.submit.success.count",
                                                    dimensions: {
                                                        cardFieldsFlow: constants.PAYMENT_FLOWS.WITH_PURCHASE
                                                    }
                                                });
                                                Object(lib.getLogger)().track((_getLogger$track = {}, _getLogger$track[sdk_constants_src.FPTI_KEY.TRANSITION] = "hcf_transaction_success", 
                                                _getLogger$track[sdk_constants_src.FPTI_KEY.EVENT_NAME] = "hcf_transaction_success", 
                                                _getLogger$track.order_id = orderID, _getLogger$track[sdk_constants_src.FPTI_KEY.PAYMENT_FLOW] = constants.PAYMENT_FLOWS.WITH_PURCHASE, 
                                                _getLogger$track[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = "order_id", _getLogger$track[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = orderID, 
                                                _getLogger$track)).flush();
                                            }({
                                                orderID: orderID
                                            });
                                        })).catch((function(error) {
                                            "string" == typeof error && (error = new Error(error));
                                            !function(_ref5) {
                                                var _getLogger$track2;
                                                var orderID = _ref5.orderID, error = _ref5.error;
                                                Object(lib.sendCountMetric)({
                                                    name: "pp.app.paypal_sdk.card_fields.submit.error.count",
                                                    dimensions: {
                                                        cardFieldsFlow: constants.PAYMENT_FLOWS.WITH_PURCHASE
                                                    }
                                                });
                                                Object(lib.getLogger)().track((_getLogger$track2 = {}, _getLogger$track2[sdk_constants_src.FPTI_KEY.ERROR_CODE] = "hcf_transaction_error", 
                                                _getLogger$track2[sdk_constants_src.FPTI_KEY.EVENT_NAME] = "hcf_transaction_error", 
                                                _getLogger$track2[sdk_constants_src.FPTI_KEY.ERROR_DESC] = Object(src.stringifyErrorMessage)(error), 
                                                _getLogger$track2[sdk_constants_src.FPTI_KEY.PAYMENT_FLOW] = constants.PAYMENT_FLOWS.WITH_PURCHASE, 
                                                _getLogger$track2.order_id = orderID, _getLogger$track2[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = "order_id", 
                                                _getLogger$track2[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = orderID, _getLogger$track2)).flush();
                                            }({
                                                error: error,
                                                orderID: orderID
                                            });
                                            cardProps.onError && cardProps.onError(error);
                                            throw error;
                                        }));
                                    }(cardProps, card, extraFields, facilitatorAccessToken);

                                  case constants.PAYMENT_FLOWS.VAULT_WITHOUT_PURCHASE:
                                    return function(cardProps, card, extraFields) {
                                        var _getComponents = props_getComponents();
                                        var userIDToken = cardProps.userIDToken, productAction = cardProps.productAction;
                                        return function(_ref) {
                                            var onApprove = _ref.onApprove, onError = _ref.onError, clientID = _ref.clientID, paymentSource = _ref.paymentSource, getParent = _ref.getParent, ThreeDomainSecure = _ref.ThreeDomainSecure, idToken = _ref.idToken, productAction = _ref.productAction;
                                            var vaultToken;
                                            return (0, _ref.createVaultSetupToken)().then((function(vaultSetupToken) {
                                                if ("string" != typeof vaultSetupToken) throw new TypeError("Expected createVaultSetupToken to return a promise that resolves with vaultSetupToken as a string");
                                                vaultToken = vaultSetupToken;
                                                return Object(api_vault.updateVaultSetupToken)({
                                                    vaultSetupToken: vaultSetupToken,
                                                    clientID: clientID,
                                                    paymentSource: paymentSource,
                                                    idToken: idToken
                                                });
                                            })).then((function(res) {
                                                var _ref2 = (null == res ? void 0 : res.updateVaultSetupToken) || {};
                                                return handleThreeDomainSecureContingency({
                                                    status: _ref2.status,
                                                    links: _ref2.links,
                                                    getParent: getParent,
                                                    ThreeDomainSecure: ThreeDomainSecure,
                                                    paymentFlow: productAction
                                                });
                                            })).then((function(threeDsResponse) {
                                                return onApprove({
                                                    vaultSetupToken: vaultToken,
                                                    liabilityShift: null == threeDsResponse ? void 0 : threeDsResponse.liability_shift
                                                });
                                            })).then((function() {
                                                return function(_ref6) {
                                                    var _getLogger$track3;
                                                    var vaultToken = _ref6.vaultToken;
                                                    Object(lib.sendCountMetric)({
                                                        name: "pp.app.paypal_sdk.card_fields.submit.success.count",
                                                        dimensions: {
                                                            cardFieldsFlow: constants.PAYMENT_FLOWS.VAULT_WITHOUT_PURCHASE
                                                        }
                                                    });
                                                    Object(lib.getLogger)().track((_getLogger$track3 = {}, _getLogger$track3[sdk_constants_src.FPTI_KEY.TRANSITION] = "hcf_transaction_success", 
                                                    _getLogger$track3[sdk_constants_src.FPTI_KEY.EVENT_NAME] = "hcf_transaction_success", 
                                                    _getLogger$track3.vault_token = vaultToken, _getLogger$track3[sdk_constants_src.FPTI_KEY.PAYMENT_FLOW] = constants.PAYMENT_FLOWS.VAULT_WITHOUT_PURCHASE, 
                                                    _getLogger$track3[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = "vault_setup_token", 
                                                    _getLogger$track3[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = vaultToken, _getLogger$track3)).flush();
                                                }({
                                                    vaultToken: vaultToken
                                                });
                                            })).catch((function(error) {
                                                "string" == typeof error && (error = new Error(error));
                                                !function(_ref7) {
                                                    var _getLogger$track4;
                                                    var vaultToken = _ref7.vaultToken, error = _ref7.error;
                                                    Object(lib.sendCountMetric)({
                                                        name: "pp.app.paypal_sdk.card_fields.submit.error.count",
                                                        dimensions: {
                                                            cardFieldsFlow: constants.PAYMENT_FLOWS.VAULT_WITHOUT_PURCHASE
                                                        }
                                                    });
                                                    Object(lib.getLogger)().track((_getLogger$track4 = {}, _getLogger$track4[sdk_constants_src.FPTI_KEY.ERROR_CODE] = "hcf_transaction_error", 
                                                    _getLogger$track4[sdk_constants_src.FPTI_KEY.EVENT_NAME] = "hcf_transaction_error", 
                                                    _getLogger$track4[sdk_constants_src.FPTI_KEY.ERROR_DESC] = Object(src.stringifyErrorMessage)(error), 
                                                    _getLogger$track4.vault_token = vaultToken, _getLogger$track4[sdk_constants_src.FPTI_KEY.PAYMENT_FLOW] = constants.PAYMENT_FLOWS.VAULT_WITHOUT_PURCHASE, 
                                                    _getLogger$track4[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = "vault_setup_token", 
                                                    _getLogger$track4[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = vaultToken, _getLogger$track4)).flush();
                                                }({
                                                    error: error,
                                                    vaultToken: vaultToken
                                                });
                                                onError(error);
                                                throw error;
                                            }));
                                        }({
                                            onApprove: cardProps.onApprove,
                                            createVaultSetupToken: cardProps.createVaultSetupToken,
                                            onError: cardProps.onError,
                                            getParent: cardProps.getParent,
                                            ThreeDomainSecure: _getComponents.ThreeDomainSecure,
                                            clientID: cardProps.clientID,
                                            paymentSource: convertCardToPaymentSource(card, extraFields),
                                            idToken: userIDToken,
                                            productAction: productAction
                                        });
                                    }(cardProps, card, extraFields);

                                  default:
                                    throw new Error("Must pass either createVaultSetupToken or createOrder");
                                }
                            }));
                        }({
                            facilitatorAccessToken: facilitatorAccessToken,
                            featureFlags: serviceData.featureFlags,
                            experiments: {
                                hostedCardFields: !0,
                                useIDToken: !0
                            }
                        });
                    },
                    close: lib.promiseNoop
                };
            },
            inline: !0,
            spinner: !0
        };
        var beaver_logger_src = __webpack_require__("./node_modules/@krakenjs/beaver-logger/src/index.js");
        function logger_getLogger() {
            return Object(src.inlineMemoize)(logger_getLogger, (function() {
                return Object(beaver_logger_src.Logger)({
                    url: "/xoplatform/logger/api/logger"
                });
            }));
        }
        var vaultCapture = {
            name: "vault_capture",
            setup: function() {},
            isEligible: function(_ref) {
                var props = _ref.props;
                return !(props.onShippingChange || props.onShippingAddressChange || props.onShippingOptionsChange);
            },
            isPaymentEligible: function(_ref2) {
                var payment = _ref2.payment;
                return !(payment.win || !payment.paymentMethodID || window.innerWidth < 250 && payment.fundingSource === sdk_constants_src.FUNDING.PAYPAL);
            },
            init: function(_ref5) {
                var props = _ref5.props, components = _ref5.components, payment = _ref5.payment, serviceData = _ref5.serviceData, config = _ref5.config, experiments = _ref5.experiments;
                var createOrder = props.createOrder, onApprove = props.onApprove, clientAccessToken = props.clientAccessToken, enableThreeDomainSecure = props.enableThreeDomainSecure, partnerAttributionID = props.partnerAttributionID, getParent = props.getParent, userIDToken = props.userIDToken, clientID = props.clientID, env = props.env, disableSetCookie = props.disableSetCookie;
                var ThreeDomainSecure = components.ThreeDomainSecure, Installments = components.Installments;
                var fundingSource = payment.fundingSource, paymentMethodID = payment.paymentMethodID, button = payment.button;
                var facilitatorAccessToken = serviceData.facilitatorAccessToken, buyerCountry = serviceData.buyerCountry;
                var cspNonce = config.cspNonce;
                var clientMetadataID = function(_ref4) {
                    var props = _ref4.props;
                    return props.clientMetadataID || props.sessionID;
                }({
                    props: props
                });
                var accessToken = null != clientAccessToken ? clientAccessToken : facilitatorAccessToken;
                if (!paymentMethodID) throw new Error("Payment method id required for vault capture");
                if (!accessToken) throw new Error("Client access token required for vault capture");
                var restart = function() {
                    return zalgo_promise_src.ZalgoPromise.try((function() {
                        throw new Error("Vault capture restart not implemented");
                    }));
                };
                var fallbackToWebCheckout = function() {
                    Object(lib.getLogger)().info("web_checkout_fallback").flush();
                    return checkout.init({
                        props: props,
                        components: components,
                        serviceData: serviceData,
                        payment: Object(esm_extends.default)({}, payment, {
                            isClick: !1,
                            buyerIntent: constants.BUYER_INTENT.PAY_WITH_DIFFERENT_FUNDING_SHIPPING
                        }),
                        config: config,
                        restart: restart
                    }).start();
                };
                var shippingRequired = function(orderID) {
                    return Object(api.getSupplementalOrderInfo)(orderID).then((function(order) {
                        return !!order.checkoutSession.flags.isChangeShippingAddressAllowed;
                    }));
                };
                var startPaymentFlow = function(orderID, installmentPlan) {
                    return zalgo_promise_src.ZalgoPromise.hash({
                        validate: Object(api.validatePaymentMethod)({
                            accessToken: accessToken,
                            orderID: orderID,
                            paymentMethodID: paymentMethodID,
                            enableThreeDomainSecure: enableThreeDomainSecure,
                            clientMetadataID: clientMetadataID,
                            partnerAttributionID: partnerAttributionID,
                            installmentPlan: installmentPlan
                        }),
                        requireShipping: shippingRequired(orderID)
                    }).then((function(_ref6) {
                        var validate = _ref6.validate;
                        if (_ref6.requireShipping) {
                            Object(lib.sendCountMetric)({
                                name: "pp.app.paypal_sdk.buttons.vault_capture.error.count",
                                event: "error",
                                dimensions: {
                                    errorName: "shipping_required_failure_or_fallback",
                                    fundingSource: fundingSource
                                }
                            });
                            if (fundingSource !== sdk_constants_src.FUNDING.PAYPAL) throw new Error("Shipping address requested for " + fundingSource + " payment");
                            return fallbackToWebCheckout();
                        }
                        return function(_ref3) {
                            var ThreeDomainSecure = _ref3.ThreeDomainSecure, status = _ref3.status, body = _ref3.body, createOrder = _ref3.createOrder, getParent = _ref3.getParent;
                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                if (422 === status && body.links && body.links.some((function(link) {
                                    return "3ds-contingency-resolution" === link.rel;
                                }))) {
                                    Object(lib_logger.sendCountMetric)({
                                        name: "pp.app.paypal_sdk.buttons.vault_capture.contingency.count",
                                        dimensions: {
                                            contingency: "validate_payment_method_three_ds_contingency"
                                        }
                                    });
                                    return handleThreeDomainSecureRedirect({
                                        ThreeDomainSecure: ThreeDomainSecure,
                                        createOrder: createOrder,
                                        getParent: getParent
                                    });
                                }
                                if (200 !== status) {
                                    Object(lib_logger.sendCountMetric)({
                                        name: "pp.app.paypal_sdk.buttons.vault_capture.error.count",
                                        event: "error",
                                        dimensions: {
                                            errorName: "validate_payment_method_failure"
                                        }
                                    });
                                    if (Array.isArray(body.details)) {
                                        var _ref4$issue = (body.details && body.details[0] || {}).issue, issue = void 0 === _ref4$issue ? "" : _ref4$issue;
                                        if (0 !== issue.trim().length) throw new Error("Validate payment failed with issue: " + issue);
                                    }
                                    throw new Error("Validate payment failed with status: " + status);
                                }
                            }));
                        }({
                            ThreeDomainSecure: ThreeDomainSecure,
                            status: validate.status,
                            body: validate.body,
                            createOrder: createOrder,
                            getParent: getParent
                        }).then((function() {
                            return Object(api.confirmOrderAPI)(orderID, {
                                payment_source: Object(api.buildPaymentSource)({
                                    paymentMethodID: paymentMethodID,
                                    fundingSource: fundingSource
                                })
                            }, {
                                facilitatorAccessToken: accessToken,
                                partnerAttributionID: partnerAttributionID,
                                experiments: {}
                            }).then((function() {
                                Object(lib.sendCountMetric)({
                                    name: "pp.app.paypal_sdk.buttons.vault_capture.success.count",
                                    event: "success",
                                    dimensions: {
                                        fundingSource: fundingSource,
                                        experimentInUse: "none"
                                    }
                                });
                                return onApprove({}, {
                                    restart: restart
                                });
                            }));
                        }));
                    }));
                };
                return {
                    start: function() {
                        return createOrder().then((function(orderID) {
                            var queryStringParams = disableSetCookie ? {
                                disableSetCookie: disableSetCookie
                            } : {};
                            return Object(api.loadFraudnet)({
                                env: env,
                                clientMetadataID: clientMetadataID,
                                cspNonce: cspNonce,
                                queryStringParams: queryStringParams
                            }).catch(src.noop).then((function() {
                                var _getLogger$info$track;
                                var installmentsEligible = (fundingEligibility = (_ref3 = {
                                    props: props,
                                    serviceData: serviceData
                                }).serviceData.fundingEligibility, !!(_ref3.props.enableVaultInstallments && fundingEligibility.card && fundingEligibility.card.installments));
                                var _ref3, fundingEligibility;
                                Object(lib.getLogger)().info(installmentsEligible ? "vault_merchant_installments_eligible" : "vault_merchant_installments_ineligible").track((_getLogger$info$track = {}, 
                                _getLogger$info$track[sdk_constants_src.FPTI_KEY.TRANSITION] = installmentsEligible ? constants.FPTI_TRANSITION.INSTALLMENTS_ELIGIBLE : constants.FPTI_TRANSITION.INSTALLMENTS_INELIGIBLE, 
                                _getLogger$info$track[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = constants.FPTI_CONTEXT_TYPE.ORDER_ID, 
                                _getLogger$info$track[sdk_constants_src.FPTI_KEY.TOKEN] = orderID, _getLogger$info$track[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = orderID, 
                                _getLogger$info$track)).flush();
                                return clientID && installmentsEligible ? Object(api.getSupplementalOrderInfo)(orderID).then((function(order) {
                                    return function(_ref) {
                                        var clientID = _ref.clientID, Installments = _ref.Installments, button = _ref.button, orderID = _ref.orderID, cartAmount = _ref.cartAmount, _onPay = _ref.onPay, _ref$getLogger = _ref.getLogger, getLogger = void 0 === _ref$getLogger ? logger_getLogger : _ref$getLogger;
                                        return function(_ref) {
                                            var _headers;
                                            return function(_ref) {
                                                var name = _ref.name, query = _ref.query, _ref$variables = _ref.variables, variables = void 0 === _ref$variables ? {} : _ref$variables, _ref$headers = _ref.headers, headers = void 0 === _ref$headers ? {} : _ref$headers;
                                                return Object(src.request)({
                                                    url: "/graphql?" + name,
                                                    method: "POST",
                                                    json: {
                                                        query: query,
                                                        variables: variables
                                                    },
                                                    headers: Object(esm_extends.default)({
                                                        "x-app-name": "smart-payment-buttons"
                                                    }, headers)
                                                }).then((function(_ref2) {
                                                    var status = _ref2.status, body = _ref2.body;
                                                    var errors = body.errors || [];
                                                    if (errors.length) {
                                                        var message = errors[0].message || JSON.stringify(errors[0]);
                                                        throw new Error(message);
                                                    }
                                                    if (200 !== status) throw new Error("/graphql returned status " + status);
                                                    return body.data;
                                                }));
                                            }({
                                                name: "getInstallmentsForVaultedToken",
                                                query: "\n            query getInstallmentsForVaultedToken(\n                $vaultedToken: String!\n                $token: String!\n            ) {\n                getInstallmentsForVaultedToken(\n                    vaultedToken: $vaultedToken\n                    token: $token\n                ) {\n                    discount {\n                        amount {\n                            currencyCode\n                            currencyFormatSymbolISOCurrency\n                            currencyValue\n                        }\n                        percentage\n                    }\n                    monthlyPayment {\n                        currencyCode\n                        currencyFormatSymbolISOCurrency\n                        currencyValue\n                    }\n                    totalCost {\n                        currencyCode\n                        currencyFormatSymbolISOCurrency\n                        currencyValue\n                    }\n                    term\n                    intervalDuration\n                }\n            }\n        ",
                                                variables: {
                                                    vaultedToken: _ref.vaultedToken,
                                                    token: _ref.token
                                                },
                                                headers: (_headers = {}, _headers["x-paypal-internal-euat"] = _ref.buyerAccessToken, 
                                                _headers)
                                            });
                                        }({
                                            vaultedToken: _ref.paymentMethodID,
                                            token: orderID,
                                            buyerAccessToken: _ref.accessToken
                                        }).then((function(installmentsResponse) {
                                            if (installmentsResponse && installmentsResponse.getInstallmentsForVaultedToken) {
                                                var _getLogger$info$track;
                                                var installmentsData = installmentsResponse.getInstallmentsForVaultedToken;
                                                getLogger().info("installments_loaded").track((_getLogger$info$track = {}, _getLogger$info$track[sdk_constants_src.FPTI_KEY.TRANSITION] = "installments_load", 
                                                _getLogger$info$track[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = "EC-Token", _getLogger$info$track[sdk_constants_src.FPTI_KEY.TOKEN] = orderID, 
                                                _getLogger$info$track[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = orderID, _getLogger$info$track)).flush();
                                                if (installmentsData.length > 1 || installmentsData[0] && installmentsData[0].discount) {
                                                    var _getLogger$info$track5;
                                                    var options = installmentsData.map((function(info) {
                                                        return Object(esm_extends.default)({
                                                            term: info.term,
                                                            intervalDuration: info.intervalDuration
                                                        }, info.discount && {
                                                            percent: info.discount.percentage
                                                        }, {
                                                            amount: info.monthlyPayment.currencyFormatSymbolISOCurrency,
                                                            totalAmount: info.totalCost.currencyFormatSymbolISOCurrency,
                                                            onSelect: function(option) {
                                                                var _getLogger$info$track2;
                                                                getLogger().info("installment_option_selected_" + option.term + "x").track((_getLogger$info$track2 = {}, 
                                                                _getLogger$info$track2[sdk_constants_src.FPTI_KEY.TRANSITION] = "installment_select", 
                                                                _getLogger$info$track2[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = "EC-Token", _getLogger$info$track2[sdk_constants_src.FPTI_KEY.TOKEN] = orderID, 
                                                                _getLogger$info$track2[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = orderID, _getLogger$info$track2)).flush();
                                                            }
                                                        });
                                                    }));
                                                    var data = {
                                                        cartAmount: cartAmount,
                                                        onPay: function(selectedInstallment) {
                                                            var _getLogger$info$track3;
                                                            !function(button) {
                                                                button.classList.add("paypal-button-loading");
                                                            }(button);
                                                            getLogger().info("installments_pay_button_clicked_" + (selectedInstallment ? selectedInstallment.term : "") + "x").track((_getLogger$info$track3 = {}, 
                                                            _getLogger$info$track3[sdk_constants_src.FPTI_KEY.TRANSITION] = "installments_pay", 
                                                            _getLogger$info$track3[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = "EC-Token", _getLogger$info$track3[sdk_constants_src.FPTI_KEY.TOKEN] = orderID, 
                                                            _getLogger$info$track3[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = orderID, _getLogger$info$track3)).flush();
                                                            var installmentPlan = null;
                                                            selectedInstallment && (installmentPlan = {
                                                                term: selectedInstallment.term,
                                                                interval_duration: selectedInstallment.intervalDuration
                                                            });
                                                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                                                return _onPay(orderID, installmentPlan);
                                                            })).finally((function() {
                                                                !function(button) {
                                                                    button.classList.remove("paypal-button-loading");
                                                                }(button);
                                                            }));
                                                        },
                                                        onClose: function() {
                                                            var _getLogger$info$track4;
                                                            getLogger().info("installments_modal_close").track((_getLogger$info$track4 = {}, 
                                                            _getLogger$info$track4[sdk_constants_src.FPTI_KEY.TRANSITION] = "installments_close", 
                                                            _getLogger$info$track4[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = "EC-Token", _getLogger$info$track4[sdk_constants_src.FPTI_KEY.TOKEN] = orderID, 
                                                            _getLogger$info$track4[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = orderID, _getLogger$info$track4)).flush();
                                                        },
                                                        options: options,
                                                        orderID: orderID
                                                    };
                                                    getLogger().info("initiate_installments_modal").track((_getLogger$info$track5 = {}, 
                                                    _getLogger$info$track5[sdk_constants_src.FPTI_KEY.TRANSITION] = "installments_load_modal", 
                                                    _getLogger$info$track5[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = "EC-Token", _getLogger$info$track5[sdk_constants_src.FPTI_KEY.TOKEN] = orderID, 
                                                    _getLogger$info$track5[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = orderID, _getLogger$info$track5)).flush();
                                                    return function(_ref) {
                                                        var clientID = _ref.clientID, Installments = _ref.Installments, data = _ref.data;
                                                        if (!clientID) throw new Error("Can not render installments without client id");
                                                        var _Installments = Installments({
                                                            clientID: clientID
                                                        }), renderTo = _Installments.renderTo, updateProps = _Installments.updateProps, show = _Installments.show, close = _Installments.close;
                                                        var render = Object(src.memoize)((function() {
                                                            return renderTo(window.xprops.getParent(), "#installments-modal");
                                                        }));
                                                        render();
                                                        return render().then((function() {
                                                            return updateProps({
                                                                clientID: clientID,
                                                                data: data,
                                                                close: close
                                                            });
                                                        })).then((function() {
                                                            return show();
                                                        }));
                                                    }({
                                                        clientID: clientID,
                                                        Installments: Installments,
                                                        data: data
                                                    });
                                                }
                                                return _onPay(orderID);
                                            }
                                            throw new Error("Installments fetch returns null");
                                        })).catch((function(err) {
                                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                                var _getLogger$error$trac;
                                                getLogger().error("installment_fetch_error", {
                                                    err: Object(src.stringifyError)(err)
                                                }).track((_getLogger$error$trac = {}, _getLogger$error$trac[sdk_constants_src.FPTI_KEY.TRANSITION] = "installments_error", 
                                                _getLogger$error$trac[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = "EC-Token", _getLogger$error$trac[sdk_constants_src.FPTI_KEY.TOKEN] = orderID, 
                                                _getLogger$error$trac[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = orderID, _getLogger$error$trac.err = Object(src.stringifyError)(err), 
                                                _getLogger$error$trac)).flush();
                                                return _onPay(orderID);
                                            }));
                                        }));
                                    }({
                                        clientID: clientID,
                                        Installments: Installments,
                                        paymentMethodID: paymentMethodID,
                                        button: button,
                                        buyerCountry: buyerCountry,
                                        orderID: orderID,
                                        accessToken: accessToken,
                                        cartAmount: order.checkoutSession.cart.amounts.total.currencyFormatSymbolISOCurrency,
                                        onPay: startPaymentFlow,
                                        getLogger: lib.getLogger
                                    });
                                })) : null != experiments && experiments.deprecateVaultValidatePaymentMethod ? function(orderID) {
                                    userIDToken && (accessToken = userIDToken);
                                    zalgo_promise_src.ZalgoPromise.try((function() {
                                        return shippingRequired(orderID).then((function(shippingRequiredFlag) {
                                            if (shippingRequiredFlag) {
                                                Object(lib.sendCountMetric)({
                                                    name: "pp.app.paypal_sdk.buttons.vault_capture.error.count",
                                                    event: "error",
                                                    dimensions: {
                                                        errorName: "shipping_required_failure_or_fallback",
                                                        fundingSource: fundingSource
                                                    }
                                                });
                                                if (fundingSource !== sdk_constants_src.FUNDING.PAYPAL) throw new Error("Shipping address requested for " + fundingSource + " payment");
                                                return fallbackToWebCheckout();
                                            }
                                            return Object(api.confirmOrderAPI)(orderID, {
                                                payment_source: Object(api.buildPaymentSource)({
                                                    paymentMethodID: paymentMethodID,
                                                    fundingSource: fundingSource,
                                                    enableThreeDomainSecure: enableThreeDomainSecure
                                                })
                                            }, {
                                                facilitatorAccessToken: accessToken,
                                                partnerAttributionID: partnerAttributionID,
                                                experiments: {}
                                            }).then((function(res) {
                                                return handleThreeDomainSecureContingency({
                                                    status: res.status,
                                                    links: res.links,
                                                    ThreeDomainSecure: ThreeDomainSecure,
                                                    createOrder: createOrder,
                                                    getParent: getParent,
                                                    paymentFlow: "vault_capture",
                                                    fundingSource: fundingSource
                                                });
                                            })).then((function() {
                                                Object(lib.sendCountMetric)({
                                                    name: "pp.app.paypal_sdk.buttons.vault_capture.success.count",
                                                    event: "success",
                                                    dimensions: {
                                                        fundingSource: fundingSource,
                                                        experimentInUse: "deprecated_validate_payment_method_experiment"
                                                    }
                                                });
                                                return onApprove({}, {
                                                    restart: restart
                                                });
                                            }));
                                        }));
                                    }));
                                }(orderID) : startPaymentFlow(orderID);
                            }));
                        }));
                    },
                    close: function() {
                        return zalgo_promise_src.ZalgoPromise.resolve();
                    }
                };
            },
            setupMenu: function(_ref7) {
                var props = _ref7.props, payment = _ref7.payment, serviceData = _ref7.serviceData, components = _ref7.components, config = _ref7.config, restart = _ref7.restart, experiments = _ref7.experiments;
                var dimensions = null != experiments && experiments.popupIncreaseDimensions ? EXPERIMENTAL_POPUP_DIMENSIONS : CHECKOUT_POPUP_DIMENSIONS;
                var POPUP_OPTIONS = {
                    width: dimensions.WIDTH,
                    height: dimensions.HEIGHT
                };
                var clientAccessToken = props.clientAccessToken, createOrder = props.createOrder, enableThreeDomainSecure = props.enableThreeDomainSecure, partnerAttributionID = props.partnerAttributionID, sessionID = props.sessionID, clientMetadataID = props.clientMetadataID, userIDToken = props.userIDToken;
                var fundingSource = payment.fundingSource, paymentMethodID = payment.paymentMethodID, button = payment.button;
                var content = serviceData.content, facilitatorAccessToken = serviceData.facilitatorAccessToken, featureFlags = serviceData.featureFlags;
                if (!clientAccessToken || !paymentMethodID) throw new Error("Client access token and payment method id required");
                Object(lib.getLogger)().info("popup_dimensions_value_vault_capture");
                Object(lib.sendCountMetric)({
                    name: "pp.app.paypal_sdk.checkout_ui.dimension.count",
                    dimensions: {
                        spbPaymentFlow: "vault_capture",
                        fundingSource: fundingSource,
                        dimensionType: null != experiments && experiments.popupIncreaseDimensions ? "experiment_default" : "default"
                    }
                });
                var updateMenuClientConfig = function() {
                    return zalgo_promise_src.ZalgoPromise.try((function() {
                        return createOrder();
                    })).then((function(orderID) {
                        return Object(api.updateButtonClientConfig)({
                            fundingSource: fundingSource,
                            orderID: orderID,
                            inline: !1,
                            featureFlags: featureFlags
                        });
                    }));
                };
                var loadCheckout = function(_ref8) {
                    return checkout.init({
                        props: props,
                        components: components,
                        serviceData: serviceData,
                        config: config,
                        payment: _ref8.payment,
                        restart: restart
                    }).start();
                };
                if (fundingSource === sdk_constants_src.FUNDING.PAYPAL) return [ {
                    label: content.payWithDifferentMethod,
                    popup: POPUP_OPTIONS,
                    onSelect: function(_ref9) {
                        var _getLogger$info$track2;
                        var win = _ref9.win;
                        Object(lib.getLogger)().info("click_choose_funding").track((_getLogger$info$track2 = {}, 
                        _getLogger$info$track2[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.CLICK_CHOOSE_FUNDING, 
                        _getLogger$info$track2[sdk_constants_src.FPTI_KEY.OPTION_SELECTED] = constants.FPTI_MENU_OPTION.CHOOSE_FUNDING, 
                        _getLogger$info$track2)).flush();
                        return zalgo_promise_src.ZalgoPromise.try((function() {
                            return updateMenuClientConfig();
                        })).then((function() {
                            return accessToken = userIDToken ? facilitatorAccessToken : clientAccessToken, zalgo_promise_src.ZalgoPromise.try((function() {
                                return createOrder();
                            })).then((function(orderID) {
                                return Object(api.validatePaymentMethod)({
                                    accessToken: accessToken,
                                    orderID: orderID,
                                    paymentMethodID: paymentMethodID,
                                    enableThreeDomainSecure: enableThreeDomainSecure,
                                    partnerAttributionID: partnerAttributionID,
                                    clientMetadataID: clientMetadataID || sessionID
                                });
                            }));
                            var accessToken;
                        })).then((function() {
                            return loadCheckout({
                                payment: Object(esm_extends.default)({}, payment, {
                                    win: win,
                                    buyerIntent: constants.BUYER_INTENT.PAY_WITH_DIFFERENT_FUNDING_SHIPPING
                                })
                            });
                        }));
                    }
                }, {
                    label: content.payWithDifferentAccount,
                    popup: POPUP_OPTIONS,
                    onSelect: function(_ref10) {
                        var _getLogger$info$track3;
                        var win = _ref10.win;
                        Object(lib.getLogger)().info("click_choose_account").track((_getLogger$info$track3 = {}, 
                        _getLogger$info$track3[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.CLICK_CHOOSE_ACCOUNT, 
                        _getLogger$info$track3[sdk_constants_src.FPTI_KEY.OPTION_SELECTED] = constants.FPTI_MENU_OPTION.CHOOSE_ACCOUNT, 
                        _getLogger$info$track3)).flush();
                        return zalgo_promise_src.ZalgoPromise.try((function() {
                            return updateMenuClientConfig();
                        })).then((function() {
                            return loadCheckout({
                                payment: Object(esm_extends.default)({}, payment, {
                                    win: win,
                                    buyerIntent: constants.BUYER_INTENT.PAY_WITH_DIFFERENT_ACCOUNT
                                })
                            });
                        }));
                    }
                } ];
                if (fundingSource === sdk_constants_src.FUNDING.CARD) return [ {
                    label: content.deleteVaultedCard,
                    spinner: !0,
                    onSelect: function() {
                        var _getLogger$info$track4;
                        var element = button.parentElement || button;
                        Object(lib.getLogger)().info("click_unlink_account").track((_getLogger$info$track4 = {}, 
                        _getLogger$info$track4[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.CLICK_UNLINK_ACCOUNT, 
                        _getLogger$info$track4[sdk_constants_src.FPTI_KEY.OPTION_SELECTED] = constants.FPTI_MENU_OPTION.UNLINK_ACCOUNT, 
                        _getLogger$info$track4)).flush();
                        return Object(api.deleteVault)({
                            paymentMethodID: paymentMethodID,
                            clientAccessToken: clientAccessToken
                        }).then((function() {
                            Object(src.destroyElement)(element);
                        }));
                    }
                } ];
                throw new Error("Can not render menu for " + fundingSource);
            },
            updateFlowClientConfig: function(_ref11) {
                var orderID = _ref11.orderID, featureFlags = _ref11.featureFlags;
                var fundingSource = _ref11.payment.fundingSource;
                return Object(api.updateButtonClientConfig)({
                    fundingSource: fundingSource,
                    orderID: orderID,
                    inline: !0,
                    featureFlags: featureFlags
                });
            },
            spinner: !0,
            inline: !0
        };
        var smartWalletPromise;
        var smartWalletErrored = !1;
        function getInstrument(wallet, fundingSource, instrumentID) {
            var walletFunding = wallet[fundingSource];
            if (!walletFunding) throw new Error("Wallet has no " + fundingSource);
            var instrument;
            for (var _i2 = 0, _walletFunding$instru2 = walletFunding.instruments; _i2 < _walletFunding$instru2.length; _i2++) {
                var inst = _walletFunding$instru2[_i2];
                inst.instrumentID === instrumentID && (instrument = inst);
            }
            if (!instrument) throw new Error("Can not find instrument with id " + instrumentID);
            return instrument;
        }
        var walletCapture = {
            name: "wallet_capture",
            setup: function(_ref3) {
                var _ref4;
                var props = _ref3.props, serviceData = _ref3.serviceData;
                var env = props.env, clientID = props.clientID, currency = props.currency, amount = props.amount, userIDToken = props.userIDToken, paymentMethodToken = props.paymentMethodToken, allowBillingPayments = props.allowBillingPayments, branded = props.branded, disableSetCookie = props.disableSetCookie;
                var cspNonce = _ref3.config.cspNonce;
                var merchantID = serviceData.merchantID, wallet = serviceData.wallet;
                var clientMetadataID = function(_ref2) {
                    var props = _ref2.props;
                    return props.clientMetadataID || props.sessionID;
                }({
                    props: props
                });
                var queryStringParams = disableSetCookie ? {
                    disableSetCookie: disableSetCookie
                } : {};
                var headers = disableSetCookie ? ((_ref4 = {})[constants.HEADERS.DISABLE_SET_COOKIE] = String(disableSetCookie), 
                _ref4) : {};
                if (!wallet) throw new Error("No wallet found");
                (smartWalletPromise = Object(api.loadFraudnet)({
                    env: env,
                    clientMetadataID: clientMetadataID,
                    cspNonce: cspNonce,
                    queryStringParams: queryStringParams
                }).catch(src.noop).then((function() {
                    return userIDToken ? Object(api.getSmartWallet)({
                        clientID: clientID,
                        merchantID: merchantID,
                        currency: currency,
                        amount: amount,
                        clientMetadataID: clientMetadataID,
                        userIDToken: userIDToken,
                        paymentMethodToken: paymentMethodToken,
                        allowBillingPayments: allowBillingPayments,
                        branded: branded,
                        headers: headers
                    }) : wallet;
                }))).catch((function(err) {
                    Object(lib.getLogger)().warn("load_smart_wallet_error", {
                        err: Object(src.stringifyError)(err)
                    });
                    smartWalletErrored = !0;
                }));
            },
            isEligible: function(_ref) {
                var props = _ref.props;
                return !(!props.userIDToken || !_ref.serviceData.wallet || props.onShippingChange || props.onShippingAddressChange || props.onShippingOptionsChange);
            },
            isPaymentEligible: function(_ref5) {
                var payment = _ref5.payment;
                var wallet = _ref5.serviceData.wallet;
                var fundingSource = payment.fundingSource, instrumentID = payment.instrumentID;
                if (payment.win) return !1;
                if (!wallet) return !1;
                if (!instrumentID) return !1;
                if (!smartWalletPromise) return !1;
                if (smartWalletErrored) return !1;
                try {
                    getInstrument(wallet, fundingSource, instrumentID);
                } catch (err) {
                    return !1;
                }
                return !0;
            },
            init: function(_ref6) {
                var props = _ref6.props, components = _ref6.components, payment = _ref6.payment, serviceData = _ref6.serviceData, config = _ref6.config, fullRestart = _ref6.restart;
                var createOrder = props.createOrder, onApprove = props.onApprove, clientMetadataID = props.clientMetadataID, vault = props.vault, onAuth = props.onAuth;
                var fundingSource = payment.fundingSource, instrumentID = payment.instrumentID;
                var wallet = serviceData.wallet;
                if (!wallet || !smartWalletPromise) throw new Error("No smart wallet found");
                if (!instrumentID) throw new Error("Instrument id required for wallet capture");
                var instrument = getInstrument(wallet, fundingSource, instrumentID);
                var createAccessToken = function() {
                    if (!smartWalletPromise) throw new Error("No smart wallet found");
                    return smartWalletPromise.then((function(smartWallet) {
                        var accessToken = getInstrument(smartWallet, fundingSource, instrumentID).accessToken;
                        if (!accessToken) throw new Error("Instrument access token not found");
                        return accessToken;
                    }));
                };
                var getWebCheckoutFallback = function() {
                    return checkout.init({
                        props: props,
                        components: components,
                        serviceData: serviceData,
                        payment: Object(esm_extends.default)({}, payment, {
                            createAccessToken: createAccessToken,
                            isClick: !1,
                            buyerIntent: constants.BUYER_INTENT.PAY_WITH_DIFFERENT_FUNDING_SHIPPING,
                            fundingSource: instrument && instrument.type === sdk_constants_src.WALLET_INSTRUMENT.CREDIT ? sdk_constants_src.FUNDING.CREDIT : fundingSource
                        }),
                        config: config,
                        restart: fullRestart
                    });
                };
                var fallbackToWebCheckout = function() {
                    Object(lib.getLogger)().info("web_checkout_fallback").flush();
                    return getWebCheckoutFallback().start();
                };
                if (!instrument.oneClick || smartWalletErrored || vault) return getWebCheckoutFallback();
                var restart = function() {
                    return fallbackToWebCheckout();
                };
                var shippingRequired = function(orderID) {
                    return Object(api.getSupplementalOrderInfo)(orderID).then((function(order) {
                        return !!order.checkoutSession.flags.isChangeShippingAddressAllowed;
                    }));
                };
                return {
                    start: function() {
                        return zalgo_promise_src.ZalgoPromise.hash({
                            orderID: createOrder(),
                            smartWallet: smartWalletPromise
                        }).then((function(_ref7) {
                            var orderID = _ref7.orderID;
                            var buyerAccessToken = getInstrument(_ref7.smartWallet, fundingSource, instrumentID).accessToken;
                            if (!buyerAccessToken) throw new Error("No access token available for instrument");
                            var instrumentType = instrument.type;
                            if (!instrumentType) throw new Error("Instrument has no type");
                            return zalgo_promise_src.ZalgoPromise.hash({
                                requireShipping: shippingRequired(orderID),
                                orderApproval: Object(api.oneClickApproveOrder)({
                                    orderID: orderID,
                                    instrumentType: instrumentType,
                                    buyerAccessToken: buyerAccessToken,
                                    instrumentID: instrumentID,
                                    clientMetadataID: clientMetadataID
                                }),
                                onAuth: onAuth({
                                    accessToken: buyerAccessToken
                                })
                            }).then((function(_ref8) {
                                var orderApproval = _ref8.orderApproval;
                                return _ref8.requireShipping ? fallbackToWebCheckout() : onApprove({
                                    payerID: orderApproval.payerID,
                                    buyerAccessToken: buyerAccessToken
                                }, {
                                    restart: restart
                                }).catch(src.noop);
                            }));
                        })).catch((function(err) {
                            Object(lib.getLogger)().warn("approve_order_error", {
                                err: Object(src.stringifyError)(err)
                            }).flush();
                            return fallbackToWebCheckout();
                        }));
                    },
                    close: function() {
                        return zalgo_promise_src.ZalgoPromise.resolve();
                    }
                };
            },
            setupMenu: function(_ref9) {
                var props = _ref9.props, payment = _ref9.payment, serviceData = _ref9.serviceData, components = _ref9.components, config = _ref9.config, restart = _ref9.restart, experiments = _ref9.experiments;
                var dimensions = null != experiments && experiments.popupIncreaseDimensions ? EXPERIMENTAL_POPUP_DIMENSIONS : CHECKOUT_POPUP_DIMENSIONS;
                var POPUP_OPTIONS = {
                    width: dimensions.WIDTH,
                    height: dimensions.HEIGHT
                };
                var createOrder = props.createOrder;
                var fundingSource = payment.fundingSource, instrumentID = payment.instrumentID;
                var wallet = serviceData.wallet, content = serviceData.content, featureFlags = serviceData.featureFlags;
                if (!wallet) throw new Error("Can not render wallet menu without wallet");
                if (!instrumentID) throw new Error("Can not render wallet menu without instrumentID");
                var instrument = getInstrument(wallet, fundingSource, instrumentID);
                if (!instrument) throw new Error("Can not render wallet menu without instrument");
                Object(lib.getLogger)().info("popup_dimensions_value_wallet_capture");
                Object(lib.sendCountMetric)({
                    name: "pp.app.paypal_sdk.checkout_ui.dimension.count",
                    dimensions: {
                        spbPaymentFlow: "wallet_capture",
                        fundingSource: fundingSource,
                        dimensionType: null != experiments && experiments.popupIncreaseDimensions ? "experiment_default" : "default"
                    }
                });
                var loadCheckout = function(_ref10) {
                    return checkout.init({
                        props: props,
                        components: components,
                        serviceData: serviceData,
                        config: config,
                        payment: _ref10.payment,
                        restart: restart
                    }).start();
                };
                var newFundingSource = instrument.type === sdk_constants_src.WALLET_INSTRUMENT.CREDIT ? sdk_constants_src.FUNDING.CREDIT : fundingSource;
                if (fundingSource === sdk_constants_src.FUNDING.PAYPAL || fundingSource === sdk_constants_src.FUNDING.CREDIT) return [ {
                    label: content.payWithDifferentMethod,
                    popup: POPUP_OPTIONS,
                    onSelect: function(_ref11) {
                        var _getLogger$info$track;
                        var win = _ref11.win;
                        Object(lib.getLogger)().info("click_choose_funding").track((_getLogger$info$track = {}, 
                        _getLogger$info$track[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                        _getLogger$info$track[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.CLICK_CHOOSE_FUNDING, 
                        _getLogger$info$track[sdk_constants_src.FPTI_KEY.OPTION_SELECTED] = constants.FPTI_MENU_OPTION.CHOOSE_FUNDING, 
                        _getLogger$info$track)).flush();
                        return zalgo_promise_src.ZalgoPromise.try((function() {
                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                return createOrder();
                            })).then((function(orderID) {
                                return Object(api.updateButtonClientConfig)({
                                    fundingSource: fundingSource,
                                    orderID: orderID,
                                    inline: !1,
                                    featureFlags: featureFlags
                                });
                            }));
                        })).then((function() {
                            return loadCheckout({
                                payment: Object(esm_extends.default)({}, payment, {
                                    win: win,
                                    buyerIntent: constants.BUYER_INTENT.PAY_WITH_DIFFERENT_FUNDING_SHIPPING,
                                    fundingSource: newFundingSource,
                                    createAccessToken: function() {
                                        return smartWalletPromise.then((function(smartWallet) {
                                            var smartInstrument = getInstrument(smartWallet, fundingSource, instrumentID);
                                            if (!smartInstrument) throw new Error("Instrument not found");
                                            if (!smartInstrument.accessToken) throw new Error("Instrument access token not found");
                                            return smartInstrument.accessToken;
                                        }));
                                    }
                                })
                            });
                        }));
                    }
                }, {
                    label: content.payWithDifferentAccount,
                    popup: POPUP_OPTIONS,
                    onSelect: function(_ref12) {
                        var _getLogger$info$track2;
                        var win = _ref12.win;
                        Object(lib.getLogger)().info("click_choose_account").track((_getLogger$info$track2 = {}, 
                        _getLogger$info$track2[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                        _getLogger$info$track2[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.CLICK_CHOOSE_ACCOUNT, 
                        _getLogger$info$track2[sdk_constants_src.FPTI_KEY.OPTION_SELECTED] = constants.FPTI_MENU_OPTION.CHOOSE_ACCOUNT, 
                        _getLogger$info$track2)).flush();
                        return loadCheckout({
                            payment: Object(esm_extends.default)({}, payment, {
                                win: win,
                                buyerIntent: constants.BUYER_INTENT.PAY_WITH_DIFFERENT_ACCOUNT,
                                fundingSource: newFundingSource
                            })
                        });
                    }
                } ];
                throw new Error("Can not render menu for " + fundingSource);
            },
            updateFlowClientConfig: function(_ref13) {
                var orderID = _ref13.orderID, featureFlags = _ref13.featureFlags;
                var fundingSource = _ref13.payment.fundingSource;
                return Object(api.updateButtonClientConfig)({
                    fundingSource: fundingSource,
                    orderID: orderID,
                    inline: !0,
                    featureFlags: featureFlags
                });
            },
            spinner: !0,
            inline: !0
        };
        var _NATIVE_DOMAIN, _HISTORY_NATIVE_POPUP, _MOBILE_NATIVE_POPUP_, _NATIVE_CHECKOUT_URI, _NATIVE_CHECKOUT_POPU, _NATIVE_CHECKOUT_FALL, _VENMO_WEB_URL;
        var NATIVE_DOMAIN = ((_NATIVE_DOMAIN = {})[sdk_constants_src.ENV.TEST] = "https://www.paypal.com", 
        _NATIVE_DOMAIN[sdk_constants_src.ENV.LOCAL] = Object(cross_domain_utils_src.getDomain)(), 
        _NATIVE_DOMAIN[sdk_constants_src.ENV.STAGE] = "https://www.paypal.com", _NATIVE_DOMAIN[sdk_constants_src.ENV.SANDBOX] = "https://www.sandbox.paypal.com", 
        _NATIVE_DOMAIN[sdk_constants_src.ENV.PRODUCTION] = "https://www.paypal.com", _NATIVE_DOMAIN);
        var HISTORY_NATIVE_POPUP_DOMAIN = ((_HISTORY_NATIVE_POPUP = {})[sdk_constants_src.ENV.TEST] = "https://history.paypal.com", 
        _HISTORY_NATIVE_POPUP[sdk_constants_src.ENV.LOCAL] = "http://localhost:8001", _HISTORY_NATIVE_POPUP[sdk_constants_src.ENV.STAGE] = "https://history.paypal.com", 
        _HISTORY_NATIVE_POPUP[sdk_constants_src.ENV.SANDBOX] = "https://history.paypal.com", 
        _HISTORY_NATIVE_POPUP[sdk_constants_src.ENV.PRODUCTION] = "https://history.paypal.com", 
        _HISTORY_NATIVE_POPUP);
        var MOBILE_NATIVE_POPUP_DOMAIN = ((_MOBILE_NATIVE_POPUP_ = {})[sdk_constants_src.ENV.TEST] = "https://mobile.paypal.com", 
        _MOBILE_NATIVE_POPUP_[sdk_constants_src.ENV.LOCAL] = "http://localhost:8001", _MOBILE_NATIVE_POPUP_[sdk_constants_src.ENV.STAGE] = "https://mobile.paypal.com", 
        _MOBILE_NATIVE_POPUP_[sdk_constants_src.ENV.SANDBOX] = "https://mobile.paypal.com", 
        _MOBILE_NATIVE_POPUP_[sdk_constants_src.ENV.PRODUCTION] = "https://mobile.paypal.com", 
        _MOBILE_NATIVE_POPUP_);
        var NATIVE_CHECKOUT_URI = ((_NATIVE_CHECKOUT_URI = {})[sdk_constants_src.FUNDING.PAYPAL] = "/smart/checkout/native", 
        _NATIVE_CHECKOUT_URI[sdk_constants_src.FUNDING.VENMO] = "/smart/checkout/venmo", 
        _NATIVE_CHECKOUT_URI);
        var NATIVE_CHECKOUT_POPUP_URI = ((_NATIVE_CHECKOUT_POPU = {})[sdk_constants_src.FUNDING.PAYPAL] = "/smart/checkout/native/popup", 
        _NATIVE_CHECKOUT_POPU[sdk_constants_src.FUNDING.VENMO] = "/smart/checkout/venmo/popup", 
        _NATIVE_CHECKOUT_POPU);
        var NATIVE_CHECKOUT_FALLBACK_URI = ((_NATIVE_CHECKOUT_FALL = {})[sdk_constants_src.FUNDING.PAYPAL] = "/smart/checkout/fallback", 
        _NATIVE_CHECKOUT_FALL[sdk_constants_src.FUNDING.VENMO] = "/smart/checkout/fallback", 
        _NATIVE_CHECKOUT_FALL);
        var VENMO_WEB_URL = ((_VENMO_WEB_URL = {})[sdk_constants_src.ENV.TEST] = "https://account.dev.venmo.com/go/web/paypal", 
        _VENMO_WEB_URL[sdk_constants_src.ENV.LOCAL] = "https://account.dev.venmo.com/go/web/paypal", 
        _VENMO_WEB_URL[sdk_constants_src.ENV.STAGE] = Object(cross_domain_utils_src.getDomain)().includes("cibns") ? "https://account.qa.venmo.com/go/web/paypal" : "https://account.dev.venmo.com/go/web/paypal", 
        _VENMO_WEB_URL[sdk_constants_src.ENV.SANDBOX] = "https://account.qa.venmo.com/go/web/paypal", 
        _VENMO_WEB_URL[sdk_constants_src.ENV.PRODUCTION] = "https://account.venmo.com/go/web/paypal", 
        _VENMO_WEB_URL);
        function isNativeOptedIn(_ref) {
            if (_ref.props.enableNativeCheckout) return !0;
            try {
                if (window.localStorage.getItem("__native_checkout__")) return !0;
            } catch (err) {}
            return !1;
        }
        var nativeEligibilityResults;
        function canUsePopupAppSwitch(_ref3) {
            var fundingSource = _ref3.fundingSource, win = _ref3.win;
            return !(!Object(lib.isIOSSafari)() && !Object(lib.isAndroidChrome)() || fundingSource && fundingSource !== sdk_constants_src.FUNDING.PAYPAL && fundingSource !== sdk_constants_src.FUNDING.VENMO || win && !Object(lib.toProxyWindow)(win).getWindow());
        }
        function canUseNativeQRCode(_ref4) {
            var fundingSource = _ref4.fundingSource, win = _ref4.win;
            return !(Object(src.isIos)() || Object(src.isAndroid)() || fundingSource && fundingSource !== sdk_constants_src.FUNDING.VENMO || win);
        }
        function setNativeOptOut(fallbackOptions) {
            var type = fallbackOptions.type;
            if (type && "native_opt_out" === type) {
                var OPT_OUT_TIME = 36288e5;
                var parsedSkipDuration = parseInt(fallbackOptions.skip_native_duration, 10);
                parsedSkipDuration && "number" == typeof parsedSkipDuration && (OPT_OUT_TIME = parsedSkipDuration);
                var now = Date.now();
                Object(lib.getStorageState)((function(state) {
                    state.nativeOptOutLifetime = now + OPT_OUT_TIME;
                }));
                return !0;
            }
            return !1;
        }
        function getNativeDomain(_ref) {
            var props = _ref.props;
            var env = props.env;
            return env !== sdk_constants_src.ENV.SANDBOX || !isNativeOptedIn({
                props: props
            }) || window.xprops && window.xprops.useCorrectNativeSandboxDomain ? NATIVE_DOMAIN[env] : "https://www.paypal.com";
        }
        function getNativePopupDomain(_ref2) {
            var props = _ref2.props;
            var env = props.env;
            return env !== sdk_constants_src.ENV.SANDBOX || !isNativeOptedIn({
                props: props
            }) || window.xprops && window.xprops.useCorrectNativeSandboxDomain ? (Object(lib.createExperiment)("enable_mobile_native_popup_domain", {
                sample: 0
            }).isEnabled() ? MOBILE_NATIVE_POPUP_DOMAIN : HISTORY_NATIVE_POPUP_DOMAIN)[env] : "https://www.sandbox.paypal.com";
        }
        function getNativeUrlQueryParams(_ref4) {
            var props = _ref4.props, serviceData = _ref4.serviceData, config = _ref4.config, fundingSource = _ref4.fundingSource, sessionUID = _ref4.sessionUID, pageUrl = _ref4.pageUrl, orderID = _ref4.orderID, stickinessID = _ref4.stickinessID;
            var env = props.env, clientID = props.clientID, commit = props.commit, buttonSessionID = props.buttonSessionID, stageHost = props.stageHost, apiStageHost = props.apiStageHost, enableFunding = props.enableFunding, merchantDomain = props.merchantDomain;
            var facilitatorAccessToken = serviceData.facilitatorAccessToken, sdkMeta = serviceData.sdkMeta, buyerCountry = serviceData.buyerCountry;
            var sdkVersion = config.sdkVersion, firebase = config.firebase;
            var webCheckoutUrl = function(_ref3) {
                var orderID = _ref3.orderID, props = _ref3.props, fundingSource = _ref3.fundingSource, facilitatorAccessToken = _ref3.facilitatorAccessToken;
                var commit = props.commit;
                return Object(src.extendUrl)("" + getNativeDomain({
                    props: props
                }) + src_config.WEB_CHECKOUT_URI, {
                    query: {
                        fundingSource: fundingSource,
                        facilitatorAccessToken: facilitatorAccessToken,
                        token: orderID,
                        useraction: commit ? constants.USER_ACTION.COMMIT : constants.USER_ACTION.CONTINUE,
                        native_xo: "1"
                    }
                });
            }({
                orderID: orderID,
                props: props,
                fundingSource: fundingSource,
                facilitatorAccessToken: facilitatorAccessToken
            });
            var forceEligible = isNativeOptedIn({
                props: props
            });
            var channel = Object(src.isDevice)() ? "mobile-web" : "desktop-web";
            if (!firebase) throw new Error("Can not find firebase config");
            var queryParams = {
                channel: channel,
                sdkMeta: sdkMeta,
                sessionUID: sessionUID,
                orderID: orderID,
                facilitatorAccessToken: facilitatorAccessToken,
                pageUrl: pageUrl,
                clientID: clientID,
                commit: String(commit),
                webCheckoutUrl: Object(lib.isIOSSafari)() ? webCheckoutUrl : "",
                stickinessID: stickinessID,
                buttonSessionID: buttonSessionID,
                env: env,
                stageHost: stageHost || "",
                apiStageHost: apiStageHost || "",
                forceEligible: forceEligible,
                fundingSource: fundingSource,
                enableFunding: enableFunding.join(","),
                domain: merchantDomain,
                rtdbInstanceID: firebase.databaseURL,
                buyerCountry: buyerCountry,
                sdkVersion: sdkVersion
            };
            "desktop-web" === queryParams.channel && delete queryParams.sdkMeta;
            return queryParams;
        }
        function getNativeUrl(_ref5) {
            var props = _ref5.props, fundingSource = _ref5.fundingSource;
            var queryParams = getNativeUrlQueryParams({
                props: props,
                serviceData: _ref5.serviceData,
                config: _ref5.config,
                fundingSource: fundingSource,
                sessionUID: _ref5.sessionUID,
                pageUrl: _ref5.pageUrl,
                orderID: _ref5.orderID,
                stickinessID: _ref5.stickinessID
            });
            return Object(src.extendUrl)("" + getNativeDomain({
                props: props
            }) + NATIVE_CHECKOUT_URI[fundingSource], {
                query: queryParams
            });
        }
        function getNativeFallbackUrl(_ref6) {
            var props = _ref6.props, fundingSource = _ref6.fundingSource;
            var queryParams = getNativeUrlQueryParams({
                props: props,
                serviceData: _ref6.serviceData,
                config: _ref6.config,
                fundingSource: fundingSource,
                sessionUID: _ref6.sessionUID,
                pageUrl: _ref6.pageUrl,
                orderID: _ref6.orderID,
                stickinessID: _ref6.stickinessID
            });
            return Object(src.extendUrl)("" + getNativeDomain({
                props: props
            }) + NATIVE_CHECKOUT_FALLBACK_URI[fundingSource], {
                query: queryParams
            });
        }
        var getNativeSocket = Object(src.memoize)((function(_ref) {
            var sessionUID = _ref.sessionUID, firebaseConfig = _ref.firebaseConfig, version = _ref.version;
            var nativeSocket = Object(api.firebaseSocket)({
                sessionUID: sessionUID,
                sourceApp: "paypal_smart_payment_buttons",
                sourceAppVersion: version,
                targetApp: "paypal_native_checkout",
                config: firebaseConfig
            });
            nativeSocket.onError((function(err) {
                var stringifiedError = Object(src.stringifyError)(err);
                if (stringifiedError && -1 === stringifiedError.toLowerCase().indexOf("permission_denied")) {
                    var _getLogger$error$trac;
                    Object(lib.getLogger)().error("native_socket_error", {
                        err: stringifiedError
                    }).track((_getLogger$error$trac = {}, _getLogger$error$trac[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                    _getLogger$error$trac[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_APP_SWITCH_ACK, 
                    _getLogger$error$trac[constants.FPTI_CUSTOM_KEY.ERR_DESC] = "[Native Socket Error] " + stringifiedError, 
                    _getLogger$error$trac)).flush();
                }
            }));
            return nativeSocket;
        }));
        function connectNative(_ref2) {
            var config = _ref2.config, sessionUID = _ref2.sessionUID, callbacks = _ref2.callbacks;
            var onInit = callbacks.onInit, onApprove = callbacks.onApprove, onCancel = callbacks.onCancel, onShippingChange = callbacks.onShippingChange, onError = callbacks.onError, onFallback = callbacks.onFallback;
            var firebaseConfig = config.firebase, sdkVersion = config.sdkVersion;
            if (!firebaseConfig) throw new Error("Firebase config not found");
            var socket = getNativeSocket({
                sessionUID: sessionUID,
                firebaseConfig: firebaseConfig,
                version: sdkVersion
            });
            var onInitListener = socket.on("onInit", onInit);
            var onShippingChangeListener = socket.on("onShippingChange", onShippingChange);
            var onApproveListener = socket.on("onApprove", onApprove);
            var onCancelListener = socket.on("onCancel", onCancel);
            var onErrorListener = socket.on("onError", onError);
            var onFallbackListener = socket.on("onFallback", onFallback);
            return {
                cancel: function() {
                    return zalgo_promise_src.ZalgoPromise.all([ onInitListener.cancel(), onShippingChangeListener.cancel(), onApproveListener.cancel(), onCancelListener.cancel(), onErrorListener.cancel(), onFallbackListener.cancel() ]).then(src.noop);
                }
            };
        }
        function getEligibility(_ref) {
            var fundingSource = _ref.fundingSource, props = _ref.props, serviceData = _ref.serviceData, validatePromise = _ref.validatePromise;
            var createOrder = props.createOrder, vault = props.vault, clientID = props.clientID, currency = props.currency, buttonSessionID = props.buttonSessionID, enableFunding = props.enableFunding, merchantDomain = props.merchantDomain, disableSetCookie = props.disableSetCookie;
            var buyerCountry = serviceData.buyerCountry, cookies = serviceData.cookies, merchantID = serviceData.merchantID;
            var shippingCallbackEnabled = Boolean(props.onShippingChange);
            var platform = sdk_constants_src.PLATFORM.MOBILE;
            return validatePromise.then((function(valid) {
                return !!valid && (!!isNativeOptedIn({
                    props: props
                }) || createOrder().then((function(orderID) {
                    var _headers;
                    return Object(api.getNativeEligibility)({
                        vault: vault,
                        platform: platform,
                        shippingCallbackEnabled: shippingCallbackEnabled,
                        clientID: clientID,
                        buyerCountry: buyerCountry,
                        currency: currency,
                        buttonSessionID: buttonSessionID,
                        cookies: cookies,
                        orderID: orderID,
                        enableFunding: enableFunding,
                        merchantID: merchantID[0],
                        domain: merchantDomain,
                        skipElmo: !0,
                        headers: (_headers = {}, _headers[constants.HEADERS.DISABLE_SET_COOKIE] = String(disableSetCookie), 
                        _headers)
                    }).then((function(eligibility) {
                        var _eligibility$fundingS;
                        var eligibleReasons = [ "isUserAgentEligible", "isBrowserMobileAndroid" ];
                        var ineligibleReasons = eligibility && (null == (_eligibility$fundingS = eligibility[fundingSource]) || null == (_eligibility$fundingS = _eligibility$fundingS.ineligibilityReason) ? void 0 : _eligibility$fundingS.split(","));
                        var eligible = null == ineligibleReasons ? void 0 : ineligibleReasons.every((function(reason) {
                            return !reason || -1 !== (null == eligibleReasons ? void 0 : eligibleReasons.indexOf(reason));
                        }));
                        if (ineligibleReasons && !eligible) {
                            var _getLogger$info$track;
                            Object(lib.getLogger)().info("native_appswitch_ineligible", {
                                orderID: orderID
                            }).track((_getLogger$info$track = {}, _getLogger$info$track[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                            _getLogger$info$track[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_APP_SWITCH_INELIGIBLE, 
                            _getLogger$info$track[constants.FPTI_CUSTOM_KEY.INFO_MSG] = null == ineligibleReasons ? void 0 : ineligibleReasons.join(","), 
                            _getLogger$info$track)).flush();
                            return !1;
                        }
                        return !0;
                    }));
                })));
            }));
        }
        function initNativeQRCode(_ref2) {
            var props = _ref2.props, serviceData = _ref2.serviceData, config = _ref2.config, components = _ref2.components, payment = _ref2.payment, clean = _ref2.clean, fallback = _ref2.fallback, callbacks = _ref2.callbacks, sessionUID = _ref2.sessionUID;
            var buttonSessionID = props.buttonSessionID, createOrder = props.createOrder, onClick = props.onClick;
            var QRCode = components.QRCode;
            var fundingSource = payment.fundingSource;
            var onInit = callbacks.onInit, onApprove = callbacks.onApprove, onCancel = callbacks.onCancel, onError = callbacks.onError, onClose = callbacks.onClose, onDestroy = callbacks.onDestroy, onShippingChange = callbacks.onShippingChange;
            var qrCodeRenderTarget = window.xprops.getParent();
            var pageUrl = window.xprops.getPageUrl();
            var stickinessID = Object(lib.getStorageID)();
            return {
                click: src.noop,
                start: function() {
                    var _getLogger$info$track2, _getLogger$info$track3;
                    Object(lib.getLogger)().info("VenmoDesktopPay_qrcode").track((_getLogger$info$track2 = {}, 
                    _getLogger$info$track2[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.QR_SHOWN, 
                    _getLogger$info$track2)).flush();
                    Object(lib.getLogger)().info("VenmoDesktopPay_qrcode_prepare_escape").track((_getLogger$info$track3 = {}, 
                    _getLogger$info$track3[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.QR_PREPARE_PAY, 
                    _getLogger$info$track3)).flush();
                    var onQRClose = function(event) {
                        void 0 === event && (event = "closeQRCode");
                        return zalgo_promise_src.ZalgoPromise.try((function() {
                            var _getLogger$info$track4;
                            Object(lib.getLogger)().info("VenmoDesktopPay_qrcode_closing_" + event).track((_getLogger$info$track4 = {}, 
                            _getLogger$info$track4[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                            _getLogger$info$track4[sdk_constants_src.FPTI_KEY.TRANSITION] = event ? constants.FPTI_TRANSITION.QR_CLOSING + "_" + event : constants.FPTI_TRANSITION.QR_CLOSING, 
                            _getLogger$info$track4)).flush();
                            onClose();
                        }));
                    };
                    var restart = function() {
                        return zalgo_promise_src.ZalgoPromise.try((function() {
                            throw new Error("QRcode restart not implemented");
                        }));
                    };
                    var onEscapePath = function(win, selectedFundingSource) {
                        var _getLogger$info$track5;
                        Object(lib.getLogger)().info("VenmoDesktopPay_process_pay_with_" + selectedFundingSource).track((_getLogger$info$track5 = {}, 
                        _getLogger$info$track5[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                        _getLogger$info$track5[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.QR_PROCESS_PAY_WITH + "_" + selectedFundingSource, 
                        _getLogger$info$track5)).flush();
                        return zalgo_promise_src.ZalgoPromise.try((function() {
                            var paymentInfo = Object(esm_extends.default)({}, payment, {
                                win: win,
                                fundingSource: selectedFundingSource
                            });
                            return checkout.init({
                                props: props,
                                components: components,
                                payment: paymentInfo,
                                config: config,
                                serviceData: serviceData,
                                restart: restart
                            }).start().then((function() {
                                return zalgo_promise_src.ZalgoPromise.resolve();
                            }));
                        }));
                    };
                    var validatePromise = zalgo_promise_src.ZalgoPromise.try((function() {
                        return !onClick || onClick({
                            fundingSource: fundingSource
                        });
                    })).then((function(valid) {
                        if (!valid) {
                            var _getLogger$info$track6;
                            Object(lib.getLogger)().info("native_onclick_invalid").track((_getLogger$info$track6 = {}, 
                            _getLogger$info$track6[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                            _getLogger$info$track6[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_ON_CLICK_INVALID, 
                            _getLogger$info$track6)).flush();
                        }
                        return valid;
                    }));
                    return zalgo_promise_src.ZalgoPromise.hash({
                        valid: validatePromise,
                        eligible: getEligibility({
                            fundingSource: fundingSource,
                            props: props,
                            serviceData: serviceData,
                            validatePromise: validatePromise
                        })
                    }).then((function(_ref3) {
                        if (_ref3.valid) return _ref3.eligible ? createOrder().then((function(orderID) {
                            var url = getNativeUrl({
                                props: props,
                                serviceData: serviceData,
                                config: config,
                                fundingSource: fundingSource,
                                sessionUID: sessionUID,
                                orderID: orderID,
                                stickinessID: stickinessID,
                                pageUrl: pageUrl
                            });
                            var cancelModal = function() {
                                return zalgo_promise_src.ZalgoPromise.try((function() {
                                    return onCancel();
                                })).then((function() {
                                    qrCodeComponentInstance.close();
                                    return onDestroy();
                                }));
                            };
                            var qrCodeComponentInstance = QRCode({
                                cspNonce: config.cspNonce,
                                qrPath: url,
                                state: constants.QRCODE_STATE.DEFAULT,
                                orderID: orderID,
                                onClose: onQRClose,
                                onCancel: cancelModal,
                                onEscapePath: onEscapePath
                            });
                            function updateQRCodeComponentState(newState) {
                                return qrCodeComponentInstance.updateProps(Object(esm_extends.default)({
                                    cspNonce: config.cspNonce,
                                    qrPath: url,
                                    orderID: orderID,
                                    onClose: onQRClose,
                                    onCancel: cancelModal,
                                    onEscapePath: onEscapePath
                                }, newState));
                            }
                            var closeQRCode = function(event) {
                                onQRClose(event);
                                return zalgo_promise_src.ZalgoPromise.delay(2e3).then((function() {
                                    return zalgo_promise_src.ZalgoPromise.try((function() {
                                        qrCodeComponentInstance.close();
                                        return onDestroy();
                                    }));
                                })).then(src.noop);
                            };
                            var connection = connectNative({
                                config: config,
                                sessionUID: sessionUID,
                                callbacks: {
                                    onInit: function() {
                                        return updateQRCodeComponentState({
                                            state: constants.QRCODE_STATE.SCANNED
                                        }).then((function() {
                                            return onInit();
                                        }));
                                    },
                                    onApprove: function(res) {
                                        return updateQRCodeComponentState({
                                            state: constants.QRCODE_STATE.AUTHORIZED
                                        }).then((function() {
                                            return closeQRCode("onApprove").then((function() {
                                                return onApprove(res);
                                            }));
                                        }));
                                    },
                                    onCancel: function() {
                                        return zalgo_promise_src.ZalgoPromise.try((function() {
                                            return onCancel();
                                        })).then((function() {
                                            return closeQRCode("onCancel");
                                        })).then((function() {
                                            return {
                                                buttonSessionID: buttonSessionID
                                            };
                                        }));
                                    },
                                    onError: function(res) {
                                        return updateQRCodeComponentState({
                                            state: constants.QRCODE_STATE.AUTHORIZED,
                                            errorText: res.data.message
                                        }).then((function() {
                                            return onError(res);
                                        }));
                                    },
                                    onFallback: function(_ref4) {
                                        var fallbackOptions = _ref4.data;
                                        return updateQRCodeComponentState({
                                            state: constants.QRCODE_STATE.ERROR,
                                            errorText: "The authorization was canceled"
                                        }).then((function() {
                                            return fallback({
                                                fallbackOptions: fallbackOptions
                                            });
                                        })).then((function() {
                                            return {
                                                buttonSessionID: buttonSessionID
                                            };
                                        }));
                                    },
                                    onShippingChange: onShippingChange
                                }
                            });
                            clean.register(connection.cancel);
                            return qrCodeComponentInstance.renderTo(qrCodeRenderTarget, constants.TARGET_ELEMENT.BODY);
                        })) : fallback().then(src.noop);
                    }));
                }
            };
        }
        function popup_getEligibility(_ref3) {
            var fundingSource = _ref3.fundingSource, props = _ref3.props, serviceData = _ref3.serviceData, sfvc = _ref3.sfvc, validatePromise = _ref3.validatePromise, stickinessID = _ref3.stickinessID, appDetect = _ref3.appDetect;
            var createOrder = props.createOrder, vault = props.vault, platform = props.platform, clientID = props.clientID, currency = props.currency, buttonSessionID = props.buttonSessionID, enableFunding = props.enableFunding, merchantDomain = props.merchantDomain, disableSetCookie = props.disableSetCookie;
            var buyerCountry = serviceData.buyerCountry, cookies = serviceData.cookies, merchantID = serviceData.merchantID;
            var shippingCallbackEnabled = Boolean(props.onShippingChange);
            return validatePromise.then((function(valid) {
                return !!valid && (!!isNativeOptedIn({
                    props: props
                }) || !!function(_ref2) {
                    var appDetect = _ref2.appDetect;
                    return null === appDetect || _ref2.fundingSource !== sdk_constants_src.FUNDING.PAYPAL || !(!appDetect.installed || !function(_ref) {
                        var version = _ref.version;
                        if (!version) return !1;
                        var num = version.split(".");
                        return parseInt(num.join(""), 10) > 850;
                    }({
                        version: null == appDetect ? void 0 : appDetect.version
                    }));
                }({
                    fundingSource: fundingSource,
                    appDetect: appDetect
                }) && (!sfvc || fundingSource === sdk_constants_src.FUNDING.VENMO) && createOrder().then((function(orderID) {
                    var _headers;
                    return Object(api.getNativeEligibility)({
                        vault: vault,
                        platform: platform,
                        shippingCallbackEnabled: shippingCallbackEnabled,
                        clientID: clientID,
                        buyerCountry: buyerCountry,
                        currency: currency,
                        buttonSessionID: buttonSessionID,
                        cookies: cookies,
                        orderID: orderID,
                        enableFunding: enableFunding,
                        stickinessID: stickinessID,
                        merchantID: merchantID[0],
                        domain: merchantDomain,
                        headers: (_headers = {}, _headers[constants.HEADERS.DISABLE_SET_COOKIE] = String(disableSetCookie), 
                        _headers)
                    }).then((function(eligibility) {
                        var _eligibility$fundingS;
                        var ineligibilityReason = eligibility && null != (_eligibility$fundingS = eligibility[fundingSource]) && _eligibility$fundingS.ineligibilityReason ? eligibility[fundingSource].ineligibilityReason : "";
                        if (!eligibility || !eligibility[fundingSource] || !eligibility[fundingSource].eligibility) {
                            var _getLogger$info$track2;
                            Object(lib.getLogger)().info("native_appswitch_ineligible", {
                                orderID: orderID
                            }).track((_getLogger$info$track2 = {}, _getLogger$info$track2[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                            _getLogger$info$track2[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_APP_SWITCH_INELIGIBLE, 
                            _getLogger$info$track2[constants.FPTI_CUSTOM_KEY.INFO_MSG] = ineligibilityReason, 
                            _getLogger$info$track2)).flush();
                            return !1;
                        }
                        return !0;
                    }));
                })));
            }));
        }
        function initNativePopup(_ref4) {
            var payment = _ref4.payment, props = _ref4.props, serviceData = _ref4.serviceData, config = _ref4.config, sessionUID = _ref4.sessionUID, fallback = _ref4.fallback, callbacks = _ref4.callbacks, clean = _ref4.clean;
            var buttonSessionID = props.buttonSessionID, onClick = props.onClick, createOrder = props.createOrder;
            var fundingSource = payment.fundingSource, win = payment.win;
            var _onInit = callbacks.onInit, _onApprove = callbacks.onApprove, _onCancel = callbacks.onCancel, _onError = callbacks.onError, onClose = callbacks.onClose, onDestroy = callbacks.onDestroy, _onShippingChange = callbacks.onShippingChange;
            if (!config.firebase) throw new Error("Can not load popup without firebase config");
            var nativePopupPromise;
            return {
                click: function() {
                    nativePopupPromise = new zalgo_promise_src.ZalgoPromise((function(resolve, reject) {
                        var url = function(_ref8) {
                            var props = _ref8.props, fundingSource = _ref8.fundingSource;
                            var queryParams = function(_ref7) {
                                var props = _ref7.props, serviceData = _ref7.serviceData;
                                var buttonSessionID = props.buttonSessionID, env = props.env, clientID = props.clientID, sessionID = props.sessionID, sdkCorrelationID = props.sdkCorrelationID;
                                var sdkMeta = serviceData.sdkMeta, buyerCountry = serviceData.buyerCountry;
                                var parentDomain = Object(cross_domain_utils_src.getDomain)();
                                return {
                                    buttonSessionID: buttonSessionID,
                                    buyerCountry: buyerCountry,
                                    clientID: clientID,
                                    channel: Object(src.isDevice)() ? "mobile-web" : "desktop-web",
                                    env: env,
                                    parentDomain: parentDomain,
                                    sdkCorrelationID: sdkCorrelationID,
                                    sdkMeta: sdkMeta,
                                    sessionID: sessionID
                                };
                            }({
                                props: props,
                                serviceData: _ref8.serviceData,
                                fundingSource: fundingSource
                            });
                            return Object(src.extendUrl)("" + getNativePopupDomain({
                                props: props
                            }) + NATIVE_CHECKOUT_POPUP_URI[fundingSource], {
                                query: queryParams
                            }) + "#init";
                        }({
                            props: props,
                            serviceData: serviceData,
                            fundingSource: fundingSource
                        });
                        var nativePopupDomain = getNativePopupDomain({
                            props: props
                        });
                        var nativePopupWinProxy = function(url) {
                            var _getLogger$info$track3;
                            var proxyWin;
                            if (win) {
                                var nativePopupWinProxy = Object(lib.toProxyWindow)(win);
                                nativePopupWinProxy.setLocation(url);
                                proxyWin = nativePopupWinProxy;
                            } else proxyWin = Object(lib.toProxyWindow)(Object(src.popup)(url));
                            Object(lib.getLogger)().info("native_attempt_appswitch_popup_shown").track((_getLogger$info$track3 = {}, 
                            _getLogger$info$track3[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                            _getLogger$info$track3[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_POPUP_SHOWN, 
                            _getLogger$info$track3)).flush();
                            return proxyWin;
                        }(url);
                        var cleanupPopupWin = clean.register((function() {
                            return nativePopupWinProxy.close();
                        }));
                        var validatePromise = zalgo_promise_src.ZalgoPromise.try((function() {
                            return !onClick || onClick({
                                fundingSource: fundingSource
                            });
                        })).then((function(valid) {
                            if (!valid) {
                                var _getLogger$info$track4;
                                Object(lib.getLogger)().info("native_onclick_invalid").track((_getLogger$info$track4 = {}, 
                                _getLogger$info$track4[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                                _getLogger$info$track4[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_ON_CLICK_INVALID, 
                                _getLogger$info$track4)).flush();
                            }
                            return valid;
                        }));
                        var orderPromise = validatePromise.then((function(valid) {
                            return valid ? createOrder() : Object(lib.unresolvedPromise)();
                        }));
                        var handleFallback = function(fallbackOptions) {
                            cleanupPopupWin.cancel();
                            return fallback({
                                win: nativePopupWinProxy,
                                fallbackOptions: fallbackOptions
                            }).then((function() {
                                return {
                                    buttonSessionID: buttonSessionID
                                };
                            }));
                        };
                        var changeDomainAndAwaitFallback = function(_ref5) {
                            var pageUrl = _ref5.pageUrl, stickinessID = _ref5.stickinessID, fallbackOptions = _ref5.fallbackOptions;
                            return nativePopupWinProxy.isClosed().then((function(isClosed) {
                                if (isClosed) return handleFallback(fallbackOptions);
                                fallbackOptions && setNativeOptOut(fallbackOptions);
                                return orderPromise.then((function(orderID) {
                                    nativePopupWinProxy.setLocation(getNativeFallbackUrl({
                                        props: props,
                                        serviceData: serviceData,
                                        config: config,
                                        fundingSource: fundingSource,
                                        sessionUID: sessionUID,
                                        pageUrl: pageUrl,
                                        orderID: orderID,
                                        stickinessID: stickinessID
                                    }));
                                }));
                            }));
                        };
                        var onDetectAppSwitch = Object(src.once)((function() {
                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                var _getLogger$info$track5;
                                resolve();
                                Object(api.onLsatUpgradeCalled)();
                                Object(lib.getLogger)().info("native_detect_app_switch").track((_getLogger$info$track5 = {}, 
                                _getLogger$info$track5[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_DETECT_APP_SWITCH, 
                                _getLogger$info$track5)).flush();
                                Object(lib.getStorageState)((function(state) {
                                    var _state$lastAppSwitchT = state.lastAppSwitchTime, lastAppSwitchTime = void 0 === _state$lastAppSwitchT ? 0 : _state$lastAppSwitchT, _state$lastWebSwitchT = state.lastWebSwitchTime, lastWebSwitchTime = void 0 === _state$lastWebSwitchT ? 0 : _state$lastWebSwitchT;
                                    lastAppSwitchTime > lastWebSwitchTime && Object(lib.getLogger)().info("app_switch_detect_with_previous_app_switch", {
                                        lastAppSwitchTime: lastAppSwitchTime.toString(),
                                        lastWebSwitchTime: lastWebSwitchTime.toString()
                                    });
                                    lastWebSwitchTime > lastAppSwitchTime && Object(lib.getLogger)().info("app_switch_detect_with_previous_web_switch", {
                                        lastAppSwitchTime: lastAppSwitchTime.toString(),
                                        lastWebSwitchTime: lastWebSwitchTime.toString()
                                    });
                                    lastAppSwitchTime || lastWebSwitchTime || Object(lib.getLogger)().info("app_switch_detect_with_no_previous_switch", {
                                        lastAppSwitchTime: lastAppSwitchTime.toString(),
                                        lastWebSwitchTime: lastWebSwitchTime.toString()
                                    });
                                    state.lastAppSwitchTime = Date.now();
                                }));
                            }));
                        }));
                        var onDetectPossibleAppSwitch = Object(src.once)((function(_ref6) {
                            var pageUrl = _ref6.pageUrl, stickinessID = _ref6.stickinessID;
                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                var _getLogger$info$track6;
                                Object(api.onLsatUpgradeCalled)();
                                Object(lib.getLogger)().info("native_detect_possible_app_switch").track((_getLogger$info$track6 = {}, 
                                _getLogger$info$track6[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_DETECT_POSSIBLE_APP_SWITCH, 
                                _getLogger$info$track6)).flush();
                                var connection = connectNative({
                                    config: config,
                                    sessionUID: sessionUID,
                                    callbacks: {
                                        onInit: function() {
                                            onDetectAppSwitch();
                                            return _onInit();
                                        },
                                        onApprove: function(_ref7) {
                                            var data = _ref7.data;
                                            onDetectAppSwitch();
                                            return _onApprove({
                                                data: data
                                            });
                                        },
                                        onCancel: function() {
                                            onDetectAppSwitch();
                                            return _onCancel();
                                        },
                                        onShippingChange: function(_ref8) {
                                            var data = _ref8.data;
                                            onDetectAppSwitch();
                                            return _onShippingChange({
                                                data: data
                                            });
                                        },
                                        onError: function(_ref9) {
                                            var data = _ref9.data;
                                            onDetectAppSwitch();
                                            reject(new Error(data.message));
                                            return _onError({
                                                data: data
                                            });
                                        },
                                        onFallback: function(_ref10) {
                                            var fallbackOptions = _ref10.data;
                                            onDetectAppSwitch();
                                            return changeDomainAndAwaitFallback({
                                                pageUrl: pageUrl,
                                                stickinessID: stickinessID,
                                                fallbackOptions: fallbackOptions
                                            }).then((function() {
                                                return {
                                                    buttonSessionID: buttonSessionID
                                                };
                                            }));
                                        }
                                    }
                                });
                                clean.register(connection.cancel);
                            })).catch(reject);
                        }));
                        var onDetectWebSwitch = Object(src.once)((function() {
                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                var _getLogger$info$track7;
                                Object(lib.getStorageState)((function(state) {
                                    var _state$lastAppSwitchT2 = state.lastAppSwitchTime, lastAppSwitchTime = void 0 === _state$lastAppSwitchT2 ? 0 : _state$lastAppSwitchT2, _state$lastWebSwitchT2 = state.lastWebSwitchTime, lastWebSwitchTime = void 0 === _state$lastWebSwitchT2 ? 0 : _state$lastWebSwitchT2;
                                    lastAppSwitchTime > lastWebSwitchTime && Object(lib.getLogger)().info("web_switch_detect_with_previous_app_switch", {
                                        lastAppSwitchTime: lastAppSwitchTime.toString(),
                                        lastWebSwitchTime: lastWebSwitchTime.toString()
                                    });
                                    lastWebSwitchTime > lastAppSwitchTime && Object(lib.getLogger)().info("web_switch_detect_with_previous_web_switch", {
                                        lastAppSwitchTime: lastAppSwitchTime.toString(),
                                        lastWebSwitchTime: lastWebSwitchTime.toString()
                                    });
                                    lastAppSwitchTime || lastWebSwitchTime || Object(lib.getLogger)().info("web_switch_detect_with_no_previous_switch", {
                                        lastAppSwitchTime: lastAppSwitchTime.toString(),
                                        lastWebSwitchTime: lastWebSwitchTime.toString()
                                    });
                                    state.lastWebSwitchTime = Date.now();
                                }));
                                Object(lib.getLogger)().info("native_detect_web_switch").track((_getLogger$info$track7 = {}, 
                                _getLogger$info$track7[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_DETECT_WEB_SWITCH, 
                                _getLogger$info$track7)).flush();
                                return handleFallback().then(src.noop);
                            })).then(resolve, reject);
                        }));
                        var closeListener = Object(lib.onCloseProxyWindow)(nativePopupWinProxy, (function() {
                            var _getLogger$info$track8;
                            Object(lib.getLogger)().info("native_popup_closed").track((_getLogger$info$track8 = {}, 
                            _getLogger$info$track8[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                            _getLogger$info$track8[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_POPUP_CLOSED, 
                            _getLogger$info$track8)).flush();
                            reject(new Error("Native popup closed"));
                            onClose();
                        }), 500);
                        var closePopup = function(event) {
                            var _getLogger$info$track9;
                            Object(lib.getLogger)().info("native_closing_popup_" + event).track((_getLogger$info$track9 = {}, 
                            _getLogger$info$track9[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                            _getLogger$info$track9[sdk_constants_src.FPTI_KEY.TRANSITION] = event ? constants.FPTI_TRANSITION.NATIVE_CLOSING_POPUP + "_" + event : constants.FPTI_TRANSITION.NATIVE_CLOSING_POPUP, 
                            _getLogger$info$track9)).flush();
                            closeListener.cancel();
                            nativePopupWinProxy.close();
                        };
                        var awaitRedirectListener = Object(lib.postRobotOnceProxy)("awaitRedirect", {
                            proxyWin: nativePopupWinProxy,
                            domain: nativePopupDomain
                        }, (function(_ref11) {
                            var _ref11$data = _ref11.data, appDetect = _ref11$data.app, pageUrl = _ref11$data.pageUrl, sfvc = _ref11$data.sfvc, stickinessID = _ref11$data.stickinessID;
                            Object(lib.getLogger)().info("native_post_message_await_redirect").flush();
                            !function(app) {
                                if (app) {
                                    var _getLogger$info$track;
                                    var logMessage = "native_app";
                                    Object.keys(app).forEach((function(key) {
                                        logMessage += "_" + String(app[key]);
                                    }));
                                    Object(lib.getLogger)().info(logMessage).track((_getLogger$info$track = {}, _getLogger$info$track[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                                    _getLogger$info$track[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_APP_INSTALLED, 
                                    _getLogger$info$track[constants.FPTI_CUSTOM_KEY.INFO_MSG] = logMessage, _getLogger$info$track)).flush();
                                }
                            }(appDetect);
                            Object(lib.getLogger)().addTrackingBuilder((function() {
                                var _ref12;
                                return (_ref12 = {})[sdk_constants_src.FPTI_KEY.STICKINESS_ID] = stickinessID, _ref12;
                            }));
                            var onDetectPossibleAppSwitchListener = Object(lib.postRobotOnceProxy)("detectAppSwitch", {
                                proxyWin: nativePopupWinProxy,
                                domain: nativePopupDomain
                            }, (function() {
                                Object(lib.getLogger)().info("native_post_message_detect_possible_app_switch").flush();
                                return onDetectPossibleAppSwitch({
                                    pageUrl: pageUrl,
                                    stickinessID: stickinessID
                                });
                            }));
                            var onDetectWebSwitchListener = Object(lib.postRobotOnceProxy)("detectWebSwitch", {
                                proxyWin: nativePopupWinProxy,
                                domain: getNativeDomain({
                                    props: props
                                })
                            }, (function() {
                                Object(lib.getLogger)().info("native_post_message_detect_web_switch").flush();
                                return onDetectWebSwitch();
                            }));
                            var onApproveListener = Object(lib.postRobotOnceProxy)("onApprove", {
                                proxyWin: nativePopupWinProxy,
                                domain: nativePopupDomain
                            }, (function(_ref13) {
                                var data = _ref13.data;
                                onDetectAppSwitch();
                                _onApprove({
                                    data: data
                                });
                                closePopup("onApprove");
                            }));
                            var onCancelListener = Object(lib.postRobotOnceProxy)("onCancel", {
                                proxyWin: nativePopupWinProxy,
                                domain: nativePopupDomain
                            }, (function() {
                                onDetectAppSwitch();
                                _onCancel();
                                closePopup("onCancel");
                            }));
                            var onFallbackListener = Object(lib.postRobotOnceProxy)("onFallback", {
                                proxyWin: nativePopupWinProxy,
                                domain: nativePopupDomain
                            }, (function(_ref14) {
                                var _getLogger$info$track10;
                                var fallbackOptions = _ref14.data;
                                onDetectAppSwitch();
                                Object(lib.getLogger)().info("native_message_onfallback").track((_getLogger$info$track10 = {}, 
                                _getLogger$info$track10[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_ON_FALLBACK, 
                                _getLogger$info$track10)).flush();
                                changeDomainAndAwaitFallback({
                                    pageUrl: pageUrl,
                                    stickinessID: stickinessID,
                                    fallbackOptions: fallbackOptions
                                });
                            }));
                            var onCompleteListener = Object(lib.postRobotOnceProxy)("onComplete", {
                                proxyWin: nativePopupWinProxy,
                                domain: nativePopupDomain
                            }, (function() {
                                var _getLogger$info$track11;
                                onDetectAppSwitch();
                                Object(lib.getLogger)().info("native_post_message_on_complete").track((_getLogger$info$track11 = {}, 
                                _getLogger$info$track11[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                                _getLogger$info$track11[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_ON_COMPLETE, 
                                _getLogger$info$track11)).flush();
                                closePopup("onComplete");
                            }));
                            var onErrorListener = Object(lib.postRobotOnceProxy)("onError", {
                                proxyWin: nativePopupWinProxy,
                                domain: nativePopupDomain
                            }, (function(_ref15) {
                                var data = _ref15.data;
                                _onError({
                                    data: data
                                });
                                closePopup("onError");
                                reject(new Error(data.message));
                            }));
                            window.addEventListener("pagehide", (function() {
                                return closePopup("pagehide");
                            }));
                            window.addEventListener("unload", (function() {
                                return closePopup("unload");
                            }));
                            clean.register((function() {
                                return zalgo_promise_src.ZalgoPromise.all([ awaitRedirectListener.cancel(), onDetectPossibleAppSwitchListener.cancel(), onApproveListener.cancel(), onCancelListener.cancel(), onFallbackListener.cancel(), onCompleteListener.cancel(), onErrorListener.cancel(), onDetectWebSwitchListener.cancel(), closeListener.cancel() ]).then(src.noop);
                            }));
                            return zalgo_promise_src.ZalgoPromise.hash({
                                valid: validatePromise,
                                eligible: popup_getEligibility({
                                    fundingSource: fundingSource,
                                    props: props,
                                    serviceData: serviceData,
                                    sfvc: sfvc,
                                    validatePromise: validatePromise,
                                    stickinessID: stickinessID,
                                    appDetect: appDetect
                                })
                            }).then((function(_ref16) {
                                var eligible = _ref16.eligible;
                                if (!_ref16.valid) {
                                    closeListener.cancel();
                                    nativePopupWinProxy.close();
                                    return onDestroy().then((function() {
                                        return {
                                            appSwitch: !1,
                                            orderID: null,
                                            redirect: !1
                                        };
                                    }));
                                }
                                return orderPromise.then(eligible ? function(orderID) {
                                    var _getLogger$info$track12;
                                    var nativeUrl = getNativeUrl({
                                        props: props,
                                        serviceData: serviceData,
                                        config: config,
                                        fundingSource: fundingSource,
                                        sessionUID: sessionUID,
                                        pageUrl: pageUrl,
                                        orderID: orderID,
                                        stickinessID: stickinessID
                                    });
                                    Object(lib.getLogger)().info("native_attempt_appswitch_url_popup", {
                                        url: nativeUrl
                                    }).track((_getLogger$info$track12 = {}, _getLogger$info$track12[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                                    _getLogger$info$track12[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_ATTEMPT_APP_SWITCH, 
                                    _getLogger$info$track12[constants.FPTI_CUSTOM_KEY.INFO_MSG] = nativeUrl, _getLogger$info$track12)).flush();
                                    if (Object(lib.isAndroidChrome)()) {
                                        closeListener.cancel();
                                        var appSwitchCloseListener = Object(lib.onCloseProxyWindow)(nativePopupWinProxy, (function() {
                                            return onDetectPossibleAppSwitch({
                                                pageUrl: pageUrl,
                                                stickinessID: stickinessID
                                            });
                                        }), 50);
                                        setTimeout(appSwitchCloseListener.cancel, 1e3);
                                    }
                                    return {
                                        appSwitch: !0,
                                        orderID: orderID,
                                        redirect: !0,
                                        redirectUrl: nativeUrl
                                    };
                                } : function(orderID) {
                                    return {
                                        redirect: !0,
                                        appSwitch: !1,
                                        orderID: orderID,
                                        redirectUrl: getNativeFallbackUrl({
                                            props: props,
                                            serviceData: serviceData,
                                            config: config,
                                            fundingSource: fundingSource,
                                            sessionUID: sessionUID,
                                            pageUrl: pageUrl,
                                            orderID: orderID,
                                            stickinessID: stickinessID
                                        })
                                    };
                                });
                            })).catch((function(err) {
                                var _getLogger$info$track13;
                                Object(lib.getLogger)().info("native_attempt_appswitch_url_popup_errored").track((_getLogger$info$track13 = {}, 
                                _getLogger$info$track13[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                                _getLogger$info$track13[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_ATTEMPT_APP_SWITCH_ERRORED, 
                                _getLogger$info$track13[constants.FPTI_CUSTOM_KEY.ERR_DESC] = Object(src.stringifyError)(err), 
                                _getLogger$info$track13)).flush();
                                return orderPromise.then((function(orderID) {
                                    return {
                                        appSwitch: !1,
                                        orderID: orderID,
                                        redirect: !0,
                                        redirectUrl: getNativeFallbackUrl({
                                            props: props,
                                            serviceData: serviceData,
                                            config: config,
                                            fundingSource: fundingSource,
                                            sessionUID: sessionUID,
                                            pageUrl: pageUrl,
                                            orderID: orderID,
                                            stickinessID: stickinessID
                                        })
                                    };
                                }));
                            })).catch((function(err) {
                                nativePopupWinProxy.close();
                                reject(err);
                                return onDestroy().then((function() {
                                    return _onError({
                                        data: {
                                            message: Object(src.stringifyError)(err)
                                        }
                                    });
                                })).then((function() {
                                    return {
                                        redirect: !1,
                                        appSwitch: !1
                                    };
                                }));
                            }));
                        }));
                    }));
                },
                start: function() {
                    if (!nativePopupPromise) throw new Error("Expected native popup promise to be set");
                    return nativePopupPromise;
                }
            };
        }
        var venmo_canRenderTop = !1;
        function venmo_getRenderWindow() {
            var top = Object(cross_domain_utils_src.getTop)(window);
            return venmo_canRenderTop && top ? top : Object(cross_domain_utils_src.getParent)() ? Object(cross_domain_utils_src.getParent)() : window;
        }
        var venmo_getDimensions = function(fundingSource) {
            Object(lib.getLogger)().info("popup_dimensions_" + fundingSource).flush();
            return {
                width: 500,
                height: 692
            };
        };
        function initVenmoWeb(_ref4) {
            var props = _ref4.props, components = _ref4.components, serviceData = _ref4.serviceData, payment = _ref4.payment, config = _ref4.config, fallback = _ref4.fallback;
            var Venmo = components.Venmo;
            var sessionID = props.sessionID, buttonSessionID = props.buttonSessionID, _createOrder = props.createOrder, _onApprove = props.onApprove, _onCancel = props.onCancel, _onError = props.onError, _onComplete = props.onComplete, onShippingChange = props.onShippingChange, onShippingAddressChange = props.onShippingAddressChange, onShippingOptionsChange = props.onShippingOptionsChange, locale = props.locale, commit = props.commit, clientAccessToken = props.clientAccessToken, onClick = props.onClick, cmid = props.clientMetadataID, _onAuth = props.onAuth, env = props.env, enableFunding = props.enableFunding, stickinessID = props.stickinessID, standaloneFundingSource = props.standaloneFundingSource, branded = props.branded, merchantRequestedPopupsDisabled = props.merchantRequestedPopupsDisabled;
            var button = payment.button, win = payment.win, fundingSource = payment.fundingSource, card = payment.card, _payment$buyerAccessT = payment.buyerAccessToken, buyerAccessToken = void 0 === _payment$buyerAccessT ? serviceData.buyerAccessToken : _payment$buyerAccessT, venmoPayloadID = payment.venmoPayloadID, buyerIntent = payment.buyerIntent;
            var buyerCountry = serviceData.buyerCountry, venmoWebEnabled = serviceData.eligibility.venmoWebEnabled;
            var cspNonce = config.cspNonce;
            var context = function(_ref3) {
                var win = _ref3.win, isClick = _ref3.isClick, merchantRequestedPopupsDisabled = _ref3.merchantRequestedPopupsDisabled;
                var popupSupported = Object(src.supportsPopups)();
                Object(lib.getLogger)().info("spb_decide_context", {
                    merchantRequestedPopupsDisabled: Boolean(merchantRequestedPopupsDisabled),
                    isClick: Boolean(isClick),
                    popupSupported: Boolean(popupSupported)
                });
                return !merchantRequestedPopupsDisabled && win || !merchantRequestedPopupsDisabled && isClick && popupSupported ? constants.CONTEXT.POPUP : constants.CONTEXT.IFRAME;
            }({
                win: win,
                isClick: payment.isClick,
                merchantRequestedPopupsDisabled: merchantRequestedPopupsDisabled
            });
            var approved = !1;
            var doApproveOnClose = !1;
            var forceClosed = !1;
            var instance;
            var close = function() {
                return zalgo_promise_src.ZalgoPromise.try((function() {
                    if (instance) {
                        forceClosed = !0;
                        return instance.close();
                    }
                }));
            };
            var start = Object(src.memoize)((function() {
                return (instance = Venmo({
                    window: win,
                    sessionID: sessionID,
                    buttonSessionID: buttonSessionID,
                    stickinessID: stickinessID,
                    clientAccessToken: clientAccessToken,
                    venmoPayloadID: venmoPayloadID,
                    parentDomain: Object(cross_domain_utils_src.getDomain)(),
                    venmoWebUrl: VENMO_WEB_URL[env],
                    venmoWebEnabled: venmoWebEnabled,
                    createOrder: function() {
                        return _createOrder().then((function(orderID) {
                            return orderID;
                        }));
                    },
                    onApprove: function(_temp) {
                        var _ref5 = void 0 === _temp ? {} : _temp, _ref5$approveOnClose = _ref5.approveOnClose, payerID = _ref5.payerID, paymentID = _ref5.paymentID, billingToken = _ref5.billingToken, subscriptionID = _ref5.subscriptionID, authCode = _ref5.authCode;
                        if (void 0 === _ref5$approveOnClose || !_ref5$approveOnClose) {
                            approved = !0;
                            Object(lib.getLogger)().info("spb_onapprove_access_token_" + (buyerAccessToken ? "present" : "not_present")).flush();
                            Object(lib.setBuyerAccessToken)(buyerAccessToken);
                            return _onApprove({
                                payerID: payerID,
                                paymentID: paymentID,
                                billingToken: billingToken,
                                subscriptionID: subscriptionID,
                                buyerAccessToken: buyerAccessToken,
                                authCode: authCode
                            }, {
                                restart: restart
                            }).finally((function() {
                                return close().then(src.noop);
                            })).catch(src.noop);
                        }
                        doApproveOnClose = !0;
                    },
                    onComplete: function() {
                        Object(lib.getLogger)().info("spb_oncomplete_access_token_" + (buyerAccessToken ? "present" : "not_present")).flush();
                        Object(lib.setBuyerAccessToken)(buyerAccessToken);
                        return _onComplete({
                            buyerAccessToken: buyerAccessToken
                        }).finally((function() {
                            return close().then(src.noop);
                        })).catch(src.noop);
                    },
                    onAuth: function(_ref6) {
                        return _onAuth({
                            accessToken: _ref6.accessToken || buyerAccessToken
                        }).then((function(token) {
                            buyerAccessToken = token;
                        }));
                    },
                    onCancel: function() {
                        return close().then((function() {
                            return _onCancel();
                        }));
                    },
                    onShippingChange: onShippingChange ? function(data, actions) {
                        return onShippingChange(Object(esm_extends.default)({
                            buyerAccessToken: buyerAccessToken
                        }, data), actions);
                    } : null,
                    onShippingAddressChange: onShippingAddressChange ? function(data, actions) {
                        if (!data.shippingAddress) throw new Error("Must pass shippingAddress in data to handle changes in shipping address.");
                        return onShippingAddressChange(Object(esm_extends.default)({}, data), actions);
                    } : null,
                    onShippingOptionsChange: onShippingOptionsChange ? function(data, actions) {
                        if (!data.selectedShippingOption) throw new Error("Must pass selectedShippingOption in data to handle changes in shipping options.");
                        return onShippingOptionsChange(Object(esm_extends.default)({}, data), actions);
                    } : null,
                    onClose: function() {
                        return doApproveOnClose && !approved ? _onApprove({
                            forceRestAPI: !0
                        }, {
                            restart: restart
                        }).catch(src.noop) : forceClosed || approved ? void 0 : _onCancel();
                    },
                    onError: function(err) {
                        var _getLogger$info$track;
                        Object(lib.getLogger)().info("venmo_flow_error ", {
                            err: Object(src.stringifyError)(err)
                        }).track((_getLogger$info$track = {}, _getLogger$info$track[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                        _getLogger$info$track[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.CHECKOUT_ERROR, 
                        _getLogger$info$track[sdk_constants_src.FPTI_KEY.EVENT_NAME] = constants.FPTI_TRANSITION.CHECKOUT_ERROR, 
                        _getLogger$info$track[sdk_constants_src.FPTI_KEY.ERROR_DESC] = Object(src.stringifyError)(err), 
                        _getLogger$info$track)).flush();
                        return _onError(err);
                    },
                    dimensions: venmo_getDimensions(fundingSource),
                    fundingSource: fundingSource,
                    card: card,
                    buyerCountry: buyerCountry,
                    locale: locale,
                    commit: commit,
                    cspNonce: cspNonce,
                    clientMetadataID: cmid,
                    enableFunding: enableFunding,
                    standaloneFundingSource: standaloneFundingSource,
                    branded: branded,
                    restart: function() {
                        return fallback(win ? {
                            win: win
                        } : {
                            win: venmo_getRenderWindow()
                        });
                    }
                })).renderTo(venmo_getRenderWindow(), constants.TARGET_ELEMENT.BODY, context);
            }));
            var restart = Object(src.memoize)((function() {
                return close().finally((function() {
                    return initVenmoWeb({
                        props: props,
                        components: components,
                        serviceData: serviceData,
                        config: config,
                        payment: {
                            button: button,
                            fundingSource: fundingSource,
                            card: card,
                            buyerIntent: buyerIntent,
                            isClick: !1,
                            checkoutRestart: !0
                        },
                        fallback: fallback
                    }).start().finally(lib.unresolvedPromise);
                }));
            }));
            return {
                click: function() {
                    return zalgo_promise_src.ZalgoPromise.try((function() {
                        if (!merchantRequestedPopupsDisabled && !win && Object(src.supportsPopups)()) try {
                            var _getDimensions = venmo_getDimensions(fundingSource);
                            win = openPopup({
                                width: _getDimensions.width,
                                height: _getDimensions.height
                            });
                        } catch (err) {
                            Object(lib.getLogger)().warn("popup_open_error_iframe_fallback", {
                                err: Object(src.stringifyError)(err)
                            });
                            if (!(err instanceof src.PopupOpenError)) throw err;
                            context = constants.CONTEXT.IFRAME;
                        }
                        return zalgo_promise_src.ZalgoPromise.try((function() {
                            return !onClick || onClick({
                                fundingSource: fundingSource
                            });
                        })).then((function(valid) {
                            if (win && !valid) {
                                var _getLogger$info$track2;
                                Object(lib.getLogger)().info("native_onclick_invalid").track((_getLogger$info$track2 = {}, 
                                _getLogger$info$track2[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                                _getLogger$info$track2[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_ON_CLICK_INVALID, 
                                _getLogger$info$track2)).flush();
                                win.close();
                            }
                            return valid;
                        }));
                    }));
                },
                start: start,
                close: close
            };
        }
        var native_clean;
        var native_fallback;
        var native_native = {
            name: "native",
            setup: function(_ref) {
                var props = _ref.props, serviceData = _ref.serviceData;
                props.fundingSource === sdk_constants_src.FUNDING.VENMO && serviceData.eligibility.venmoWebEnabled && function(_ref) {
                    var Venmo = _ref.components.Venmo;
                    var _ref2 = [ Object(cross_domain_utils_src.getParent)(window), Object(cross_domain_utils_src.getTop)(window) ], parent = _ref2[0], top = _ref2[1];
                    var tasks = {};
                    top && parent && parent !== top && (tasks.canRenderTo = Venmo.canRenderTo(top).then((function(result) {
                        venmo_canRenderTop = result;
                    })));
                    zalgo_promise_src.ZalgoPromise.hash(tasks).then(src.noop);
                }({
                    components: _ref.components
                });
                return function(_ref2) {
                    var _headers;
                    var props = _ref2.props, serviceData = _ref2.serviceData;
                    var clientID = props.clientID, currency = props.currency, platform = props.platform, vault = props.vault, buttonSessionID = props.buttonSessionID, enableFunding = props.enableFunding, merchantDomain = props.merchantDomain, disableSetCookie = props.disableSetCookie;
                    var merchantID = serviceData.merchantID, buyerCountry = serviceData.buyerCountry, cookies = serviceData.cookies;
                    var shippingCallbackEnabled = !serviceData.eligibility.venmoWebEnabled && Boolean(props.onShippingChange);
                    return Object(api.getNativeEligibility)({
                        vault: vault,
                        platform: platform,
                        shippingCallbackEnabled: shippingCallbackEnabled,
                        clientID: clientID,
                        buyerCountry: buyerCountry,
                        currency: currency,
                        buttonSessionID: buttonSessionID,
                        cookies: cookies,
                        enableFunding: enableFunding,
                        stickinessID: null,
                        skipElmo: !0,
                        merchantID: merchantID[0],
                        domain: merchantDomain,
                        headers: (_headers = {}, _headers[constants.HEADERS.DISABLE_SET_COOKIE] = String(disableSetCookie), 
                        _headers)
                    }).then((function(nativeEligibility) {
                        nativeEligibilityResults = nativeEligibility;
                    }));
                }({
                    props: props,
                    serviceData: serviceData
                }).then(src.noop);
            },
            isEligible: function(_ref6) {
                var _fundingEligibility$v;
                var props = _ref6.props, serviceData = _ref6.serviceData;
                var fundingSource = props.fundingSource, onShippingChange = props.onShippingChange, createBillingAgreement = props.createBillingAgreement, createSubscription = props.createSubscription, env = props.env, platform = props.platform;
                var cookies = serviceData.cookies, merchantID = serviceData.merchantID, fundingEligibility = serviceData.fundingEligibility, venmoWebEnabled = serviceData.eligibility.venmoWebEnabled;
                var isVenmoEligible = null == fundingEligibility || null == (_fundingEligibility$v = fundingEligibility.venmo) ? void 0 : _fundingEligibility$v.eligible;
                var isVenmoButton = fundingSource === sdk_constants_src.FUNDING.VENMO;
                var isLocalOrStageEnv = env === sdk_constants_src.ENV.LOCAL || env === sdk_constants_src.ENV.STAGE;
                return !(!_ref6.config.firebase || platform && platform === sdk_constants_src.PLATFORM.DESKTOP && !isVenmoEligible || !canUsePopupAppSwitch({
                    fundingSource: fundingSource
                }) && !canUseNativeQRCode({
                    fundingSource: fundingSource
                }) || function() {
                    var now = Date.now();
                    var optOutLifetime = 0;
                    Object(lib.getStorageState)((function(state) {
                        var nativeOptOutLifetime = state.nativeOptOutLifetime;
                        nativeOptOutLifetime && "number" == typeof nativeOptOutLifetime && (optOutLifetime = nativeOptOutLifetime);
                    }));
                    return optOutLifetime > now;
                }() || !isNativeOptedIn({
                    props: props
                }) && (!cookies && fundingSource === sdk_constants_src.FUNDING.PAYPAL || !Object(src.supportsPopups)() || !venmoWebEnabled && onShippingChange || createBillingAgreement || createSubscription || !isVenmoButton && isLocalOrStageEnv || merchantID.length > 1 || !serviceData.featureFlags.isLsatUpgradable));
            },
            isPaymentEligible: function(_ref7) {
                var payment = _ref7.payment;
                var platform = _ref7.props.platform;
                var fundingSource = payment.fundingSource, win = payment.win;
                var venmoWebEnabled = _ref7.serviceData.eligibility.venmoWebEnabled;
                return !!(NATIVE_CHECKOUT_URI[fundingSource] && NATIVE_CHECKOUT_POPUP_URI[fundingSource] && NATIVE_CHECKOUT_FALLBACK_URI[fundingSource]) && !(!canUsePopupAppSwitch({
                    fundingSource: fundingSource,
                    win: win
                }) && !canUseNativeQRCode({
                    fundingSource: fundingSource,
                    win: win
                })) && (platform && platform === sdk_constants_src.PLATFORM.DESKTOP ? !!venmoWebEnabled || !(!nativeEligibilityResults || !nativeEligibilityResults[fundingSource]) && nativeEligibilityResults[fundingSource].eligibility : !(win && !Object(lib.toProxyWindow)(win).getWindow()));
            },
            init: function(_ref2) {
                var props = _ref2.props, components = _ref2.components, config = _ref2.config, payment = _ref2.payment, serviceData = _ref2.serviceData, restart = _ref2.restart;
                var onApprove = props.onApprove, onCancel = props.onCancel, onError = props.onError, buttonSessionID = props.buttonSessionID, onShippingChange = props.onShippingChange;
                var venmoWebEnabled = serviceData.eligibility.venmoWebEnabled;
                var fundingSource = payment.fundingSource, win = payment.win;
                if (!config.firebase) throw new Error("Can not run native flow without firebase config");
                native_clean && native_clean.all();
                native_clean = Object(src.cleanup)();
                var approved = !1;
                var cancelled = !1;
                var didFallback = !1;
                var destroy = Object(src.memoize)((function() {
                    return native_clean.all();
                }));
                var fallbackToWebCheckout = function(fallbackWin) {
                    didFallback = !0;
                    return zalgo_promise_src.ZalgoPromise.try((function() {
                        return !fallbackWin || Object(lib.toProxyWindow)(fallbackWin).isClosed();
                    })).then((function(winClosedOrNotPassed) {
                        var actualFallbackWin = winClosedOrNotPassed ? null : fallbackWin;
                        var checkoutPayment = Object(esm_extends.default)({}, payment, {
                            win: actualFallbackWin,
                            isClick: !1
                        });
                        var instance;
                        instance = fundingSource === sdk_constants_src.FUNDING.VENMO && venmoWebEnabled ? initVenmoWeb({
                            props: props,
                            components: components,
                            payment: checkoutPayment,
                            config: config,
                            serviceData: serviceData,
                            fallback: native_fallback
                        }) : checkout.init({
                            props: props,
                            components: components,
                            payment: checkoutPayment,
                            config: config,
                            serviceData: serviceData,
                            restart: restart
                        });
                        return zalgo_promise_src.ZalgoPromise.all([ destroy(), instance.start() ]).then(src.noop);
                    }));
                };
                native_fallback = function(opts) {
                    var _ref6 = opts || {}, fallbackWin = _ref6.win, _ref6$fallbackOptions = _ref6.fallbackOptions, fallbackOptions = void 0 === _ref6$fallbackOptions ? {} : _ref6$fallbackOptions;
                    return zalgo_promise_src.ZalgoPromise.try((function() {
                        var _getLogger$info$track6;
                        var result = setNativeOptOut(fallbackOptions);
                        var fallback_reason = fallbackOptions.fallback_reason;
                        var fallbackTransitionLog;
                        fallbackTransitionLog = result ? constants.FPTI_TRANSITION.NATIVE_OPT_OUT : fundingSource === sdk_constants_src.FUNDING.VENMO && venmoWebEnabled ? constants.FPTI_TRANSITION.NATIVE_FALLBACK_VENMO : constants.FPTI_TRANSITION.NATIVE_FALLBACK;
                        Object(lib.getLogger)().info("native_message_onfallback").track((_getLogger$info$track6 = {}, 
                        _getLogger$info$track6[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_ON_FALLBACK, 
                        _getLogger$info$track6[constants.FPTI_CUSTOM_KEY.TRANSITION_TYPE] = fallbackTransitionLog, 
                        _getLogger$info$track6[constants.FPTI_CUSTOM_KEY.TRANSITION_REASON] = fallback_reason || "", 
                        _getLogger$info$track6)).flush();
                        return fallbackToWebCheckout(fallbackWin);
                    }));
                };
                var sessionUID = Object(src.uniqueID)();
                var initFlow;
                if (function(_ref5) {
                    var fundingSource = _ref5.fundingSource;
                    return !(!_ref5.serviceData.eligibility.venmoWebEnabled || fundingSource && fundingSource !== sdk_constants_src.FUNDING.VENMO || _ref5.win);
                }({
                    fundingSource: fundingSource,
                    win: win,
                    serviceData: serviceData
                }) && Boolean(onShippingChange)) {
                    var _getLogger$info$track7;
                    Object(lib.getLogger)().info("venmo_web").track((_getLogger$info$track7 = {}, _getLogger$info$track7[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_VENMO_WEB, 
                    _getLogger$info$track7)).flush();
                    initFlow = initVenmoWeb;
                } else if (canUsePopupAppSwitch({
                    fundingSource: fundingSource,
                    win: win
                })) initFlow = initNativePopup; else {
                    if (!canUseNativeQRCode({
                        fundingSource: fundingSource,
                        win: win
                    })) throw new Error("No valid native payment flow found");
                    initFlow = initNativeQRCode;
                }
                var flow = initFlow({
                    payment: payment,
                    props: props,
                    serviceData: serviceData,
                    config: config,
                    components: components,
                    clean: native_clean,
                    sessionUID: sessionUID,
                    fallback: native_fallback,
                    callbacks: {
                        onInit: function() {
                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                Object(api.onLsatUpgradeCalled)();
                                return {
                                    buttonSessionID: buttonSessionID
                                };
                            }));
                        },
                        onApprove: function(_ref3) {
                            var _getLogger$info$track;
                            var _ref3$data = _ref3.data, payerID = _ref3$data.payerID, paymentID = _ref3$data.paymentID, billingToken = _ref3$data.billingToken;
                            approved = !0;
                            Object(lib.getLogger)().info("native_message_onapprove", {
                                payerID: payerID,
                                paymentID: paymentID,
                                billingToken: billingToken
                            }).track((_getLogger$info$track = {}, _getLogger$info$track[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_ON_APPROVE, 
                            _getLogger$info$track[constants.FPTI_CUSTOM_KEY.INFO_MSG] = "payerID: " + payerID + ", paymentID: " + (paymentID || "undefined") + ", billingToken: " + (billingToken || "undefined"), 
                            _getLogger$info$track)).flush();
                            return zalgo_promise_src.ZalgoPromise.all([ onApprove({
                                payerID: payerID,
                                paymentID: paymentID,
                                billingToken: billingToken,
                                forceRestAPI: !0
                            }, {
                                restart: function() {
                                    return fallbackToWebCheckout();
                                }
                            }).catch((function(err) {
                                var _getLogger$info$track2;
                                Object(lib.getLogger)().info("native_message_onapprove_error", {
                                    payerID: payerID,
                                    paymentID: paymentID,
                                    billingToken: billingToken
                                }).track((_getLogger$info$track2 = {}, _getLogger$info$track2[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_ON_APPROVE_ERROR, 
                                _getLogger$info$track2[constants.FPTI_CUSTOM_KEY.INFO_MSG] = "Error: " + Object(src.stringifyError)(err), 
                                _getLogger$info$track2)).flush();
                                onError(err);
                            })), destroy() ]).then((function() {
                                return {
                                    buttonSessionID: buttonSessionID
                                };
                            }));
                        },
                        onCancel: function() {
                            var _getLogger$info$track3;
                            cancelled = !0;
                            Object(lib.getLogger)().info("native_message_oncancel").track((_getLogger$info$track3 = {}, 
                            _getLogger$info$track3[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_ON_CANCEL, 
                            _getLogger$info$track3)).flush();
                            return zalgo_promise_src.ZalgoPromise.all([ onCancel(), destroy() ]).then((function() {
                                return {
                                    buttonSessionID: buttonSessionID
                                };
                            }));
                        },
                        onError: function(_ref4) {
                            var _getLogger$info$track4;
                            var message = _ref4.data.message;
                            Object(lib.getLogger)().info("native_message_onerror", {
                                err: message
                            }).track((_getLogger$info$track4 = {}, _getLogger$info$track4[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_ON_ERROR, 
                            _getLogger$info$track4[constants.FPTI_CUSTOM_KEY.INFO_MSG] = "Error message: " + message, 
                            _getLogger$info$track4)).flush();
                            return zalgo_promise_src.ZalgoPromise.all([ onError(new Error(message)), destroy() ]).then((function() {
                                return {
                                    buttonSessionID: buttonSessionID
                                };
                            }));
                        },
                        onShippingChange: function(_ref5) {
                            var data = _ref5.data;
                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                var _getLogger$info$track5;
                                Object(lib.getLogger)().info("native_message_onshippingchange").track((_getLogger$info$track5 = {}, 
                                _getLogger$info$track5[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_ON_SHIPPING_CHANGE, 
                                _getLogger$info$track5)).flush();
                                if (onShippingChange) {
                                    var resolved = !0;
                                    var actions = {
                                        resolve: function() {
                                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                                resolved = !0;
                                            }));
                                        },
                                        reject: function() {
                                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                                resolved = !1;
                                            }));
                                        }
                                    };
                                    return onShippingChange(Object(esm_extends.default)({}, data, {
                                        forceRestAPI: !0
                                    }), actions).then((function() {
                                        return {
                                            resolved: resolved
                                        };
                                    }));
                                }
                                return {
                                    resolved: !0
                                };
                            }));
                        },
                        onClose: function() {
                            return zalgo_promise_src.ZalgoPromise.delay(1e3).then((function() {
                                if (!(approved || cancelled || didFallback || Object(lib.isAndroidChrome)())) return zalgo_promise_src.ZalgoPromise.try((function() {
                                    return destroy();
                                }));
                            })).then(src.noop);
                        },
                        onDestroy: destroy
                    }
                });
                return {
                    click: function() {
                        return flow.click();
                    },
                    start: function() {
                        return zalgo_promise_src.ZalgoPromise.try((function() {
                            return flow.start();
                        })).catch((function(err) {
                            return destroy().then((function() {
                                var _getLogger$error$trac;
                                Object(lib.getLogger)().error("native_error", {
                                    err: Object(src.stringifyError)(err)
                                }).track((_getLogger$error$trac = {}, _getLogger$error$trac[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.NATIVE_ERROR, 
                                _getLogger$error$trac[sdk_constants_src.FPTI_KEY.ERROR_CODE] = "native_error", _getLogger$error$trac[sdk_constants_src.FPTI_KEY.ERROR_DESC] = Object(src.stringifyErrorMessage)(err), 
                                _getLogger$error$trac)).flush();
                                throw err;
                            }));
                        }));
                    },
                    close: destroy
                };
            },
            updateFlowClientConfig: function(_ref7) {
                var orderID = _ref7.orderID, payment = _ref7.payment, userExperienceFlow = _ref7.userExperienceFlow, buttonSessionID = _ref7.buttonSessionID, featureFlags = _ref7.featureFlags;
                return zalgo_promise_src.ZalgoPromise.try((function() {
                    var fundingSource = payment.fundingSource;
                    return Object(api.updateButtonClientConfig)({
                        fundingSource: fundingSource,
                        orderID: orderID,
                        inline: !1,
                        userExperienceFlow: userExperienceFlow,
                        buttonSessionID: buttonSessionID,
                        featureFlags: featureFlags
                    });
                }));
            },
            spinner: !0
        };
        var parentPopupBridge;
        var popupBridge = {
            name: "popup_bridge",
            setup: function(_ref) {
                var props = _ref.props;
                return zalgo_promise_src.ZalgoPromise.try((function() {
                    var getPopupBridge = props.getPopupBridge;
                    if (getPopupBridge) return getPopupBridge().then((function(bridge) {
                        parentPopupBridge = bridge;
                    }));
                }));
            },
            isEligible: function(_ref2) {
                var props = _ref2.props;
                return !(props.onShippingChange || props.onShippingAddressChange || props.onShippingOptionsChange);
            },
            isPaymentEligible: function(_ref3) {
                return !_ref3.payment.win && !!parentPopupBridge;
            },
            init: function(_ref4) {
                var props = _ref4.props;
                var createOrder = props.createOrder, onApprove = props.onApprove, onCancel = props.onCancel, commit = props.commit;
                var fundingSource = _ref4.payment.fundingSource;
                return {
                    start: function start() {
                        return createOrder().then((function(orderID) {
                            if (!parentPopupBridge) throw new Error("Popup bridge required");
                            var url = Object(src.extendUrl)("" + Object(cross_domain_utils_src.getDomain)() + src_config.WEB_CHECKOUT_URI, {
                                query: {
                                    fundingSource: fundingSource,
                                    token: orderID,
                                    useraction: commit ? constants.USER_ACTION.COMMIT : constants.USER_ACTION.CONTINUE,
                                    redirect_uri: parentPopupBridge.nativeUrl,
                                    native_xo: "1"
                                }
                            });
                            return parentPopupBridge.start(url);
                        })).then((function(_ref5) {
                            var opType = _ref5.opType, payerID = _ref5.PayerID, paymentID = _ref5.paymentId, billingToken = _ref5.ba_token;
                            if (opType === src_props.POPUP_BRIDGE_OPTYPE.PAYMENT) {
                                if (!payerID && !billingToken) throw new Error("Expected payerID to be passed");
                                return onApprove({
                                    payerID: payerID,
                                    paymentID: paymentID,
                                    billingToken: billingToken
                                }, {
                                    restart: start
                                });
                            }
                            if (opType === src_props.POPUP_BRIDGE_OPTYPE.CANCEL) return onCancel();
                            throw new Error("Unhandleable opType: " + opType);
                        }));
                    },
                    close: lib.promiseNoop
                };
            },
            spinner: !0
        };
        var confirmOrder = __webpack_require__("./src/props/confirmOrder.js");
        function isValidMerchantIDs(merchantIDs, payees) {
            if (merchantIDs.length !== payees.length) return !1;
            var merchantEmails = [];
            var merchantIds = [];
            merchantIDs.forEach((function(id) {
                Object(lib.isEmailAddress)(id) ? merchantEmails.push(id.toLowerCase()) : merchantIds.push(id);
            }));
            var foundEmail = merchantEmails.every((function(email) {
                return payees.some((function(payee) {
                    return email === (payee.email && payee.email.stringValue && payee.email.stringValue.toLowerCase());
                }));
            }));
            var foundMerchantId = merchantIds.every((function(id) {
                return payees.some((function(payee) {
                    return id === payee.merchantId;
                }));
            }));
            return !(!foundEmail || !foundMerchantId) && payees.every((function(payee) {
                return merchantIds.indexOf(payee.merchantId) > -1 || merchantEmails.indexOf(payee.email && payee.email.stringValue && payee.email.stringValue.toLowerCase()) > -1;
            }));
        }
        function triggerIntegrationError(_ref) {
            var _getLogger$warn$track;
            var error = _ref.error, _ref$message = _ref.message, message = void 0 === _ref$message ? error : _ref$message, orderID = _ref.orderID, _ref$loggerPayload = _ref.loggerPayload, loggerPayload = void 0 === _ref$loggerPayload ? {} : _ref$loggerPayload, _ref$throwError = _ref.throwError;
            var shouldThrowError = (void 0 === _ref$throwError || _ref$throwError) && _ref.featureFlags.shouldThrowIntegrationError;
            Object(lib_logger.getLogger)().warn(error, loggerPayload).track((_getLogger$warn$track = {}, 
            _getLogger$warn$track[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
            _getLogger$warn$track[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.ORDER_VALIDATE, 
            _getLogger$warn$track[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = constants.FPTI_CONTEXT_TYPE.ORDER_ID, 
            _getLogger$warn$track[sdk_constants_src.FPTI_KEY.TOKEN] = orderID, _getLogger$warn$track[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = orderID, 
            _getLogger$warn$track[constants.FPTI_CUSTOM_KEY.INTEGRATION_ISSUE] = error, _getLogger$warn$track[constants.FPTI_CUSTOM_KEY.INTEGRATION_WHITELIST] = shouldThrowError ? "false" : "true", 
            _getLogger$warn$track[sdk_constants_src.FPTI_KEY.ERROR_DESC] = message, _getLogger$warn$track)).flush();
            if (shouldThrowError) {
                console.error(message);
                throw new Error(message);
            }
            console.warn(message);
        }
        var VALIDATE_INTENTS = [ sdk_constants_src.INTENT.CAPTURE, sdk_constants_src.INTENT.AUTHORIZE, sdk_constants_src.INTENT.ORDER ];
        var menu_menu;
        function renderButtonSmartMenu(_ref) {
            var containerUID = _ref.containerUID;
            if (menu_menu) return menu_menu;
            var newMenu = (0, _ref.Menu)({
                clientID: _ref.clientID
            });
            newMenu.hide();
            newMenu.renderTo(window.xprops.getParent(), "#" + containerUID + " #smart-menu");
            return menu_menu = newMenu;
        }
        var PAYMENT_FLOWS = [ vaultCapture, walletCapture, cardField, cardForm, paymentFields, popupBridge, applepay, native_native, checkout ];
        function getPaymentFlow(_ref2) {
            var props = _ref2.props, payment = _ref2.payment, config = _ref2.config, serviceData = _ref2.serviceData;
            !props.fundingSource && payment.fundingSource && (props.fundingSource = payment.fundingSource);
            for (var _i2 = 0; _i2 < PAYMENT_FLOWS.length; _i2++) {
                var flow = PAYMENT_FLOWS[_i2];
                if (flow.isEligible({
                    props: props,
                    config: config,
                    serviceData: serviceData
                }) && flow.isPaymentEligible({
                    props: props,
                    payment: payment,
                    config: config,
                    serviceData: serviceData
                })) return flow;
            }
            throw new Error("Could not find eligible payment flow");
        }
        function initiatePaymentFlow(_ref3) {
            var _props$style;
            var payment = _ref3.payment, serviceData = _ref3.serviceData, config = _ref3.config, components = _ref3.components, props = _ref3.props, experiments = _ref3.experiments;
            var button = payment.button, fundingSource = payment.fundingSource, instrumentType = payment.instrumentType, buyerIntent = payment.buyerIntent;
            var buttonLabel = null == (_props$style = props.style) ? void 0 : _props$style.label;
            return zalgo_promise_src.ZalgoPromise.try((function() {
                var _getLogger$addPayload, _getLogger$addPayload2;
                var merchantID = serviceData.merchantID, fundingEligibility = serviceData.fundingEligibility, buyerCountry = serviceData.buyerCountry, featureFlags = serviceData.featureFlags;
                var clientID = props.clientID, onClick = props.onClick, createOrder = props.createOrder, env = props.env, vault = props.vault, partnerAttributionID = props.partnerAttributionID, userExperienceFlow = props.userExperienceFlow, buttonSessionID = props.buttonSessionID, intent = props.intent, currency = props.currency, clientAccessToken = props.clientAccessToken, createBillingAgreement = props.createBillingAgreement, createSubscription = props.createSubscription, commit = props.commit, disableFunding = props.disableFunding, disableCard = props.disableCard, userIDToken = props.userIDToken, enableNativeCheckout = props.enableNativeCheckout;
                !function(personalization) {
                    personalization && personalization.tagline && personalization.tagline.tracking && Object(lib.sendBeacon)(personalization.tagline.tracking.click);
                    personalization && personalization.buttonText && personalization.buttonText.tracking && Object(lib.sendBeacon)(personalization.buttonText.tracking.click);
                }(serviceData.personalization);
                var _getPaymentFlow = getPaymentFlow({
                    props: props,
                    payment: payment,
                    config: config,
                    components: components,
                    serviceData: serviceData
                }), name = _getPaymentFlow.name, inline = _getPaymentFlow.inline, spinner = _getPaymentFlow.spinner, updateFlowClientConfig = _getPaymentFlow.updateFlowClientConfig;
                var _init = (0, _getPaymentFlow.init)({
                    props: props,
                    config: config,
                    serviceData: serviceData,
                    components: components,
                    payment: payment,
                    restart: function(_ref4) {
                        return initiatePaymentFlow({
                            payment: _ref4.payment,
                            serviceData: serviceData,
                            config: config,
                            components: components,
                            props: props,
                            experiments: experiments
                        });
                    },
                    experiments: experiments
                }), click = _init.click, start = _init.start, close = _init.close;
                Object(lib.sendCountMetric)({
                    name: "pp.app.paypal_sdk.buttons.click.count",
                    dimensions: {
                        fundingSource: fundingSource,
                        spbPaymentFlow: name
                    }
                });
                Object(lib.getLogger)().addPayloadBuilder((function() {
                    return {
                        token: null
                    };
                })).addTrackingBuilder((function() {
                    var _ref5;
                    return (_ref5 = {})[sdk_constants_src.FPTI_KEY.CHOSEN_FUNDING] = fundingSource, 
                    _ref5[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = constants.FPTI_CONTEXT_TYPE.BUTTON_SESSION_ID, 
                    _ref5[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = buttonSessionID, _ref5[sdk_constants_src.FPTI_KEY.BUTTON_SESSION_UID] = buttonSessionID, 
                    _ref5;
                })).info("button_click_pay_flow_" + name).info("button_click_fundingsource_" + fundingSource).info("button_click_instrument_" + (instrumentType || "default")).info("cross_site_tracking_" + (Object(src.isCrossSiteTrackingEnabled)("enforce_policy") ? "enabled" : "disabled")).track((_getLogger$addPayload = {}, 
                _getLogger$addPayload[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                _getLogger$addPayload[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.BUTTON_CLICK, 
                _getLogger$addPayload[sdk_constants_src.FPTI_KEY.EVENT_NAME] = constants.FPTI_TRANSITION.BUTTON_CLICK, 
                _getLogger$addPayload[sdk_constants_src.FPTI_KEY.CHOSEN_FI_TYPE] = instrumentType, 
                _getLogger$addPayload[sdk_constants_src.FPTI_KEY.PAYMENT_FLOW] = name, _getLogger$addPayload[sdk_constants_src.FPTI_KEY.IS_VAULT] = instrumentType ? "1" : "0", 
                _getLogger$addPayload[constants.FPTI_CUSTOM_KEY.INFO_MSG] = enableNativeCheckout ? "tester" : "", 
                _getLogger$addPayload.client_time = Object(lib.getClientsideTimestamp)(), _getLogger$addPayload)).track((_getLogger$addPayload2 = {}, 
                _getLogger$addPayload2[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                _getLogger$addPayload2[sdk_constants_src.FPTI_KEY.TRANSITION] = "cross_site_tracking_" + (Object(src.isCrossSiteTrackingEnabled)("enforce_policy") ? "enabled" : "disabled"), 
                _getLogger$addPayload2)).flush();
                var loggingPromise = zalgo_promise_src.ZalgoPromise.try((function() {
                    return window.xprops.sessionState.get("__confirm_" + fundingSource + "_payload__").then((function(confirmPayload) {
                        var fieldsSessionID = confirmPayload ? confirmPayload.payment_source[fundingSource].metadata.fieldsSessionID : "";
                        Object(lib.getLogger)().addTrackingBuilder((function() {
                            var _ref6;
                            return (_ref6 = {})[sdk_constants_src.FPTI_KEY.FIELDS_COMPONENT_SESSION_ID] = fieldsSessionID, 
                            _ref6;
                        }));
                    }));
                }));
                var clickPromise = click ? zalgo_promise_src.ZalgoPromise.try(click) : zalgo_promise_src.ZalgoPromise.resolve();
                clickPromise.catch(src.noop);
                return zalgo_promise_src.ZalgoPromise.try((function() {
                    return !onClick || onClick({
                        fundingSource: fundingSource
                    });
                })).then((function(valid) {
                    return !!valid && clickPromise;
                })).then((function(valid) {
                    if (!1 !== valid) {
                        spinner && enableLoadingSpinner(button);
                        var updateClientConfigPromise = createOrder().then((function(orderID) {
                            if (updateFlowClientConfig) return updateFlowClientConfig({
                                orderID: orderID,
                                payment: payment,
                                userExperienceFlow: userExperienceFlow,
                                buttonSessionID: buttonSessionID,
                                featureFlags: featureFlags
                            });
                            function updateButtonClientConfigWrapper() {
                                return Object(api.updateButtonClientConfig)({
                                    orderID: orderID,
                                    fundingSource: fundingSource,
                                    inline: inline,
                                    userExperienceFlow: userExperienceFlow,
                                    featureFlags: featureFlags
                                }).catch((function(err) {
                                    Object(lib.getLogger)().error("update_client_config_error", {
                                        err: Object(src.stringifyError)(err)
                                    });
                                }));
                            }
                            if (featureFlags.isButtonClientConfigCallBlocking) return updateButtonClientConfigWrapper();
                            updateButtonClientConfigWrapper();
                        })).catch(src.noop);
                        var vaultPromise = createOrder().then((function(orderID) {
                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                if (clientID && buyerIntent === constants.BUYER_INTENT.PAY) return function(_ref3) {
                                    var orderID = _ref3.orderID, vault = _ref3.vault, clientAccessToken = _ref3.clientAccessToken, createBillingAgreement = _ref3.createBillingAgreement, createSubscription = _ref3.createSubscription, fundingSource = _ref3.fundingSource, clientID = _ref3.clientID, merchantID = _ref3.merchantID, buyerCountry = _ref3.buyerCountry, currency = _ref3.currency, commit = _ref3.commit, intent = _ref3.intent, disableFunding = _ref3.disableFunding, disableCard = _ref3.disableCard, userIDToken = _ref3.userIDToken, _ref3$inline = _ref3.inline, inline = void 0 !== _ref3$inline && _ref3$inline, userExperienceFlow = _ref3.userExperienceFlow, buttonSessionID = _ref3.buttonSessionID;
                                    return zalgo_promise_src.ZalgoPromise.try((function() {
                                        Object(lib.getLogger)().info("vault_auto_setup_vault_" + vault.toString() + "_id_token_" + (userIDToken ? "present" : "not_present")).flush();
                                        return function(_ref2) {
                                            var vault = _ref2.vault, clientAccessToken = _ref2.clientAccessToken, createBillingAgreement = _ref2.createBillingAgreement, createSubscription = _ref2.createSubscription, fundingSource = _ref2.fundingSource, clientID = _ref2.clientID, merchantID = _ref2.merchantID, buyerCountry = _ref2.buyerCountry, currency = _ref2.currency, commit = _ref2.commit, intent = _ref2.intent, disableFunding = _ref2.disableFunding, disableCard = _ref2.disableCard, userIDToken = _ref2.userIDToken;
                                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                                if (!clientAccessToken) return !1;
                                                if (userIDToken) {
                                                    Object(lib.getLogger)().info("vault_auto_setup_disabled_id_token", {
                                                        clientID: clientID
                                                    });
                                                    return !1;
                                                }
                                                return !createBillingAgreement && !createSubscription && (!!vault || function(_ref) {
                                                    var accessToken = _ref.accessToken, fundingSource = _ref.fundingSource, clientID = _ref.clientID, merchantID = _ref.merchantID, buyerCountry = _ref.buyerCountry, currency = _ref.currency, commit = _ref.commit, vault = _ref.vault, intent = _ref.intent, disableFunding = _ref.disableFunding, disableCard = _ref.disableCard;
                                                    return zalgo_promise_src.ZalgoPromise.try((function() {
                                                        return fundingSource === sdk_constants_src.FUNDING.PAYPAL && Object(api.getFundingEligibility)("\n                " + fundingSource + " {\n                    vaultable\n                }\n            ", {
                                                            accessToken: accessToken,
                                                            clientID: clientID,
                                                            merchantID: merchantID,
                                                            buyerCountry: buyerCountry,
                                                            currency: currency,
                                                            commit: commit,
                                                            vault: vault,
                                                            intent: intent,
                                                            disableFunding: disableFunding,
                                                            disableCard: disableCard
                                                        }).then((function(newFundingEligibility) {
                                                            return !(!newFundingEligibility[fundingSource] || !newFundingEligibility[fundingSource].vaultable);
                                                        }));
                                                    }));
                                                }({
                                                    accessToken: clientAccessToken,
                                                    fundingSource: fundingSource,
                                                    clientID: clientID,
                                                    merchantID: merchantID,
                                                    buyerCountry: buyerCountry,
                                                    currency: currency,
                                                    commit: commit,
                                                    vault: vault,
                                                    intent: intent,
                                                    disableFunding: disableFunding,
                                                    disableCard: disableCard
                                                }).catch((function(err) {
                                                    Object(lib.getLogger)().warn("funding_vaultable_error", {
                                                        err: Object(src.stringifyError)(err)
                                                    });
                                                    return !1;
                                                })));
                                            }));
                                        }({
                                            vault: vault,
                                            clientAccessToken: clientAccessToken,
                                            createBillingAgreement: createBillingAgreement,
                                            createSubscription: createSubscription,
                                            fundingSource: fundingSource,
                                            clientID: clientID,
                                            merchantID: merchantID,
                                            buyerCountry: buyerCountry,
                                            currency: currency,
                                            commit: commit,
                                            intent: intent,
                                            disableFunding: disableFunding,
                                            disableCard: disableCard,
                                            userIDToken: userIDToken
                                        });
                                    })).then((function(eligible) {
                                        if (eligible && clientAccessToken) {
                                            var experienceFlow = inline ? constants.USER_EXPERIENCE_FLOW.INLINE : constants.USER_EXPERIENCE_FLOW.INCONTEXT;
                                            return Object(api.enableVault)({
                                                orderID: orderID,
                                                clientAccessToken: clientAccessToken,
                                                fundingSource: fundingSource,
                                                integrationArtifact: constants.INTEGRATION_ARTIFACT.PAYPAL_JS_SDK,
                                                userExperienceFlow: userExperienceFlow || experienceFlow,
                                                productFlow: constants.PRODUCT_FLOW.SMART_PAYMENT_BUTTONS,
                                                buttonSessionID: buttonSessionID
                                            }).catch((function(err) {
                                                if (vault) throw err;
                                            }));
                                        }
                                    }));
                                }({
                                    orderID: orderID,
                                    vault: vault,
                                    clientAccessToken: clientAccessToken,
                                    fundingEligibility: fundingEligibility,
                                    fundingSource: fundingSource,
                                    createBillingAgreement: createBillingAgreement,
                                    createSubscription: createSubscription,
                                    clientID: clientID,
                                    merchantID: merchantID,
                                    buyerCountry: buyerCountry,
                                    currency: currency,
                                    commit: commit,
                                    intent: intent,
                                    disableFunding: disableFunding,
                                    disableCard: disableCard,
                                    userIDToken: userIDToken,
                                    userExperienceFlow: userExperienceFlow,
                                    buttonSessionID: buttonSessionID,
                                    inline: inline
                                });
                            }));
                        }));
                        var startPromise = updateClientConfigPromise.then((function() {
                            featureFlags.isButtonClientConfigCallBlocking ? Object(lib.getLogger)().info("blocking_cco_call_resolved", {
                                time: Object(lib.getClientsideTimestamp)(),
                                fundingSource: fundingSource,
                                buttonSessionID: buttonSessionID
                            }) : Object(lib.getLogger)().info("non_blocking_cco_call_resolved", {
                                time: Object(lib.getClientsideTimestamp)(),
                                fundingSource: fundingSource,
                                buttonSessionID: buttonSessionID
                            });
                            return start();
                        }));
                        var validateOrderPromise = createOrder().then((function(orderID) {
                            return function(orderID, _ref3) {
                                var env = _ref3.env, merchantID = _ref3.merchantID, currency = _ref3.currency, intent = _ref3.intent, vault = _ref3.vault, buttonLabel = _ref3.buttonLabel, featureFlags = _ref3.featureFlags;
                                var logger = Object(lib_logger.getLogger)();
                                return Object(api.getSupplementalOrderInfo)(orderID).then((function(order) {
                                    var _cart$supplementary, _cart$supplementary2;
                                    var cart = order.checkoutSession.cart;
                                    var cartIntent = "sale" === cart.intent.toLowerCase() ? sdk_constants_src.INTENT.CAPTURE : cart.intent.toLowerCase();
                                    var initiationIntent = "authorization" === (null == (_cart$supplementary = cart.supplementary) || null == (_cart$supplementary = _cart$supplementary.initiationIntent) ? void 0 : _cart$supplementary.toLowerCase()) ? sdk_constants_src.INTENT.AUTHORIZE : null == (_cart$supplementary2 = cart.supplementary) || null == (_cart$supplementary2 = _cart$supplementary2.initiationIntent) ? void 0 : _cart$supplementary2.toLowerCase();
                                    var cartCurrency = cart.amounts && cart.amounts.total.currencyCode;
                                    var cartAmount = cart.amounts && cart.amounts.total.currencyValue;
                                    var cartBillingType = cart.billingType;
                                    cartIntent === intent || initiationIntent === intent || -1 === VALIDATE_INTENTS.indexOf(intent) || triggerIntegrationError({
                                        error: "smart_button_validation_error_incorrect_intent",
                                        message: "Expected intent from order api call to be " + intent + ", got " + cartIntent + ". Please ensure you are passing " + sdk_constants_src.SDK_QUERY_KEYS.INTENT + "=" + (initiationIntent || cartIntent) + " to the sdk url. https://developer.paypal.com/docs/checkout/reference/customize-sdk/",
                                        featureFlags: featureFlags,
                                        loggerPayload: {
                                            cartIntent: cartIntent,
                                            intent: intent
                                        },
                                        orderID: orderID
                                    });
                                    if (!window.xprops.createBillingAgreement && buttonLabel === constants.BUTTON_LABEL.DONATE) {
                                        var category = constants.ITEM_CATEGORY.DONATION;
                                        var itemCategory = cart.category || "";
                                        itemCategory && itemCategory === category || triggerIntegrationError({
                                            error: "smart_button_validation_error_incorrect_item_category",
                                            message: "Expected item category from order api call to be " + category + ", got " + itemCategory + ". Please ensure you are passing category=" + category + " for all items in the order payload. https://developer.paypal.com/docs/checkout/reference/customize-sdk/",
                                            featureFlags: featureFlags,
                                            loggerPayload: {
                                                itemCategory: itemCategory,
                                                category: category
                                            },
                                            orderID: orderID
                                        });
                                    }
                                    cartCurrency && cartCurrency !== currency && triggerIntegrationError({
                                        error: "smart_button_validation_error_incorrect_currency",
                                        message: "Expected currency from order api call to be " + currency + ", got " + cartCurrency + ". Please ensure you are passing " + sdk_constants_src.SDK_QUERY_KEYS.CURRENCY + "=" + cartCurrency + " to the sdk url. https://developer.paypal.com/docs/checkout/reference/customize-sdk/",
                                        featureFlags: featureFlags,
                                        loggerPayload: {
                                            cartCurrency: cartCurrency,
                                            currency: currency
                                        },
                                        orderID: orderID
                                    });
                                    merchantID && 0 !== merchantID.length || triggerIntegrationError({
                                        error: "smart_button_validation_error_no_merchant_id",
                                        message: "Could not determine correct merchant id",
                                        featureFlags: featureFlags,
                                        orderID: orderID
                                    });
                                    !cartBillingType || vault || window.xprops.createVaultSetupToken || triggerIntegrationError({
                                        error: "smart_button_validation_error_billing_" + (cartAmount ? "with" : "without") + "_purchase_no_vault",
                                        message: "Expected " + sdk_constants_src.SDK_QUERY_KEYS.VAULT + "=" + sdk_constants_src.VAULT.TRUE.toString() + " for a billing transaction",
                                        featureFlags: featureFlags,
                                        orderID: orderID,
                                        loggerPayload: {
                                            cartBillingType: cartBillingType,
                                            vault: vault
                                        },
                                        throwError: !1
                                    });
                                    vault && window.xprops.createVaultSetupToken ? triggerIntegrationError({
                                        error: "smart_button_validation_error_vault_passed_with_create_vault_setup_token",
                                        message: "Query parameter " + sdk_constants_src.SDK_QUERY_KEYS.VAULT + " is not needed when using createVaultSetupToken",
                                        featureFlags: featureFlags,
                                        orderID: orderID,
                                        loggerPayload: {
                                            vault: vault,
                                            cartBillingType: cartBillingType
                                        },
                                        throwError: !1
                                    }) : !vault || cartBillingType || window.xprops.createBillingAgreement || window.xprops.createSubscription || window.xprops.clientAccessToken || window.xprops.userIDToken || triggerIntegrationError({
                                        error: "smart_button_validation_error_vault_passed_not_needed",
                                        message: "Expected " + sdk_constants_src.SDK_QUERY_KEYS.VAULT + "=" + sdk_constants_src.VAULT.FALSE.toString() + " for a non-billing, non-subscription transaction",
                                        featureFlags: featureFlags,
                                        orderID: orderID,
                                        loggerPayload: {
                                            vault: vault,
                                            cartBillingType: cartBillingType
                                        },
                                        throwError: !1
                                    });
                                    !cartBillingType || cartAmount || intent === sdk_constants_src.INTENT.TOKENIZE || window.xprops.createVaultSetupToken || window.xprops.createSubscription || triggerIntegrationError({
                                        error: "smart_button_validation_error_billing_without_purchase_intent_tokenize_not_passed",
                                        message: "Expected " + sdk_constants_src.SDK_QUERY_KEYS.INTENT + "=" + sdk_constants_src.INTENT.TOKENIZE + " for a billing-without-purchase transaction",
                                        featureFlags: featureFlags,
                                        orderID: orderID,
                                        loggerPayload: {
                                            vault: vault,
                                            cartBillingType: cartBillingType,
                                            cartAmount: cartAmount
                                        },
                                        throwError: !1
                                    });
                                    var payees = order.checkoutSession.payees;
                                    if (!payees) return triggerIntegrationError({
                                        error: "smart_button_validation_error_supplemental_order_missing_payees",
                                        featureFlags: featureFlags,
                                        orderID: orderID,
                                        throwError: !1
                                    });
                                    if (!payees.length) return triggerIntegrationError({
                                        error: "smart_button_validation_error_supplemental_order_no_payees",
                                        featureFlags: featureFlags,
                                        orderID: orderID,
                                        throwError: !1
                                    });
                                    var dict = {};
                                    var uniquePayees = [];
                                    for (var _i2 = 0; _i2 < payees.length; _i2++) {
                                        var payee = payees[_i2];
                                        if (!(payee.merchantId || payee.email && payee.email.stringValue)) return triggerIntegrationError({
                                            error: "smart_button_validation_error_supplemental_order_missing_values",
                                            featureFlags: featureFlags,
                                            orderID: orderID,
                                            loggerPayload: {
                                                payees: JSON.stringify(payees)
                                            },
                                            throwError: !1
                                        });
                                        if (payee.merchantId) {
                                            if (!dict[payee.merchantId]) {
                                                dict[payee.merchantId] = 1;
                                                uniquePayees.push(payee);
                                            }
                                        } else if (payee.email && payee.email.stringValue && !dict[payee.email.stringValue]) {
                                            dict[payee.email.stringValue] = 1;
                                            uniquePayees.push(payee);
                                        }
                                    }
                                    var payeesStr = uniquePayees.map((function(payee) {
                                        if (payee.merchantId) return payee.merchantId;
                                        if (payee.email && payee.email.stringValue) return payee.email.stringValue;
                                        triggerIntegrationError({
                                            error: "smart_button_validation_error_invalid_payee_state",
                                            message: "Invalid payee state: " + JSON.stringify(uniquePayees),
                                            featureFlags: featureFlags,
                                            loggerPayload: {
                                                uniquePayees: JSON.stringify(uniquePayees)
                                            },
                                            orderID: orderID
                                        });
                                        throw new Error("Payees Incorrect");
                                    })).join(",");
                                    var xpropMerchantID = window.xprops.merchantID;
                                    if (!window.xprops.createVaultSetupToken) if (xpropMerchantID && xpropMerchantID.length) isValidMerchantIDs(xpropMerchantID, uniquePayees) || triggerIntegrationError(1 === uniquePayees.length ? {
                                        error: "smart_button_validation_error_payee_no_match",
                                        message: "Payee(s) passed in transaction does not match expected merchant id. Please ensure you are passing " + sdk_constants_src.SDK_QUERY_KEYS.MERCHANT_ID + "=" + payeesStr + " or " + sdk_constants_src.SDK_QUERY_KEYS.MERCHANT_ID + "=" + (uniquePayees[0] && uniquePayees[0].email && uniquePayees[0].email.stringValue ? uniquePayees[0].email.stringValue : "payee@merchant.com") + " to the sdk url. https://developer.paypal.com/docs/checkout/reference/customize-sdk/",
                                        featureFlags: featureFlags,
                                        orderID: orderID
                                    } : {
                                        error: "smart_button_validation_error_payee_no_match",
                                        message: "Payee(s) passed in transaction does not match expected merchant id. Please ensure you are passing " + sdk_constants_src.SDK_QUERY_KEYS.MERCHANT_ID + "=* to the sdk url and " + sdk_constants_src.SDK_SETTINGS.MERCHANT_ID + '="' + payeesStr + '" in the sdk script tag. https://developer.paypal.com/docs/checkout/reference/customize-sdk/',
                                        featureFlags: featureFlags,
                                        orderID: orderID
                                    }); else if (!isValidMerchantIDs(merchantID, uniquePayees)) {
                                        logger.warn("smart_button_validation_error_derived_payee_transaction_mismatch", {
                                            payees: JSON.stringify(uniquePayees),
                                            merchantID: JSON.stringify(merchantID)
                                        });
                                        if (1 === uniquePayees.length) {
                                            env === sdk_constants_src.ENV.SANDBOX && logger.warn("smart_button_validation_error_derived_payee_transaction_mismatch_sandbox", {
                                                payees: JSON.stringify(payees),
                                                merchantID: JSON.stringify(merchantID)
                                            });
                                            triggerIntegrationError({
                                                error: "smart_button_validation_error_payee_no_match",
                                                message: "Payee(s) passed in transaction does not match expected merchant id. Please ensure you are passing " + sdk_constants_src.SDK_QUERY_KEYS.MERCHANT_ID + "=" + payeesStr + " or " + sdk_constants_src.SDK_QUERY_KEYS.MERCHANT_ID + "=" + (uniquePayees[0] && uniquePayees[0].email && uniquePayees[0].email.stringValue ? uniquePayees[0].email.stringValue : "payee@merchant.com") + " to the sdk url. https://developer.paypal.com/docs/checkout/reference/customize-sdk/",
                                                featureFlags: featureFlags,
                                                orderID: orderID,
                                                throwError: !1
                                            });
                                        } else triggerIntegrationError({
                                            error: "smart_button_validation_error_payee_no_match",
                                            message: "Payee(s) passed in transaction does not match expected merchant id. Please ensure you are passing " + sdk_constants_src.SDK_QUERY_KEYS.MERCHANT_ID + "=* to the sdk url and " + sdk_constants_src.SDK_SETTINGS.MERCHANT_ID + '="' + payeesStr + '" in the sdk script tag. https://developer.paypal.com/docs/checkout/reference/customize-sdk/',
                                            featureFlags: featureFlags,
                                            orderID: orderID
                                        });
                                    }
                                }));
                            }(orderID, {
                                env: env,
                                merchantID: merchantID,
                                intent: intent,
                                currency: currency,
                                vault: vault,
                                buttonLabel: buttonLabel,
                                featureFlags: serviceData.featureFlags
                            });
                        }));
                        var confirmOrderPromise = createOrder().then((function(orderID) {
                            return window.xprops.sessionState.get("__confirm_" + fundingSource + "_payload__").then((function(confirmOrderPayload) {
                                if (confirmOrderPayload) return Object(confirmOrder.getConfirmOrder)({
                                    orderID: orderID,
                                    payload: confirmOrderPayload,
                                    partnerAttributionID: partnerAttributionID
                                }, {
                                    facilitatorAccessToken: serviceData.facilitatorAccessToken
                                });
                            }));
                        }));
                        return zalgo_promise_src.ZalgoPromise.all([ loggingPromise, updateClientConfigPromise, clickPromise, vaultPromise, validateOrderPromise, startPromise, confirmOrderPromise ]).catch((function(err) {
                            return zalgo_promise_src.ZalgoPromise.try(close).then((function() {
                                throw err;
                            }));
                        })).then((function() {
                            featureFlags.isButtonClientConfigCallBlocking ? Object(lib.getLogger)().info("redirect_to_xorouter_blocking_cco", {
                                time: Object(lib.getClientsideTimestamp)(),
                                fundingSource: fundingSource,
                                buttonSessionID: buttonSessionID
                            }) : Object(lib.getLogger)().info("redirect_to_xorouter_non_blocking_cco", {
                                time: Object(lib.getClientsideTimestamp)(),
                                fundingSource: fundingSource,
                                buttonSessionID: buttonSessionID
                            });
                        }));
                    }
                }));
            })).finally((function() {
                disableLoadingSpinner(button);
            }));
        }
        try {
            if (!window.paypal) {
                var script = Object(src.querySelectorAll)("script").find((function(el) {
                    return el.getAttribute("data-namespace");
                }));
                script && (window.paypal = window[script.getAttribute("data-namespace")]);
            }
        } catch (err) {}
        function setupButton(_ref) {
            var facilitatorAccessToken = _ref.facilitatorAccessToken, eligibility = _ref.eligibility, fundingEligibility = _ref.fundingEligibility, buyerGeoCountry = _ref.buyerCountry, sdkMeta = _ref.sdkMeta, buyerAccessToken = _ref.buyerAccessToken, wallet = _ref.wallet, cookies = _ref.cookies, serverCSPNonce = _ref.cspNonce, serverMerchantID = _ref.merchantID, firebaseConfig = _ref.firebaseConfig, content = _ref.content, personalization = _ref.personalization, _ref$correlationID = _ref.correlationID, buttonCorrelationID = void 0 === _ref$correlationID ? "" : _ref$correlationID, _ref$brandedDefault = _ref.brandedDefault, brandedDefault = void 0 === _ref$brandedDefault ? null : _ref$brandedDefault, _ref$experiments = _ref.experiments, experiments = void 0 === _ref$experiments ? {} : _ref$experiments, featureFlags = _ref.featureFlags, product = _ref.product, dumbledoreCurrentReleaseHash = _ref.dumbledoreCurrentReleaseHash, dumbledoreServiceWorker = _ref.dumbledoreServiceWorker;
            if (!window.paypal) throw new Error("PayPal SDK not loaded");
            var clientID = window.xprops.clientID;
            var serviceData = getServiceData({
                eligibility: eligibility,
                facilitatorAccessToken: facilitatorAccessToken,
                buyerGeoCountry: buyerGeoCountry,
                serverMerchantID: serverMerchantID,
                fundingEligibility: fundingEligibility,
                cookies: cookies,
                sdkMeta: sdkMeta,
                buyerAccessToken: buyerAccessToken,
                wallet: wallet,
                content: content,
                personalization: personalization,
                featureFlags: featureFlags
            });
            var merchantID = serviceData.merchantID, buyerCountry = serviceData.buyerCountry;
            var props = getButtonProps({
                facilitatorAccessToken: facilitatorAccessToken,
                brandedDefault: brandedDefault,
                paymentSource: null,
                featureFlags: featureFlags,
                experiments: experiments
            });
            var env = props.env, sessionID = props.sessionID, partnerAttributionID = props.partnerAttributionID, commit = props.commit, sdkCorrelationID = props.sdkCorrelationID, locale = props.locale, onShippingChange = props.onShippingChange, buttonSessionID = props.buttonSessionID, merchantDomain = props.merchantDomain, onInit = props.onInit, getPrerenderDetails = props.getPrerenderDetails, rememberFunding = props.rememberFunding, getQueriedEligibleFunding = props.getQueriedEligibleFunding, style = props.style, fundingSource = props.fundingSource, intent = props.intent, createBillingAgreement = props.createBillingAgreement, createSubscription = props.createSubscription, stickinessID = props.stickinessID;
            var config = getConfig({
                serverCSPNonce: serverCSPNonce,
                firebaseConfig: firebaseConfig
            });
            var sdkVersion = config.sdkVersion;
            var components = getComponents();
            var _onInit = onInit({
                correlationID: buttonCorrelationID
            }), initPromise = _onInit.initPromise, isEnabled = _onInit.isEnabled;
            var paymentProcessing = !1;
            function initiatePayment(_ref2) {
                var payment = _ref2.payment, paymentProps = _ref2.props;
                return zalgo_promise_src.ZalgoPromise.try((function() {
                    if (!paymentProcessing) {
                        var win = payment.win, paymentFundingSource = payment.fundingSource;
                        var onClick = paymentProps.onClick;
                        var smartFields = Object(lib.getSmartFieldsByFundingSource)(paymentFundingSource);
                        if (!smartFields || smartFields.isValid()) {
                            onClick && onClick({
                                fundingSource: paymentFundingSource
                            });
                            if (isEnabled()) {
                                paymentProcessing = !0;
                                return initiatePaymentFlow({
                                    payment: payment,
                                    config: config,
                                    serviceData: serviceData,
                                    components: components,
                                    props: paymentProps,
                                    experiments: experiments
                                }).finally((function() {
                                    paymentProcessing = !1;
                                }));
                            }
                            win && win.close();
                        } else win && win.close();
                    }
                })).catch((function(err) {
                    Object(lib.getLogger)().info("smart_buttons_payment_error", {
                        err: Object(src.stringifyError)(err)
                    });
                    throw err;
                }));
            }
            menu_menu = null;
            Object(src.querySelectorAll)("[ " + constants.DATA_ATTRIBUTES.FUNDING_SOURCE + " ]").forEach((function(button) {
                var menuToggle = function(button) {
                    var menu = button.querySelector("[" + constants.DATA_ATTRIBUTES.MENU + "]");
                    if (menu) return menu;
                    var parent = button.parentNode;
                    parent && (menu = parent.querySelector("[" + constants.DATA_ATTRIBUTES.MENU + "]"));
                    return menu || void 0;
                }(button);
                var _getSelectedFunding = function(button) {
                    var fundingSource = button.getAttribute(constants.DATA_ATTRIBUTES.FUNDING_SOURCE);
                    var paymentMethodID = button.getAttribute(constants.DATA_ATTRIBUTES.PAYMENT_METHOD_ID);
                    var instrumentID = button.getAttribute(constants.DATA_ATTRIBUTES.INSTRUMENT_ID);
                    var instrumentType = button.getAttribute(constants.DATA_ATTRIBUTES.INSTRUMENT_TYPE);
                    return {
                        fundingSource: fundingSource,
                        card: button.getAttribute(constants.DATA_ATTRIBUTES.CARD),
                        paymentMethodID: paymentMethodID,
                        instrumentID: instrumentID,
                        instrumentType: instrumentType
                    };
                }(button), paymentFundingSource = _getSelectedFunding.fundingSource;
                var payment = {
                    button: button,
                    menuToggle: menuToggle,
                    fundingSource: paymentFundingSource,
                    card: _getSelectedFunding.card,
                    paymentMethodID: _getSelectedFunding.paymentMethodID,
                    instrumentID: _getSelectedFunding.instrumentID,
                    instrumentType: _getSelectedFunding.instrumentType,
                    isClick: !0,
                    buyerIntent: constants.BUYER_INTENT.PAY
                };
                Object(src.preventClickFocus)(button);
                Object(src.onClick)(button, (function(event) {
                    event.preventDefault();
                    event.stopPropagation();
                    Object(lib.getLogger)().addTrackingBuilder((function() {
                        var _ref4;
                        return (_ref4 = {})[constants.FPTI_CUSTOM_KEY.ORDER_CREATED_BY] = constants.ORDER_CREATED_BY.BUTTON_CLICK, 
                        _ref4;
                    }));
                    if (eligibility.isServiceWorkerEligible) {
                        Object(lib.getLogger)().info("SERVICE_WORKER_ELMO_TREATMENT");
                        Object(lib.registerServiceWorker)({
                            dumbledoreCurrentReleaseHash: dumbledoreCurrentReleaseHash,
                            dumbledoreServiceWorker: dumbledoreServiceWorker
                        });
                    } else {
                        var _getLogger$info$track2;
                        Object(lib.getLogger)().info("SERVICE_WORKER_ELMO_CONTROL").track(((_getLogger$info$track2 = {})[sdk_constants_src.FPTI_KEY.EVENT_NAME] = "SERVICE_WORKER_NOT_ELIGIBLE", 
                        _getLogger$info$track2));
                        Object(lib.unregisterServiceWorker)();
                    }
                    var paymentProps = getButtonProps({
                        facilitatorAccessToken: facilitatorAccessToken,
                        brandedDefault: brandedDefault,
                        paymentSource: paymentFundingSource,
                        featureFlags: featureFlags,
                        experiments: experiments
                    });
                    var payPromise = initiatePayment({
                        payment: payment,
                        props: paymentProps
                    });
                    var onError = paymentProps.onError;
                    payPromise.catch((function(err) {
                        var _getLogger$warn$track;
                        Object(lib.sendCountMetric)({
                            name: "pp.app.paypal_sdk.buttons.click.error.count",
                            dimensions: {
                                errorName: "payment_flow_error",
                                fundingSource: paymentFundingSource,
                                prerender: !1
                            }
                        });
                        Object(lib.getLogger)().warn("click_initiate_payment_reject", {
                            err: Object(src.stringifyError)(err)
                        }).track((_getLogger$warn$track = {}, _getLogger$warn$track[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                        _getLogger$warn$track[sdk_constants_src.FPTI_KEY.ERROR_CODE] = "smart_buttons_payment_error", 
                        _getLogger$warn$track[sdk_constants_src.FPTI_KEY.ERROR_DESC] = Object(src.stringifyErrorMessage)(err), 
                        _getLogger$warn$track)).flush();
                        onError(err);
                    }));
                    button.payPromise = payPromise;
                }));
                if (menuToggle) {
                    !function(_ref2) {
                        var props = _ref2.props;
                        var clientID = props.clientID;
                        clientID && renderButtonSmartMenu({
                            containerUID: props.uid,
                            clientID: clientID,
                            Menu: _ref2.components.Menu
                        });
                    }({
                        props: props,
                        components: components
                    });
                    Object(src.onClick)(menuToggle, (function(event) {
                        event.preventDefault();
                        event.stopPropagation();
                        var menuPromise = function(_ref3) {
                            var payment = _ref3.payment;
                            return zalgo_promise_src.ZalgoPromise.try((function() {
                                if (!paymentProcessing) return isEnabled() ? function(_ref7) {
                                    var payment = _ref7.payment, serviceData = _ref7.serviceData, config = _ref7.config, components = _ref7.components, props = _ref7.props, experiments = _ref7.experiments;
                                    return zalgo_promise_src.ZalgoPromise.try((function() {
                                        var _getLogger$info$info$;
                                        var fundingSource = payment.fundingSource, button = payment.button;
                                        var _getPaymentFlow2 = getPaymentFlow({
                                            props: props,
                                            payment: payment,
                                            config: config,
                                            components: components,
                                            serviceData: serviceData
                                        }), name = _getPaymentFlow2.name, setupMenu = _getPaymentFlow2.setupMenu;
                                        if (!setupMenu) throw new Error(name + " does not support menu");
                                        Object(lib.getLogger)().info("menu_click").info("pay_flow_" + name).track((_getLogger$info$info$ = {}, 
                                        _getLogger$info$info$[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                                        _getLogger$info$info$[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.MENU_CLICK, 
                                        _getLogger$info$info$[sdk_constants_src.FPTI_KEY.CHOSEN_FUNDING] = fundingSource, 
                                        _getLogger$info$info$[sdk_constants_src.FPTI_KEY.PAYMENT_FLOW] = name, _getLogger$info$info$)).flush();
                                        var choices = setupMenu({
                                            props: props,
                                            payment: payment,
                                            serviceData: serviceData,
                                            components: components,
                                            config: config,
                                            restart: function(_ref8) {
                                                return initiatePaymentFlow({
                                                    payment: _ref8.payment,
                                                    serviceData: serviceData,
                                                    config: config,
                                                    components: components,
                                                    props: props,
                                                    experiments: experiments
                                                });
                                            },
                                            experiments: experiments
                                        }).map((function(choice) {
                                            return Object(esm_extends.default)({}, choice, {
                                                onSelect: function() {
                                                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                                                    choice.spinner && enableLoadingSpinner(button);
                                                    return zalgo_promise_src.ZalgoPromise.try((function() {
                                                        return choice.onSelect.apply(choice, args);
                                                    })).then((function() {
                                                        choice.spinner && disableLoadingSpinner(button);
                                                    }));
                                                }
                                            });
                                        }));
                                        return function(_ref3) {
                                            var props = _ref3.props, payment = _ref3.payment, choices = _ref3.choices;
                                            var clientID = props.clientID, containerUID = props.uid;
                                            var button = payment.button, menuToggle = payment.menuToggle;
                                            var Menu = _ref3.components.Menu;
                                            if (!clientID) throw new Error("Can not render menu without client id");
                                            var smartMenu = menu_menu || renderButtonSmartMenu({
                                                containerUID: containerUID,
                                                clientID: clientID,
                                                Menu: Menu
                                            });
                                            menu_menu = smartMenu;
                                            var loadingTimeout = setTimeout((function() {
                                                return enableLoadingSpinner(button);
                                            }), 50);
                                            var updateProps = function() {
                                                return smartMenu.updateProps({
                                                    clientID: clientID,
                                                    choices: choices,
                                                    verticalOffset: button.getBoundingClientRect().bottom,
                                                    onFocusFail: onFocusFail,
                                                    onBlur: onBlur
                                                });
                                            };
                                            window.addEventListener("resize", updateProps);
                                            var onBlur = function() {
                                                smartMenu.hide();
                                                window.removeEventListener("resize", updateProps);
                                            };
                                            var onFocusFail = function() {
                                                menuToggle && menuToggle.addEventListener("blur", (function blur() {
                                                    menuToggle.removeEventListener("blur", blur);
                                                    onBlur();
                                                }));
                                            };
                                            return updateProps().then((function() {
                                                return smartMenu.show();
                                            })).then((function() {
                                                disableLoadingSpinner(button);
                                            })).finally((function() {
                                                clearTimeout(loadingTimeout);
                                            }));
                                        }({
                                            props: props,
                                            payment: payment,
                                            components: components,
                                            choices: choices
                                        });
                                    }));
                                }({
                                    payment: payment,
                                    config: config,
                                    serviceData: serviceData,
                                    components: components,
                                    props: props,
                                    experiments: experiments
                                }) : void 0;
                            })).catch((function(err) {
                                var _getLogger$info$track;
                                Object(lib.getLogger)().info("smart_buttons_payment_error", {
                                    err: Object(src.stringifyError)(err)
                                }).track(((_getLogger$info$track = {})[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                                _getLogger$info$track[sdk_constants_src.FPTI_KEY.ERROR_CODE] = "smart_buttons_payment_error", 
                                _getLogger$info$track[sdk_constants_src.FPTI_KEY.ERROR_DESC] = Object(src.stringifyErrorMessage)(err), 
                                _getLogger$info$track));
                                throw err;
                            }));
                        }({
                            payment: payment
                        });
                        button.menuPromise = menuPromise;
                    }));
                }
            }));
            var setupPrerenderTask = initPromise.then((function() {
                return zalgo_promise_src.ZalgoPromise.hash({
                    prerenderDetails: getPrerenderDetails(),
                    initPromise: initPromise
                }).then((function(_ref5) {
                    var prerenderDetails = _ref5.prerenderDetails;
                    if (prerenderDetails) {
                        var win = prerenderDetails.win, paymentFundingSource = prerenderDetails.fundingSource, card = prerenderDetails.card;
                        var button = document.querySelector("[" + constants.DATA_ATTRIBUTES.FUNDING_SOURCE + "=" + paymentFundingSource + "]");
                        if (!button) throw new Error("Can not find button element");
                        var paymentProps = getButtonProps({
                            facilitatorAccessToken: facilitatorAccessToken,
                            brandedDefault: brandedDefault,
                            paymentSource: paymentFundingSource,
                            featureFlags: featureFlags,
                            experiments: experiments
                        });
                        var payPromise = initiatePayment({
                            payment: {
                                win: win,
                                button: button,
                                fundingSource: paymentFundingSource,
                                card: card,
                                buyerIntent: constants.BUYER_INTENT.PAY
                            },
                            props: paymentProps
                        });
                        var onError = paymentProps.onError;
                        payPromise.catch((function(err) {
                            var _getLogger$error$trac;
                            Object(lib.sendCountMetric)({
                                name: "pp.app.paypal_sdk.buttons.click.error.count",
                                dimensions: {
                                    fundingSource: paymentFundingSource,
                                    prerender: !0
                                }
                            });
                            Object(lib.getLogger)().error("prerender_initiate_payment_reject", {
                                err: Object(src.stringifyError)(err)
                            }).track((_getLogger$error$trac = {}, _getLogger$error$trac[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                            _getLogger$error$trac[sdk_constants_src.FPTI_KEY.ERROR_CODE] = "smart_buttons_prerender_payment_error", 
                            _getLogger$error$trac[sdk_constants_src.FPTI_KEY.ERROR_DESC] = Object(src.stringifyErrorMessage)(err), 
                            _getLogger$error$trac)).flush();
                            onError(err);
                        }));
                        button.payPromise = payPromise;
                    }
                }));
            }));
            var setupRememberTask = function(_ref) {
                var rememberFunding = _ref.rememberFunding, fundingEligibility = _ref.fundingEligibility;
                return zalgo_promise_src.ZalgoPromise.try((function() {
                    if (fundingEligibility && fundingEligibility.venmo && fundingEligibility.venmo.eligible) return rememberFunding([ sdk_constants_src.FUNDING.VENMO ]);
                }));
            }({
                rememberFunding: rememberFunding,
                fundingEligibility: fundingEligibility
            });
            var setupButtonLogsTask = function(_ref) {
                var env = _ref.env, sessionID = _ref.sessionID, buttonSessionID = _ref.buttonSessionID, clientID = _ref.clientID, partnerAttributionID = _ref.partnerAttributionID, commit = _ref.commit, sdkCorrelationID = _ref.sdkCorrelationID, buttonCorrelationID = _ref.buttonCorrelationID, locale = _ref.locale, merchantID = _ref.merchantID, merchantDomain = _ref.merchantDomain, sdkVersion = _ref.sdkVersion, style = _ref.style, fundingSource = _ref.fundingSource, getQueriedEligibleFunding = _ref.getQueriedEligibleFunding, stickinessID = _ref.stickinessID, buyerCountry = _ref.buyerCountry, onShippingChange = _ref.onShippingChange, product = _ref.product;
                var logger = Object(lib.getLogger)();
                Object(lib.setupLogger)({
                    env: env,
                    sessionID: sessionID,
                    clientID: clientID,
                    sdkCorrelationID: sdkCorrelationID,
                    locale: locale,
                    sdkVersion: sdkVersion,
                    buyerCountry: buyerCountry
                });
                logger.addPayloadBuilder((function() {
                    return {
                        buttonSessionID: buttonSessionID,
                        buttonCorrelationID: buttonCorrelationID
                    };
                }));
                logger.addTrackingBuilder((function() {
                    var _ref2;
                    return (_ref2 = {})[sdk_constants_src.FPTI_KEY.CONTEXT_TYPE] = constants.FPTI_CONTEXT_TYPE.BUTTON_SESSION_ID, 
                    _ref2[sdk_constants_src.FPTI_KEY.CONTEXT_ID] = buttonSessionID, _ref2[sdk_constants_src.FPTI_KEY.BUTTON_SESSION_UID] = buttonSessionID, 
                    _ref2[sdk_constants_src.FPTI_KEY.BUTTON_VERSION] = "5.0.162", _ref2[constants.FPTI_BUTTON_KEY.BUTTON_CORRELATION_ID] = buttonCorrelationID, 
                    _ref2[sdk_constants_src.FPTI_KEY.STICKINESS_ID] = Object(lib.isAndroidChrome)() ? stickinessID : null, 
                    _ref2[sdk_constants_src.FPTI_KEY.PARTNER_ATTRIBUTION_ID] = partnerAttributionID, 
                    _ref2[sdk_constants_src.FPTI_KEY.USER_ACTION] = commit ? sdk_constants_src.FPTI_USER_ACTION.COMMIT : sdk_constants_src.FPTI_USER_ACTION.CONTINUE, 
                    _ref2[sdk_constants_src.FPTI_KEY.SELLER_ID] = merchantID[0], _ref2[sdk_constants_src.FPTI_KEY.MERCHANT_DOMAIN] = merchantDomain, 
                    _ref2[sdk_constants_src.FPTI_KEY.CHOSEN_FUNDING] = fundingSource, _ref2[sdk_constants_src.FPTI_KEY.PRODUCT] = product, 
                    _ref2[sdk_constants_src.FPTI_KEY.TIMESTAMP] = Date.now().toString(), _ref2;
                }));
                Object(src.isIEIntranet)() && logger.warn("button_child_intranet_mode");
                return zalgo_promise_src.ZalgoPromise.hash({
                    pageRenderTime: Object(src.getPageRenderTime)(),
                    queriedEligibleFunding: getQueriedEligibleFunding()
                }).then((function(_ref3) {
                    var _tracking;
                    var pageRenderTime = _ref3.pageRenderTime, queriedEligibleFunding = _ref3.queriedEligibleFunding;
                    var fundingSources = Object(src.querySelectorAll)("[" + constants.DATA_ATTRIBUTES.FUNDING_SOURCE + "]").map((function(el) {
                        return el.getAttribute(constants.DATA_ATTRIBUTES.FUNDING_SOURCE);
                    })).filter(Boolean);
                    var walletInstruments = Object(src.querySelectorAll)("[" + constants.DATA_ATTRIBUTES.INSTRUMENT_TYPE + "]").flatMap((function(el) {
                        return [ el.getAttribute(constants.DATA_ATTRIBUTES.INSTRUMENT_TYPE), el.getAttribute(constants.DATA_ATTRIBUTES.SECONDARY_INSTRUMENT_TYPE) ];
                    })).filter(Boolean);
                    var payNow = Object(src.querySelectorAll)("[" + constants.DATA_ATTRIBUTES.FUNDING_SOURCE + "]").map((function(el) {
                        return el.getAttribute(constants.DATA_ATTRIBUTES.PAY_NOW);
                    })).some(Boolean);
                    var layout = style.layout, color = style.color, shape = style.shape, label = style.label, _style$tagline = style.tagline, tagline = void 0 === _style$tagline || _style$tagline;
                    var nativeDevice = "non_native";
                    Object(lib.isIOSSafari)() ? nativeDevice = "ios_safari" : Object(lib.isAndroidChrome)() && (nativeDevice = "android_chrome");
                    var serverRenderVersion = (document.body && document.body.getAttribute("" + constants.DATA_ATTRIBUTES.RENDER_VERSION) || "unknown").replace(/[^a-zA-Z0-9]+/g, "_");
                    if (serverRenderVersion.split("_").join(".") !== sdkVersion) {
                        logger.warn("server_render_version_mismatch", {
                            sdkVersion: sdkVersion,
                            serverRenderVersion: serverRenderVersion
                        });
                        Object(lib.sendCountMetric)({
                            name: "pp.app.paypal_sdk.buttons.server_render_version_mismatch",
                            dimensions: {}
                        });
                    }
                    logger.info("smart_payment_buttons_render_options", {
                        color: color,
                        label: label,
                        layout: layout,
                        nativeDevice: nativeDevice,
                        shape: shape,
                        fundingInstruments: fundingSources.join(","),
                        fundingInstrumentsCount: fundingSources.length.toString(),
                        js_sdk_version: (document.body && document.body.getAttribute("" + constants.DATA_ATTRIBUTES.CLIENT_VERSION) || "unknown").replace(/[^a-zA-Z0-9]+/g, "_"),
                        storageState: Object(lib.isStorageStateFresh)() ? "fresh" : "not_fresh",
                        tagline: tagline.toString(),
                        version: serverRenderVersion,
                        walletInstruments: walletInstruments.join(","),
                        walletInstrumentsCount: walletInstruments.length.toString()
                    });
                    if (window.performance) try {
                        var _logger$track;
                        var responseStartTime = (startTime = document.body && document.body.getAttribute(constants.DATA_ATTRIBUTES.RESPONSE_START_TIME), 
                        Number(startTime));
                        var responseEndTime = Object(lib.getNavigationTimeOrigin)() + performance.getEntriesByName("buttons-response-received").pop().startTime;
                        var cplPhases = Object(lib.prepareLatencyInstrumentationPayload)(responseStartTime, responseEndTime);
                        logger.info("CPL_LATENCY_METRICS_SECOND_RENDER");
                        logger.track(((_logger$track = {})[sdk_constants_src.FPTI_KEY.STATE] = "CPL_LATENCY_METRICS", 
                        _logger$track[sdk_constants_src.FPTI_KEY.TRANSITION] = "process_client_metrics", 
                        _logger$track[sdk_constants_src.FPTI_KEY.PAGE] = "main:xo:paypal-components:smart-payment-buttons", 
                        _logger$track[sdk_constants_src.FPTI_KEY.CPL_COMP_METRICS] = JSON.stringify((null == cplPhases ? void 0 : cplPhases.comp) || {}), 
                        _logger$track));
                    } catch (error) {
                        logger.info("button_render_CPL_instrumentation_log_error", error);
                    } else logger.info("button_render_CPL_instrumentation_not_executed");
                    var startTime;
                    var tracking = ((_tracking = {})[sdk_constants_src.FPTI_KEY.STATE] = constants.FPTI_STATE.BUTTON, 
                    _tracking[sdk_constants_src.FPTI_KEY.TRANSITION] = constants.FPTI_TRANSITION.BUTTON_LOAD, 
                    _tracking[sdk_constants_src.FPTI_KEY.EVENT_NAME] = constants.FPTI_TRANSITION.BUTTON_LOAD, 
                    _tracking[sdk_constants_src.FPTI_KEY.FUNDING_LIST] = fundingSources.join(":"), _tracking[sdk_constants_src.FPTI_KEY.FI_LIST] = walletInstruments.join(":"), 
                    _tracking[sdk_constants_src.FPTI_KEY.SELECTED_FI] = fundingSource, _tracking[sdk_constants_src.FPTI_KEY.FUNDING_COUNT] = fundingSources.length.toString(), 
                    _tracking[sdk_constants_src.FPTI_KEY.PAGE_LOAD_TIME] = pageRenderTime ? pageRenderTime.toString() : "", 
                    _tracking[sdk_constants_src.FPTI_KEY.POTENTIAL_PAYMENT_METHODS] = Array.isArray(queriedEligibleFunding) ? queriedEligibleFunding.join(":") : "", 
                    _tracking[sdk_constants_src.FPTI_KEY.PAY_NOW] = payNow.toString(), _tracking[constants.FPTI_BUTTON_KEY.BUTTON_LAYOUT] = layout, 
                    _tracking[constants.FPTI_BUTTON_KEY.BUTTON_COLOR] = color, _tracking[constants.FPTI_BUTTON_KEY.BUTTON_SIZE] = "responsive", 
                    _tracking[constants.FPTI_BUTTON_KEY.BUTTON_SHAPE] = shape, _tracking[constants.FPTI_BUTTON_KEY.BUTTON_LABEL] = label, 
                    _tracking[constants.FPTI_BUTTON_KEY.BUTTON_WIDTH] = window.innerWidth, _tracking[constants.FPTI_BUTTON_KEY.BUTTON_TYPE] = constants.FPTI_BUTTON_TYPE.IFRAME, 
                    _tracking[constants.FPTI_BUTTON_KEY.BUTTON_TAGLINE_ENABLED] = tagline ? "1" : "0", 
                    _tracking[constants.FPTI_CUSTOM_KEY.SHIPPING_CALLBACK_PASSED] = onShippingChange ? "1" : "0", 
                    _tracking);
                    logger.track(tracking);
                    logger.flush();
                }));
            }({
                style: style,
                env: env,
                sdkVersion: sdkVersion,
                sessionID: sessionID,
                clientID: clientID,
                partnerAttributionID: partnerAttributionID,
                commit: commit,
                sdkCorrelationID: sdkCorrelationID,
                stickinessID: stickinessID,
                buttonCorrelationID: buttonCorrelationID,
                locale: locale,
                merchantID: merchantID,
                buttonSessionID: buttonSessionID,
                merchantDomain: merchantDomain,
                fundingSource: fundingSource,
                getQueriedEligibleFunding: getQueriedEligibleFunding,
                buyerCountry: buyerCountry,
                onShippingChange: onShippingChange,
                product: product
            });
            var setupPaymentFlowsTask = function(_ref) {
                var props = _ref.props, config = _ref.config, serviceData = _ref.serviceData, components = _ref.components;
                return zalgo_promise_src.ZalgoPromise.all(PAYMENT_FLOWS.map((function(flow) {
                    return flow.isEligible({
                        props: props,
                        config: config,
                        serviceData: serviceData
                    }) ? flow.setup({
                        props: props,
                        config: config,
                        serviceData: serviceData,
                        components: components
                    }) : null;
                }))).then(src.noop);
            }({
                props: props,
                config: config,
                serviceData: serviceData,
                components: components
            });
            var setupExportsTask = function(_ref) {
                var props = _ref.props, isEnabled = _ref.isEnabled, facilitatorAccessToken = _ref.facilitatorAccessToken, fundingEligibility = _ref.fundingEligibility, merchantID = _ref.merchantID;
                var _createOrder = props.createOrder, _onApprove = props.onApprove, onError = props.onError, onCancel = props.onCancel, onClick = props.onClick, _onShippingChange = props.onShippingChange, commit = props.commit, intent = props.intent, fundingSource = props.fundingSource, currency = props.currency;
                var fundingSources = Object(src.querySelectorAll)("[" + constants.DATA_ATTRIBUTES.FUNDING_SOURCE + "]").map((function(el) {
                    return el.getAttribute(constants.DATA_ATTRIBUTES.FUNDING_SOURCE);
                })).filter(Boolean);
                window.exports = {
                    name: "smart-payment-buttons",
                    commit: {
                        commit: commit,
                        currency: currency,
                        intent: intent
                    },
                    currency: currency,
                    intent: intent,
                    isGuestEnabled: function() {
                        var _fundingEligibility$c;
                        return null != fundingEligibility && null != (_fundingEligibility$c = fundingEligibility.card) && _fundingEligibility$c.hasOwnProperty("guestEnabled") ? fundingEligibility.card.guestEnabled : Object(api.getGuestEnabledStatus)(merchantID);
                    },
                    isShippingChangeEnabled: function() {
                        return "function" == typeof _onShippingChange;
                    },
                    paymentSession: function() {
                        return {
                            getAvailableFundingSources: function() {
                                return fundingSources;
                            },
                            createOrder: function(data) {
                                var _ref2$eventSource = (data || {}).eventSource, eventSource = void 0 === _ref2$eventSource ? constants.ORDER_CREATED_BY.UNKNOWN_EVENT : _ref2$eventSource;
                                Object(lib.getLogger)().addTrackingBuilder((function() {
                                    var _ref3;
                                    return (_ref3 = {})[constants.FPTI_CUSTOM_KEY.ORDER_CREATED_BY] = eventSource, _ref3;
                                }));
                                if (!isEnabled()) throw new Error("Error occurred. Button not enabled.");
                                return zalgo_promise_src.ZalgoPromise.hash({
                                    valid: !onClick || !fundingSource || onClick({
                                        fundingSource: fundingSource
                                    })
                                }).then((function(_ref4) {
                                    if (_ref4.valid) return _createOrder();
                                    throw new Error("Error occurred during async validation");
                                }));
                            },
                            onApprove: function(merchantData) {
                                return _onApprove({
                                    payerID: merchantData.payerID,
                                    forceRestAPI: !0
                                }, {
                                    restart: function() {
                                        throw new Error("Action unimplemented");
                                    }
                                });
                            },
                            onCancel: onCancel,
                            onError: onError,
                            upgradeFacilitatorAccessToken: function(_ref5) {
                                var merchantAccessToken = _ref5.facilitatorAccessToken, orderID = _ref5.orderID;
                                var buyerAccessToken = Object(lib.getBuyerAccessToken)();
                                if (!buyerAccessToken) {
                                    Object(lib.getLogger)().error("lsat_upgrade_error", {
                                        err: "buyer access token not found"
                                    });
                                    throw new Error("Buyer access token not found");
                                }
                                return Object(api.upgradeFacilitatorAccessToken)(merchantAccessToken, {
                                    buyerAccessToken: buyerAccessToken,
                                    orderID: orderID
                                });
                            },
                            getFacilitatorAccessToken: function() {
                                return facilitatorAccessToken;
                            },
                            onShippingChange: function(data) {
                                if (_onShippingChange) return _onShippingChange(data, {
                                    resolve: function() {
                                        throw new Error("Action unimplemented");
                                    },
                                    reject: function() {
                                        throw new Error("Action unimplemented");
                                    }
                                });
                            }
                        };
                    }
                };
            }({
                props: props,
                isEnabled: isEnabled,
                facilitatorAccessToken: facilitatorAccessToken,
                fundingEligibility: fundingEligibility,
                merchantID: merchantID
            });
            var validatePropsTask = setupButtonLogsTask.then((function() {
                return function(_ref2) {
                    var intent = _ref2.intent, createBillingAgreement = _ref2.createBillingAgreement, createSubscription = _ref2.createSubscription, featureFlags = _ref2.featureFlags;
                    var logger = Object(lib_logger.getLogger)();
                    createBillingAgreement && intent !== sdk_constants_src.INTENT.TOKENIZE && triggerIntegrationError({
                        error: "smart_button_validation_error_expected_intent_tokenize",
                        message: "Expected intent=" + sdk_constants_src.INTENT.TOKENIZE + " to be passed to SDK with createBillingAgreement, but got intent=" + intent,
                        featureFlags: featureFlags,
                        loggerPayload: {
                            intent: intent
                        },
                        throwError: !1
                    });
                    createSubscription && intent !== sdk_constants_src.INTENT.SUBSCRIPTION && triggerIntegrationError({
                        error: "smart_button_validation_error_expected_intent_subscription",
                        message: "Expected intent=" + sdk_constants_src.INTENT.SUBSCRIPTION + " to be passed to SDK with createSubscription, but got intent=" + intent,
                        featureFlags: featureFlags,
                        loggerPayload: {
                            intent: intent
                        },
                        throwError: !1
                    });
                    logger.flush();
                }({
                    intent: intent,
                    createBillingAgreement: createBillingAgreement,
                    createSubscription: createSubscription,
                    featureFlags: featureFlags
                });
            }));
            return zalgo_promise_src.ZalgoPromise.hash({
                initPromise: initPromise,
                facilitatorAccessToken: facilitatorAccessToken,
                setupButtonLogsTask: setupButtonLogsTask,
                setupPrerenderTask: setupPrerenderTask,
                setupRememberTask: setupRememberTask,
                setupPaymentFlowsTask: setupPaymentFlowsTask,
                validatePropsTask: validatePropsTask,
                setupExportsTask: setupExportsTask
            }).then(src.noop);
        }
    },
    "./src/config.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "LOGGER_URL", (function() {
            return LOGGER_URL;
        }));
        __webpack_require__.d(__webpack_exports__, "AUTH_API_URL", (function() {
            return AUTH_API_URL;
        }));
        __webpack_require__.d(__webpack_exports__, "ORDERS_API_URL", (function() {
            return ORDERS_API_URL;
        }));
        __webpack_require__.d(__webpack_exports__, "PAYMENTS_API_URL", (function() {
            return PAYMENTS_API_URL;
        }));
        __webpack_require__.d(__webpack_exports__, "CREATE_SUBSCRIPTIONS_API_URL", (function() {
            return CREATE_SUBSCRIPTIONS_API_URL;
        }));
        __webpack_require__.d(__webpack_exports__, "VALIDATE_PAYMENT_METHOD_API", (function() {
            return VALIDATE_PAYMENT_METHOD_API;
        }));
        __webpack_require__.d(__webpack_exports__, "VAULT_API_URL", (function() {
            return VAULT_API_URL;
        }));
        __webpack_require__.d(__webpack_exports__, "VAULT_SETUP_TOKENS_API_URL", (function() {
            return VAULT_SETUP_TOKENS_API_URL;
        }));
        __webpack_require__.d(__webpack_exports__, "BASE_SMART_API_URL", (function() {
            return BASE_SMART_API_URL;
        }));
        __webpack_require__.d(__webpack_exports__, "SMART_API_URI", (function() {
            return SMART_API_URI;
        }));
        __webpack_require__.d(__webpack_exports__, "GRAPHQL_URI", (function() {
            return GRAPHQL_URI;
        }));
        __webpack_require__.d(__webpack_exports__, "WEB_CHECKOUT_URI", (function() {
            return WEB_CHECKOUT_URI;
        }));
        __webpack_require__.d(__webpack_exports__, "FUNDING_SKIP_LOGIN", (function() {
            return FUNDING_SKIP_LOGIN;
        }));
        __webpack_require__.d(__webpack_exports__, "NATIVE_DETECTION_URL", (function() {
            return NATIVE_DETECTION_URL;
        }));
        __webpack_require__.d(__webpack_exports__, "FIREBASE_SCRIPTS", (function() {
            return FIREBASE_SCRIPTS;
        }));
        __webpack_require__.d(__webpack_exports__, "ENABLE_PAYMENT_API", (function() {
            return ENABLE_PAYMENT_API;
        }));
        var _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _FUNDING_SKIP_LOGIN;
        var LOGGER_URL = "/xoplatform/logger/api/logger";
        var AUTH_API_URL = "/v1/oauth2/token";
        var ORDERS_API_URL = "/v2/checkout/orders";
        var PAYMENTS_API_URL = "/v1/payments/payment";
        var CREATE_SUBSCRIPTIONS_API_URL = "/v1/billing/subscriptions";
        var VALIDATE_PAYMENT_METHOD_API = "validate-payment-method";
        var VAULT_API_URL = "/v3/vault";
        var VAULT_SETUP_TOKENS_API_URL = VAULT_API_URL + "/setup-tokens";
        var BASE_SMART_API_URL = "/smart/api";
        var SMART_API_URI = {
            AUTH: BASE_SMART_API_URL + "/auth",
            CHECKOUT: BASE_SMART_API_URL + "/checkout",
            ORDER: BASE_SMART_API_URL + "/order",
            PAYMENT: BASE_SMART_API_URL + "/payment",
            SUBSCRIPTION: BASE_SMART_API_URL + "/billagmt/subscriptions",
            VAULT: BASE_SMART_API_URL + "/vault"
        };
        var GRAPHQL_URI = "/graphql";
        var WEB_CHECKOUT_URI = "/checkoutnow";
        var FUNDING_SKIP_LOGIN = ((_FUNDING_SKIP_LOGIN = {})[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_0__.FUNDING.PAYPAL] = _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_0__.FUNDING.PAYPAL, 
        _FUNDING_SKIP_LOGIN[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_0__.FUNDING.PAYLATER] = _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_0__.FUNDING.PAYPAL, 
        _FUNDING_SKIP_LOGIN[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_0__.FUNDING.CREDIT] = _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_0__.FUNDING.PAYPAL, 
        _FUNDING_SKIP_LOGIN);
        var NATIVE_DETECTION_URL = "http://127.0.0.1:8765/hello";
        var FIREBASE_SCRIPTS = {
            APP: "https://www.paypalobjects.com/checkout/js/lib/firebase-app.js",
            AUTH: "https://www.paypalobjects.com/checkout/js/lib/firebase-auth.js",
            DATABASE: "https://www.paypalobjects.com/checkout/js/lib/firebase-database.js"
        };
        var ENABLE_PAYMENT_API = !1;
    },
    "./src/constants.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "SMART_PAYMENT_BUTTONS", (function() {
            return SMART_PAYMENT_BUTTONS;
        }));
        __webpack_require__.d(__webpack_exports__, "BUYER_INTENT", (function() {
            return BUYER_INTENT;
        }));
        __webpack_require__.d(__webpack_exports__, "HEADERS", (function() {
            return HEADERS;
        }));
        __webpack_require__.d(__webpack_exports__, "DATA_ATTRIBUTES", (function() {
            return DATA_ATTRIBUTES;
        }));
        __webpack_require__.d(__webpack_exports__, "CLASS", (function() {
            return CLASS;
        }));
        __webpack_require__.d(__webpack_exports__, "PREFER", (function() {
            return PREFER;
        }));
        __webpack_require__.d(__webpack_exports__, "ORDER_API_ERROR", (function() {
            return ORDER_API_ERROR;
        }));
        __webpack_require__.d(__webpack_exports__, "CONTEXT", (function() {
            return CONTEXT;
        }));
        __webpack_require__.d(__webpack_exports__, "TARGET_ELEMENT", (function() {
            return TARGET_ELEMENT;
        }));
        __webpack_require__.d(__webpack_exports__, "INTEGRATION_ARTIFACT", (function() {
            return INTEGRATION_ARTIFACT;
        }));
        __webpack_require__.d(__webpack_exports__, "USER_EXPERIENCE_FLOW", (function() {
            return USER_EXPERIENCE_FLOW;
        }));
        __webpack_require__.d(__webpack_exports__, "PRODUCT_FLOW", (function() {
            return PRODUCT_FLOW;
        }));
        __webpack_require__.d(__webpack_exports__, "FPTI_CONTEXT_TYPE", (function() {
            return FPTI_CONTEXT_TYPE;
        }));
        __webpack_require__.d(__webpack_exports__, "FPTI_STATE", (function() {
            return FPTI_STATE;
        }));
        __webpack_require__.d(__webpack_exports__, "FPTI_TRANSITION", (function() {
            return FPTI_TRANSITION;
        }));
        __webpack_require__.d(__webpack_exports__, "FPTI_MENU_OPTION", (function() {
            return FPTI_MENU_OPTION;
        }));
        __webpack_require__.d(__webpack_exports__, "FPTI_BUTTON_TYPE", (function() {
            return FPTI_BUTTON_TYPE;
        }));
        __webpack_require__.d(__webpack_exports__, "FPTI_CUSTOM_KEY", (function() {
            return FPTI_CUSTOM_KEY;
        }));
        __webpack_require__.d(__webpack_exports__, "FPTI_BUTTON_KEY", (function() {
            return FPTI_BUTTON_KEY;
        }));
        __webpack_require__.d(__webpack_exports__, "FTPI_WALLET_KEY", (function() {
            return FTPI_WALLET_KEY;
        }));
        __webpack_require__.d(__webpack_exports__, "USER_ACTION", (function() {
            return USER_ACTION;
        }));
        __webpack_require__.d(__webpack_exports__, "UPGRADE_LSAT_RAMP", (function() {
            return UPGRADE_LSAT_RAMP;
        }));
        __webpack_require__.d(__webpack_exports__, "FRAME_NAME", (function() {
            return FRAME_NAME;
        }));
        __webpack_require__.d(__webpack_exports__, "VENMO_BLUE", (function() {
            return VENMO_BLUE;
        }));
        __webpack_require__.d(__webpack_exports__, "QRCODE_STATE", (function() {
            return QRCODE_STATE;
        }));
        __webpack_require__.d(__webpack_exports__, "ITEM_CATEGORY", (function() {
            return ITEM_CATEGORY;
        }));
        __webpack_require__.d(__webpack_exports__, "BUTTON_LABEL", (function() {
            return BUTTON_LABEL;
        }));
        __webpack_require__.d(__webpack_exports__, "STATUS_CODES", (function() {
            return STATUS_CODES;
        }));
        __webpack_require__.d(__webpack_exports__, "SERVICE_WORKER", (function() {
            return SERVICE_WORKER;
        }));
        __webpack_require__.d(__webpack_exports__, "PAYMENT_FLOWS", (function() {
            return PAYMENT_FLOWS;
        }));
        __webpack_require__.d(__webpack_exports__, "ORDER_CREATED_BY", (function() {
            return ORDER_CREATED_BY;
        }));
        var SMART_PAYMENT_BUTTONS = "smart-payment-buttons";
        var BUYER_INTENT = {
            PAY: "pay",
            PAY_WITH_DIFFERENT_ACCOUNT: "pay_with_different_account",
            PAY_WITH_DIFFERENT_FUNDING_SHIPPING: "pay_with_different_funding_shipping"
        };
        var HEADERS = {
            AUTHORIZATION: "authorization",
            CONTENT_TYPE: "content-type",
            PREFER: "prefer",
            ACCESS_TOKEN: "x-paypal-internal-euat",
            CSRF_TOKEN: "x-csrf-jwt",
            SOURCE: "x-source",
            REQUESTED_BY: "x-requested-by",
            APP_NAME: "x-app-name",
            APP_VERSION: "x-app-version",
            CLIENT_CONTEXT: "paypal-client-context",
            PARTNER_ATTRIBUTION_ID: "paypal-partner-attribution-id",
            CLIENT_METADATA_ID: "paypal-client-metadata-id",
            PAYPAL_DEBUG_ID: "paypal-debug-id",
            PAYPAL_REQUEST_ID: "paypal-request-id",
            DISABLE_SET_COOKIE: "disable-set-cookie"
        };
        var DATA_ATTRIBUTES = {
            FUNDING_SOURCE: "data-funding-source",
            CARD: "data-card",
            PAYMENT_METHOD_ID: "data-payment-method-id",
            INSTRUMENT_ID: "data-instrument-id",
            INSTRUMENT_TYPE: "data-instrument-type",
            SECONDARY_INSTRUMENT_TYPE: "data-secondary-instrument-type",
            MENU: "data-menu",
            NONCE: "data-nonce",
            RENDER_VERSION: "data-render-version",
            CLIENT_VERSION: "data-client-version",
            PAY_NOW: "data-pay-now",
            RESPONSE_START_TIME: "data-response-start-time"
        };
        var CLASS = {
            LOADING: "paypal-button-loading",
            CLICKED: "paypal-button-clicked",
            BUTTON: "paypal-button"
        };
        var PREFER = {
            REPRESENTATION: "return=representation"
        };
        var ORDER_API_ERROR = {
            INSTRUMENT_DECLINED: "INSTRUMENT_DECLINED",
            PAYER_ACTION_REQUIRED: "PAYER_ACTION_REQUIRED",
            DUPLICATE_INVOICE_ID: "DUPLICATE_INVOICE_ID",
            INVALID_RESOURCE_ID: "INVALID_RESOURCE_ID"
        };
        var CONTEXT = {
            IFRAME: "iframe",
            POPUP: "popup"
        };
        var TARGET_ELEMENT = {
            BODY: "body"
        };
        var INTEGRATION_ARTIFACT = {
            PAYPAL_JS_SDK: "PAYPAL_JS_SDK"
        };
        var USER_EXPERIENCE_FLOW = {
            INCONTEXT: "INCONTEXT",
            INLINE: "INLINE"
        };
        var PRODUCT_FLOW = {
            SMART_PAYMENT_BUTTONS: "SMART_PAYMENT_BUTTONS"
        };
        var FPTI_CONTEXT_TYPE = {
            BUTTON_SESSION_ID: "button_session_id",
            WALLET_SESSION_ID: "wallet_session_id",
            ORDER_ID: "EC-Token",
            PAYMENT_ID: "Pay-ID",
            VAULT_SETUP_TOKEN: "vault_setup_token"
        };
        var FPTI_STATE = {
            BUTTON: "smart_button",
            CARD: "card_field",
            WALLET: "smart_wallet",
            PXP: "PXP_CHECK",
            ELIGIBILITY_CHECK: "eligibility_check"
        };
        var FPTI_TRANSITION = {
            BUTTON_LOAD: "process_button_load",
            BUTTON_CLICK: "process_button_click",
            PXP: "process_pxp_check",
            WALLET_LOAD: "process_wallet_load",
            MENU_CLICK: "process_menu_click",
            CLICK_CHOOSE_FUNDING: "process_click_pay_with_different_payment_method",
            CLICK_CHOOSE_ACCOUNT: "process_click_pay_with_different_account",
            CLICK_UNLINK_ACCOUNT: "process_click_unlink_account",
            INSTALLMENTS_ELIGIBLE: "installments_eligible",
            INSTALLMENTS_INELIGIBLE: "installments_ineligible",
            CREATE_ORDER: "process_create_order",
            CONFIRM_ORDER: "process_confirm_order",
            RECEIVE_ORDER: "process_receive_order",
            RECEIVE_VAULT_SETUP_TOKEN: "process_receive_vault_setup_token",
            CREATE_PAYMENT: "process_create_payment",
            CAPTURE_AUTHORIZATION: "process_capture_authorization",
            CHECKOUT_SHIPPING_CHANGE: "process_checkout_shipping_change",
            CHECKOUT_SHIPPING_ADDRESS_CHANGE: "process_checkout_shipping_address_change",
            CHECKOUT_SHIPPING_OPTIONS_CHANGE: "process_checkout_shipping_options_change",
            CHECKOUT_APPROVE: "process_checkout_approve",
            CHECKOUT_COMPLETE: "process_checkout_complete",
            CHECKOUT_CANCEL: "process_checkout_cancel",
            CHECKOUT_ERROR: "process_checkout_error",
            TOKENIZE_APPROVE: "process_tokenize_approve",
            CONNECT_REDIRECT: "process_connect_redirect",
            FIREBASE_CONNECTION_OPENED: "firebase_connection_opened",
            FIREBASE_CONNECTION_ERRORED: "firebase_connection_errored",
            APPLEPAY_EVENT: "applepay_event",
            APPLEPAY_FLOW_ERROR: "applepay_flow_error",
            APPLEPAY_ON_CLICK_INVALID: "applepay_onclick_invalid",
            APPLEPAY_MERCHANT_VALIDATION_COMPLETION_ERROR: "applepay_merchant_validation_completion_error",
            APPLEPAY_MERCHANT_VALIDATION_ERROR: "applepay_merchant_validation_error",
            APPLEPAY_CREATE_ORDER_ERROR: "applepay_create_order_error",
            APPLEPAY_GET_DETAILS_ERROR: "applepay_get_details_error",
            APPLEPAY_PAYMENT_ERROR: "applepay_payment_error",
            APPLEPAY_CONFIG_ERROR: "applepay_config_error",
            NATIVE_DETECT_POSSIBLE_APP_SWITCH: "native_detect_possible_app_switch",
            NATIVE_DETECT_APP_SWITCH: "native_detect_app_switch",
            NATIVE_DETECT_WEB_SWITCH: "native_detect_web_switch",
            NATIVE_APP_SWITCH_ACK: "native_app_switch_ack",
            NATIVE_ERROR: "native_app_switch_ack",
            NATIVE_APP_INSTALLED: "native_app_installed",
            NATIVE_APP_SWITCH_INELIGIBLE: "app_switch_ineligible",
            NATIVE_ATTEMPT_APP_SWITCH: "app_switch_attempted",
            NATIVE_ATTEMPT_APP_SWITCH_ERRORED: "app_switch_attempted_errored",
            NATIVE_CLOSING_POPUP: "native_closing_popup",
            NATIVE_POPUP_CLOSED: "popup_closed",
            NATIVE_POPUP_HASHCHANGE: "popup_hashchange",
            NATIVE_POPUP_NO_OPENER: "popup_no_opener",
            NATIVE_POPUP_ANDROID_APP_ERROR: "native_popup_android_app_installed_error",
            NATIVE_POPUP_FALLBACK: "popup_fallback",
            NATIVE_FALLBACK_RETRY_VENMO_APP_SWITCH: "native_fallback_retry_venmo_app_switch",
            NATIVE_POPUP_SHOWN: "popup_shown",
            NATIVE_ON_APPROVE: "native_onapprove",
            NATIVE_ON_APPROVE_ERROR: "native_onapprove_error",
            NATIVE_ON_CANCEL: "native_oncancel",
            NATIVE_ON_CLICK_INVALID: "native_onclick_invalid",
            NATIVE_ON_COMPLETE: "native_oncomplete",
            NATIVE_ON_ERROR: "native_onerror",
            NATIVE_ON_SHIPPING_CHANGE: "native_onshippingchange",
            NATIVE_ON_FALLBACK: "native_onfallback",
            NATIVE_POPUP_INIT: "native_popup_init",
            NATIVE_POPUP_UNLOAD: "native_popup_unload",
            NATIVE_POPUP_BEFORE_UNLOAD: "native_popup_beforeunload",
            NATIVE_POPUP_PAGEHIDE: "native_popup_pagehide",
            NATIVE_POPUP_OPENER_DETECT_CLOSE: "native_popup_opener_detect_close",
            NATIVE_OPT_OUT: "native_opt_out",
            NATIVE_FALLBACK: "native_fallback",
            NATIVE_FALLBACK_VENMO: "native_fallback_venmo",
            NATIVE_VENMO_WEB: "native_venmo_web",
            NATIVE_VENMO_WEB_REDIRECT: "native_venmo_web_redirect",
            QR_LOAD: "qr_load",
            QR_SHOWN: "qr_shown",
            QR_CLOSING: "qr_closing",
            QR_SURVEY: "desktop_exit_survey_selection_submitted",
            QR_PREPARE_PAY: "qr_prepare_pay",
            QR_PROCESS_PAY_WITH: "qr_process_pay_with",
            HONEY_IDENTIFY: "honey_identify",
            CALL_REST_API: "call_rest_api",
            ORDER_VALIDATE: "process_order_validate"
        };
        var FPTI_MENU_OPTION = {
            CHOOSE_FUNDING: "pay_with_different_payment_method",
            CHOOSE_ACCOUNT: "pay_with_different_account",
            UNLINK_ACCOUNT: "unlink_account"
        };
        var FPTI_BUTTON_TYPE = {
            IFRAME: "iframe"
        };
        var FPTI_CUSTOM_KEY = {
            ERR_DESC: "int_error_desc",
            HONEY_DEVICE_ID: "honey_device_id",
            HONEY_SESSION_ID: "honey_session_id",
            INTEGRATION_ISSUE: "integration_issue",
            INTEGRATION_WHITELIST: "whitelist",
            INFO_MSG: "info_msg",
            PMT_TOKEN: "pmt_token",
            TRANSITION_TYPE: "transition_type",
            TRANSITION_REASON: "transition_reason",
            SHIPPING_CALLBACK_PASSED: "shipping_callback_passed",
            SHIPPING_CALLBACK_INVOKED: "shipping_callback_invoked",
            DESKTOP_EXIT_SURVEY_REASON: "desktop_exit_survey_reason",
            ORDER_CREATED_BY: "order_created_by"
        };
        var FPTI_BUTTON_KEY = {
            BUTTON_LAYOUT: "button_layout",
            BUTTON_COLOR: "button_color",
            BUTTON_SIZE: "button_size",
            BUTTON_SHAPE: "button_shape",
            BUTTON_LABEL: "button_label",
            BUTTON_WIDTH: "button_width",
            BUTTON_TYPE: "button_type",
            BUTTON_TAGLINE_ENABLED: "button_tagline_enabled",
            BUTTON_CORRELATION_ID: "button_correlation_id"
        };
        var FTPI_WALLET_KEY = {
            WALLET_SESSION_UID: "wallet_session_id",
            WALLET_VERSION: "wallet_version"
        };
        var USER_ACTION = {
            COMMIT: "commit",
            CONTINUE: "continue"
        };
        var UPGRADE_LSAT_RAMP = {
            EXP_NAME: "UPGRADE_LSAT_EXPERIMENT",
            RAMP: 100
        };
        var FRAME_NAME = {
            SMART_FIELDS: "smart-fields",
            CARD_FIELD: "card-field",
            CARD_NUMBER_FIELD: "card-number-field",
            CARD_CVV_FIELD: "card-cvv-field",
            CARD_EXPIRY_FIELD: "card-expiry-field",
            CARD_NAME_FIELD: "card-name-field",
            CARD_POSTAL_FIELD: "card-postal-field"
        };
        var VENMO_BLUE = "#3D93CE";
        var QRCODE_STATE = {
            ERROR: "qr_error",
            SCANNED: "qr_scanned",
            AUTHORIZED: "qr_authorized",
            DEFAULT: "qr_default"
        };
        var ITEM_CATEGORY = {
            DIGITAL: "DIGITAL",
            DONATION: "DONATION",
            PHYSICAL: "PHYSICAL"
        };
        var BUTTON_LABEL = {
            DONATE: "donate"
        };
        var STATUS_CODES = {
            TOO_MANY_REQUESTS: 429
        };
        var SERVICE_WORKER = {
            SERVICE_WORKER_URL: "https://www.paypal.com/checkout-sw",
            SW_SCOPE: "/webapps/hermes",
            GET_SW_LOGS_EVENT_NAME: "GET_SW_LOGS",
            LOGS_CHANNEL_NAME: "logs-channel",
            GET_SW_LOGS_RESPONSE_EVENT_NAME: "GET_SW_LOGS_RESPONSE"
        };
        var PAYMENT_FLOWS = {
            WITH_PURCHASE: "with_purchase",
            VAULT_WITHOUT_PURCHASE: "vault_without_purchase"
        };
        var ORDER_CREATED_BY = {
            HONEY: "honey",
            UNKNOWN_EVENT: "unknown_event",
            BUTTON_CLICK: "button_click"
        };
    },
    "./src/lib/index.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "unresolvedPromise", (function() {
            return util.unresolvedPromise;
        }));
        __webpack_require__.d(__webpack_exports__, "promiseNoop", (function() {
            return util.promiseNoop;
        }));
        __webpack_require__.d(__webpack_exports__, "getBody", (function() {
            return util.getBody;
        }));
        __webpack_require__.d(__webpack_exports__, "sendBeacon", (function() {
            return util.sendBeacon;
        }));
        __webpack_require__.d(__webpack_exports__, "sleep", (function() {
            return util.sleep;
        }));
        __webpack_require__.d(__webpack_exports__, "redirectTop", (function() {
            return util.redirectTop;
        }));
        __webpack_require__.d(__webpack_exports__, "loadScript", (function() {
            return util.loadScript;
        }));
        __webpack_require__.d(__webpack_exports__, "promiseOne", (function() {
            return util.promiseOne;
        }));
        __webpack_require__.d(__webpack_exports__, "isServer", (function() {
            return util.isServer;
        }));
        __webpack_require__.d(__webpack_exports__, "isClient", (function() {
            return util.isClient;
        }));
        __webpack_require__.d(__webpack_exports__, "isEmailAddress", (function() {
            return util.isEmailAddress;
        }));
        __webpack_require__.d(__webpack_exports__, "createExperiment", (function() {
            return util.createExperiment;
        }));
        __webpack_require__.d(__webpack_exports__, "isIOSSafari", (function() {
            return util.isIOSSafari;
        }));
        __webpack_require__.d(__webpack_exports__, "isAndroidChrome", (function() {
            return util.isAndroidChrome;
        }));
        __webpack_require__.d(__webpack_exports__, "onCloseProxyWindow", (function() {
            return util.onCloseProxyWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "getNavigationTimeOrigin", (function() {
            return util.getNavigationTimeOrigin;
        }));
        __webpack_require__.d(__webpack_exports__, "getClientsideTimestamp", (function() {
            return util.getClientsideTimestamp;
        }));
        __webpack_require__.d(__webpack_exports__, "getLogger", (function() {
            return logger.getLogger;
        }));
        __webpack_require__.d(__webpack_exports__, "sendCountMetric", (function() {
            return logger.sendCountMetric;
        }));
        __webpack_require__.d(__webpack_exports__, "sendGaugeMetric", (function() {
            return logger.sendGaugeMetric;
        }));
        __webpack_require__.d(__webpack_exports__, "setupLogger", (function() {
            return logger.setupLogger;
        }));
        __webpack_require__.d(__webpack_exports__, "getNonce", (function() {
            return getNonce;
        }));
        __webpack_require__.d(__webpack_exports__, "getActiveElement", (function() {
            return getActiveElement;
        }));
        __webpack_require__.d(__webpack_exports__, "getSmartFieldsByFundingSource", (function() {
            return getSmartFieldsByFundingSource;
        }));
        __webpack_require__.d(__webpack_exports__, "getSessionID", (function() {
            return getSessionID;
        }));
        __webpack_require__.d(__webpack_exports__, "getStorageState", (function() {
            return getStorageState;
        }));
        __webpack_require__.d(__webpack_exports__, "getStorageID", (function() {
            return getStorageID;
        }));
        __webpack_require__.d(__webpack_exports__, "isStorageStateFresh", (function() {
            return isStorageStateFresh;
        }));
        __webpack_require__.d(__webpack_exports__, "getSessionState", (function() {
            return getSessionState;
        }));
        __webpack_require__.d(__webpack_exports__, "getStickinessID", (function() {
            return getStickinessID;
        }));
        __webpack_require__.d(__webpack_exports__, "getBuyerAccessToken", (function() {
            return getBuyerAccessToken;
        }));
        __webpack_require__.d(__webpack_exports__, "setBuyerAccessToken", (function() {
            return setBuyerAccessToken;
        }));
        __webpack_require__.d(__webpack_exports__, "getPayPal", (function() {
            return getPayPal;
        }));
        __webpack_require__.d(__webpack_exports__, "getPostRobot", (function() {
            return getPostRobot;
        }));
        __webpack_require__.d(__webpack_exports__, "toProxyWindow", (function() {
            return toProxyWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "postRobotOnceProxy", (function() {
            return postRobotOnceProxy;
        }));
        __webpack_require__.d(__webpack_exports__, "getSDKVersion", (function() {
            return getSDKVersion;
        }));
        __webpack_require__.d(__webpack_exports__, "prepareLatencyInstrumentationPayload", (function() {
            return prepareLatencyInstrumentationPayload;
        }));
        __webpack_require__.d(__webpack_exports__, "getSanitizedUrl", (function() {
            return getSanitizedUrl;
        }));
        __webpack_require__.d(__webpack_exports__, "registerServiceWorker", (function() {
            return registerServiceWorker;
        }));
        __webpack_require__.d(__webpack_exports__, "unregisterServiceWorker", (function() {
            return unregisterServiceWorker;
        }));
        var util = __webpack_require__("./src/lib/util.js");
        var logger = __webpack_require__("./src/lib/logger.js");
        var constants = __webpack_require__("./src/constants.js");
        function getNonce() {
            var nonce = "";
            document.body && (nonce = document.body.getAttribute("" + constants.DATA_ATTRIBUTES.NONCE) || "");
            return nonce;
        }
        function getActiveElement() {
            return document.activeElement;
        }
        var src = __webpack_require__("./node_modules/@krakenjs/cross-domain-utils/src/index.js");
        function getSmartFieldsByFundingSource(fundingSource) {
            try {
                for (var _i2 = 0, _getAllFramesInWindow2 = Object(src.getAllFramesInWindow)(window); _i2 < _getAllFramesInWindow2.length; _i2++) {
                    var win = _getAllFramesInWindow2[_i2];
                    if (Object(src.isSameDomain)(win) && win.exports && win.exports.name === constants.FRAME_NAME.SMART_FIELDS && win.exports.fundingSource === fundingSource) return win.exports;
                }
            } catch (err) {}
        }
        var belter_src = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        function getSDKStorage() {
            return Object(belter_src.getStorage)({
                name: "paypal",
                lifetime: 36e5
            });
        }
        function getSessionID() {
            return getSDKStorage().getSessionID();
        }
        function getStorageState(handler) {
            return getSDKStorage().getState(handler);
        }
        function getStorageID() {
            return getSDKStorage().getID();
        }
        function isStorageStateFresh() {
            return getSDKStorage().isStateFresh();
        }
        function getSessionState(handler) {
            return getSDKStorage().getSessionState(handler);
        }
        function getStickinessID() {
            return (Object(belter_src.hashStr)((_window$navigator = window.navigator, userAgent = _window$navigator.userAgent, 
            language = _window$navigator.language, languages = _window$navigator.languages, 
            platform = _window$navigator.platform, hardwareConcurrency = _window$navigator.hardwareConcurrency, 
            deviceMemory = _window$navigator.deviceMemory, plugins = Object.entries(window.navigator.plugins).map((function(_ref) {
                return _ref[1].name;
            })), _window$screen = window.screen, colorDepth = _window$screen.colorDepth, availWidth = _window$screen.availWidth, 
            availHeight = _window$screen.availHeight, timezoneOffset = (new Date).getTimezoneOffset(), 
            timezone = Intl.DateTimeFormat().resolvedOptions().timeZone, touchSupport = "ontouchstart" in window, 
            canvas = function() {
                try {
                    var _canvas = document.createElement("canvas");
                    var ctx = _canvas.getContext("2d");
                    ctx.textBaseline = "top";
                    ctx.font = "14px 'Arial'";
                    ctx.textBaseline = "alphabetic";
                    ctx.fillStyle = "#f60";
                    ctx.fillRect(125, 1, 62, 20);
                    ctx.fillStyle = "#069";
                    ctx.fillText("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~1!2@3#4$5%6^7&8*9(0)-_=+[{]}|;:',<.>/?", 2, 15);
                    ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
                    ctx.fillText("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~1!2@3#4$5%6^7&8*9(0)-_=+[{]}|;:',<.>/?", 4, 17);
                    return _canvas.toDataURL();
                } catch (error) {
                    return error;
                }
            }(), function(key) {
                var remainder = 3 & key.length;
                var bytes = key.length - remainder;
                var c1 = 3432918353;
                var c2 = 461845907;
                var h1, h1b, k1;
                for (var _i = 0; _i < bytes; _i++) {
                    k1 = 255 & key.charCodeAt(_i) | (255 & key.charCodeAt(++_i)) << 8 | (255 & key.charCodeAt(++_i)) << 16 | (255 & key.charCodeAt(++_i)) << 24;
                    ++_i;
                    h1 = 27492 + (65535 & (h1b = 5 * (65535 & (h1 = (h1 ^= k1 = (65535 & (k1 = (k1 = (65535 & k1) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295) << 15 | k1 >>> 17)) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295) << 13 | h1 >>> 19)) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (h1b >>> 16) & 65535) << 16);
                }
                var i = bytes - 1;
                k1 = 0;
                switch (remainder) {
                  case 3:
                    k1 ^= (255 & key.charCodeAt(i + 2)) << 16;
                    break;

                  case 2:
                    k1 ^= (255 & key.charCodeAt(i + 1)) << 8;
                    break;

                  case 1:
                    k1 ^= 255 & key.charCodeAt(i);
                }
                h1 ^= k1 = (65535 & (k1 = (k1 = (65535 & k1) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295) << 15 | k1 >>> 17)) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
                h1 ^= key.length;
                h1 = 2246822507 * (65535 & (h1 ^= h1 >>> 16)) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
                h1 = 3266489909 * (65535 & (h1 ^= h1 >>> 13)) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
                return (h1 ^= h1 >>> 16) >>> 0;
            }(JSON.stringify({
                userAgent: userAgent,
                language: language,
                languages: languages,
                platform: platform,
                hardwareConcurrency: hardwareConcurrency,
                deviceMemory: deviceMemory,
                plugins: plugins,
                colorDepth: colorDepth,
                availWidth: availWidth,
                availHeight: availHeight,
                timezoneOffset: timezoneOffset,
                timezone: timezone,
                touchSupport: touchSupport,
                canvas: canvas
            }))).toString()) % 100).toString();
            var _window$navigator, userAgent, language, languages, platform, hardwareConcurrency, deviceMemory, plugins, _window$screen, colorDepth, availWidth, availHeight, timezoneOffset, timezone, touchSupport, canvas;
        }
        var buyerAccessToken;
        function getBuyerAccessToken() {
            return buyerAccessToken;
        }
        function setBuyerAccessToken(token) {
            buyerAccessToken = token;
        }
        function getPayPal() {
            if (!window.paypal) throw new Error("paypal not found");
            return window.paypal;
        }
        function getPostRobot() {
            var paypal = getPayPal();
            if (!paypal.postRobot) throw new Error("paypal.postRobot not found");
            return paypal.postRobot;
        }
        function toProxyWindow(win) {
            return getPostRobot().toProxyWindow(win);
        }
        function postRobotOnceProxy(event, _ref, handler) {
            var domain = _ref.domain;
            var cancelled = !1;
            var cancel = function() {
                cancelled = !0;
            };
            _ref.proxyWin.awaitWindow().then((function(win) {
                cancelled || (cancel = getPostRobot().once(event, {
                    window: win,
                    domain: domain
                }, (function(_ref2) {
                    return handler({
                        data: _ref2.data
                    });
                })).cancel);
            }));
            return {
                cancel: cancel
            };
        }
        function getSDKVersion() {
            return getPayPal().version;
        }
        function prepareLatencyInstrumentationPayload(responseStartTime, responseEndTime) {
            return {
                comp: {
                    "second-render-response": {
                        start: responseStartTime,
                        tt: responseEndTime - responseStartTime
                    },
                    "second-render-body": {
                        start: responseEndTime,
                        tt: Date.now() - responseEndTime
                    }
                }
            };
        }
        var sdk_constants_src = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var SERVICE_WORKER_URL = constants.SERVICE_WORKER.SERVICE_WORKER_URL, SW_SCOPE = constants.SERVICE_WORKER.SW_SCOPE, GET_SW_LOGS_EVENT_NAME = constants.SERVICE_WORKER.GET_SW_LOGS_EVENT_NAME, LOGS_CHANNEL_NAME = constants.SERVICE_WORKER.LOGS_CHANNEL_NAME, GET_SW_LOGS_RESPONSE_EVENT_NAME = constants.SERVICE_WORKER.GET_SW_LOGS_RESPONSE_EVENT_NAME;
        var LOG_PREFIX = "SERVICE_WORKER_";
        var broadcastChannel = {};
        var requestSwLogs = function() {
            broadcastChannel.postMessage({
                type: GET_SW_LOGS_EVENT_NAME
            });
        };
        var register_service_worker_unRegisterButtonHandlers = function() {
            var paypalButtons = document.getElementsByClassName(constants.CLASS.BUTTON);
            for (var i = 0; i < paypalButtons.length; i++) paypalButtons[i].removeEventListener("click", requestSwLogs);
        };
        function getSanitizedUrl(releaseHash, serviceWorker) {
            var clearedHash = releaseHash.replace(/[^0-9a-z]/gi, "");
            return new URL(SERVICE_WORKER_URL + "/" + serviceWorker + "?releaseHash=" + clearedHash).toString();
        }
        function registerServiceWorker(_ref) {
            var _getLogger$track;
            var dumbledoreCurrentReleaseHash = _ref.dumbledoreCurrentReleaseHash, dumbledoreServiceWorker = _ref.dumbledoreServiceWorker;
            if ("serviceWorker" in navigator != 0 && "BroadcastChannel" in window != 0) {
                Object(logger.getLogger)().track(((_getLogger$track = {})[sdk_constants_src.FPTI_KEY.EVENT_NAME] = LOG_PREFIX + "ELIGIBILE", 
                _getLogger$track));
                if (dumbledoreCurrentReleaseHash) if (dumbledoreServiceWorker) try {
                    !function() {
                        var paypalButtons = document.getElementsByClassName(constants.CLASS.BUTTON);
                        for (var i = 0; i < paypalButtons.length; i++) paypalButtons[i].addEventListener("click", requestSwLogs);
                    }();
                    (broadcastChannel = new BroadcastChannel(LOGS_CHANNEL_NAME)).addEventListener("message", (function(event) {
                        var _event$data = event.data, _event$data$payload = _event$data.payload, payload = void 0 === _event$data$payload ? [] : _event$data$payload;
                        payload && _event$data.eventName === GET_SW_LOGS_RESPONSE_EVENT_NAME && Object(logger.getLogger)().info(LOG_PREFIX + "LOGS", {
                            logs: JSON.stringify(payload)
                        });
                    }));
                    !function(releaseHash, serviceWorker) {
                        var swUrl = getSanitizedUrl(releaseHash, serviceWorker);
                        Object(logger.getLogger)().info(LOG_PREFIX + "REGISTER_START", {
                            url: swUrl
                        });
                        swUrl ? function(swUrl) {
                            var _navigator$serviceWor;
                            null == (_navigator$serviceWor = navigator.serviceWorker) || _navigator$serviceWor.register(swUrl, {
                                scope: SW_SCOPE
                            }).then((function(registration) {
                                Object(logger.getLogger)().info(LOG_PREFIX + "REGISTERED");
                                registration.addEventListener("updatefound", (function() {
                                    var installingWorker = registration.installing;
                                    installingWorker && installingWorker.addEventListener("statechange", (function() {
                                        "activated" === installingWorker.state && requestSwLogs();
                                        Object(logger.getLogger)().info(LOG_PREFIX + "REGISTERING: " + installingWorker.state);
                                    }));
                                }));
                            })).catch((function(err) {
                                Object(logger.getLogger)().error(LOG_PREFIX + "ERROR_REGISTERING", {
                                    err: Object(belter_src.stringifyError)(err)
                                });
                                register_service_worker_unRegisterButtonHandlers();
                            }));
                        }(swUrl) : Object(logger.getLogger)().error(LOG_PREFIX + "ERROR_DURING_SWURL_GENERATION");
                    }(dumbledoreCurrentReleaseHash, dumbledoreServiceWorker);
                } catch (err) {
                    Object(logger.getLogger)().error(LOG_PREFIX + "ERROR_DURING_INITIALIZATION", {
                        err: Object(belter_src.stringifyError)(err)
                    });
                } else Object(logger.getLogger)().error(LOG_PREFIX + "SERVICE_WORKER_URL_NOT_PROVIDED", {
                    serviceWorker: dumbledoreServiceWorker
                }); else Object(logger.getLogger)().error(LOG_PREFIX + "RELEASE_HASH_NOT_PROVIDED", {
                    releaseHash: dumbledoreCurrentReleaseHash
                });
            } else {
                var _getLogger$info$track;
                Object(logger.getLogger)().info(LOG_PREFIX + "NOT_SUPPORTED", {
                    serviceWorker: Boolean("serviceWorker" in navigator),
                    BroadcastChannel: Boolean("BroadcastChannel" in window)
                }).track(((_getLogger$info$track = {})[sdk_constants_src.FPTI_KEY.EVENT_NAME] = LOG_PREFIX + "NOT_ELIGIBILE", 
                _getLogger$info$track));
            }
        }
        function unregisterServiceWorker() {
            if ("serviceWorker" in navigator) {
                var _navigator$serviceWor2;
                null == (_navigator$serviceWor2 = navigator.serviceWorker) || _navigator$serviceWor2.ready.then((function(registration) {
                    Object(logger.getLogger)().info(LOG_PREFIX + "UNREGISTER");
                    registration.unregister();
                    register_service_worker_unRegisterButtonHandlers();
                }));
            }
        }
    },
    "./src/lib/logger.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "getLogger", (function() {
            return getLogger;
        }));
        __webpack_require__.d(__webpack_exports__, "sendCountMetric", (function() {
            return sendCountMetric;
        }));
        __webpack_require__.d(__webpack_exports__, "sendGaugeMetric", (function() {
            return sendGaugeMetric;
        }));
        __webpack_require__.d(__webpack_exports__, "setupLogger", (function() {
            return setupLogger;
        }));
        var _krakenjs_beaver_logger_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@krakenjs/beaver-logger/src/index.js");
        var _krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        var _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/config.js");
        function getLogger() {
            var loggerUrl = window && "object" == typeof window.xprops && window.xprops.disableSetCookie ? _config__WEBPACK_IMPORTED_MODULE_4__.LOGGER_URL + "?disableSetCookie=true" : _config__WEBPACK_IMPORTED_MODULE_4__.LOGGER_URL;
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__.inlineMemoize)(getLogger, (function() {
                return Object(_krakenjs_beaver_logger_src__WEBPACK_IMPORTED_MODULE_0__.Logger)({
                    url: loggerUrl,
                    enableSendBeacon: !0
                });
            }));
        }
        var sendCountMetric = function(_ref) {
            var dimensions = _ref.dimensions, _ref$event = _ref.event, event = void 0 === _ref$event ? "unused" : _ref$event, name = _ref.name, _ref$value = _ref.value, value = void 0 === _ref$value ? 1 : _ref$value;
            return getLogger().metric({
                dimensions: dimensions,
                metricEventName: event,
                metricNamespace: name,
                metricValue: value,
                metricType: "counter"
            });
        };
        var sendGaugeMetric = function(_ref2) {
            var dimensions = _ref2.dimensions, _ref2$event = _ref2.event, event = void 0 === _ref2$event ? "unused" : _ref2$event, name = _ref2.name, value = _ref2.value;
            return getLogger().metric({
                dimensions: dimensions,
                metricEventName: event,
                metricNamespace: name,
                metricValue: value,
                metricType: "gauge"
            });
        };
        function setupLogger(_ref3) {
            var env = _ref3.env, sessionID = _ref3.sessionID, clientID = _ref3.clientID, sdkCorrelationID = _ref3.sdkCorrelationID, buyerCountry = _ref3.buyerCountry, locale = _ref3.locale, _ref3$sdkVersion = _ref3.sdkVersion, sdkVersion = void 0 === _ref3$sdkVersion ? window.paypal.version : _ref3$sdkVersion;
            var logger = getLogger();
            logger.addPayloadBuilder((function() {
                return {
                    referer: window.location.host,
                    sdkCorrelationID: sdkCorrelationID,
                    sessionID: sessionID,
                    clientID: clientID,
                    env: env
                };
            }));
            logger.addTrackingBuilder((function() {
                var _ref4;
                return (_ref4 = {})[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.FEED] = _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_FEED.PAYMENTS_SDK, 
                _ref4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.DATA_SOURCE] = _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_DATA_SOURCE.PAYMENTS_SDK, 
                _ref4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CLIENT_ID] = clientID, 
                _ref4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.SESSION_UID] = sessionID, 
                _ref4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.REFERER] = window.location.host, 
                _ref4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.BUYER_COUNTRY] = buyerCountry, 
                _ref4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.LOCALE] = locale.lang + "_" + locale.country, 
                _ref4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.INTEGRATION_IDENTIFIER] = clientID, 
                _ref4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.SDK_ENVIRONMENT] = Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__.isIos)() ? _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.MOBILE_ENV.IOS : Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__.isAndroid)() ? _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.MOBILE_ENV.ANDROID : null, 
                _ref4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.SDK_NAME] = _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_SDK_NAME.PAYMENTS_SDK, 
                _ref4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.SDK_VERSION] = sdkVersion, 
                _ref4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.USER_AGENT] = window.navigator && window.navigator.userAgent, 
                _ref4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_CORRID] = sdkCorrelationID, 
                _ref4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TIMESTAMP] = Date.now().toString(), 
                _ref4;
            }));
            _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_2__.ZalgoPromise.onPossiblyUnhandledException((function(err) {
                var _logger$track;
                logger.track(((_logger$track = {})[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.ERROR_CODE] = "payments_sdk_error", 
                _logger$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.ERROR_DESC] = Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__.stringifyErrorMessage)(err), 
                _logger$track));
                logger.error("unhandled_error", {
                    err: Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__.stringifyError)(err)
                });
                sendCountMetric({
                    event: "error",
                    name: "pp.app.paypal_sdk.buttons.unhandled_exception.count",
                    dimensions: {
                        errorType: "payments_sdk_error"
                    }
                });
                logger.flush().catch(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__.noop);
            }));
        }
    },
    "./src/lib/util.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "unresolvedPromise", (function() {
            return unresolvedPromise;
        }));
        __webpack_require__.d(__webpack_exports__, "promiseNoop", (function() {
            return promiseNoop;
        }));
        __webpack_require__.d(__webpack_exports__, "getBody", (function() {
            return getBody;
        }));
        __webpack_require__.d(__webpack_exports__, "sendBeacon", (function() {
            return sendBeacon;
        }));
        __webpack_require__.d(__webpack_exports__, "sleep", (function() {
            return sleep;
        }));
        __webpack_require__.d(__webpack_exports__, "redirectTop", (function() {
            return redirectTop;
        }));
        __webpack_require__.d(__webpack_exports__, "loadScript", (function() {
            return loadScript;
        }));
        __webpack_require__.d(__webpack_exports__, "promiseOne", (function() {
            return promiseOne;
        }));
        __webpack_require__.d(__webpack_exports__, "isServer", (function() {
            return isServer;
        }));
        __webpack_require__.d(__webpack_exports__, "isClient", (function() {
            return isClient;
        }));
        __webpack_require__.d(__webpack_exports__, "isEmailAddress", (function() {
            return isEmailAddress;
        }));
        __webpack_require__.d(__webpack_exports__, "createExperiment", (function() {
            return createExperiment;
        }));
        __webpack_require__.d(__webpack_exports__, "isIOSSafari", (function() {
            return isIOSSafari;
        }));
        __webpack_require__.d(__webpack_exports__, "isAndroidChrome", (function() {
            return isAndroidChrome;
        }));
        __webpack_require__.d(__webpack_exports__, "onCloseProxyWindow", (function() {
            return onCloseProxyWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "getNavigationTimeOrigin", (function() {
            return getNavigationTimeOrigin;
        }));
        __webpack_require__.d(__webpack_exports__, "getClientsideTimestamp", (function() {
            return getClientsideTimestamp;
        }));
        var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/extends.js");
        var _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        var _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _krakenjs_cross_domain_utils_src__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@krakenjs/cross-domain-utils/src/index.js");
        var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/constants.js");
        var _logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/lib/logger.js");
        function unresolvedPromise() {
            return new _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__.ZalgoPromise(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.noop);
        }
        function promiseNoop() {
            return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__.ZalgoPromise.resolve();
        }
        function getBody() {
            var body = document.body;
            if (!body) throw new Error("Document body not found");
            return body;
        }
        function sendBeacon(url) {
            var img = document.createElement("img");
            img.src = url;
            img.style.visibility = "hidden";
            img.style.position = "absolute";
            document.body && document.body.appendChild(img);
        }
        function sleep(time) {
            return new _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__.ZalgoPromise((function(resolve) {
                setTimeout(resolve, time);
            }));
        }
        function redirectTop(url) {
            window.top.location = url;
        }
        function loadScript(url) {
            return new _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__.ZalgoPromise((function(resolve, reject) {
                var container = document.body || document.head;
                if (!container) return reject(new Error("Can not find container for script: " + url));
                var script = document.createElement("script");
                script.setAttribute("src", url);
                script.addEventListener("load", (function() {
                    return resolve(script);
                }));
                script.addEventListener("error", (function(err) {
                    return reject(err);
                }));
                container.appendChild(script);
            }));
        }
        function promiseOne(promises) {
            return new _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__.ZalgoPromise((function(resolve, reject) {
                for (var _i2 = 0; _i2 < promises.length; _i2++) promises[_i2].then(resolve, reject);
            }));
        }
        function isServer() {
            return "undefined" == typeof window;
        }
        function isClient() {
            return "undefined" != typeof window;
        }
        function isEmailAddress(str) {
            return Boolean(str.match(/^.+@.+\..+$/));
        }
        function createExperiment(name, _ref) {
            var sample = _ref.sample, _ref$sticky = _ref.sticky, sticky = void 0 === _ref$sticky || _ref$sticky;
            var logger = Object(_logger__WEBPACK_IMPORTED_MODULE_6__.getLogger)();
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.experiment)({
                name: name,
                sample: sample,
                logTreatment: function(_ref2) {
                    var _extends2;
                    var treatment = _ref2.treatment, payload = _ref2.payload;
                    var fullPayload = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)(((_extends2 = {})[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.STATE] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_STATE.PXP, 
                    _extends2[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_TRANSITION.PXP, 
                    _extends2[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.EXPERIMENT_NAME] = name, 
                    _extends2[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TREATMENT_NAME] = treatment, 
                    _extends2), payload);
                    logger.track(fullPayload);
                    logger.flush();
                },
                logCheckpoint: function(_ref3) {
                    var payload = _ref3.payload, throttle = _ref3.throttle;
                    logger.info(_ref3.treatment + "_" + _ref3.checkpoint, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, payload, {
                        throttle: throttle.toString()
                    }));
                    logger.flush();
                },
                sticky: sticky
            });
        }
        function isIOSSafari() {
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.isIos)() && Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.isSafari)();
        }
        function isAndroidChrome() {
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.isAndroid)() && Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.isChrome)();
        }
        function onCloseProxyWindow(proxyWin, callback, delay, maxtime) {
            void 0 === delay && (delay = 1e3);
            void 0 === maxtime && (maxtime = 1 / 0);
            var cancelled = !1;
            var cancel = function() {
                cancelled = !0;
            };
            proxyWin.awaitWindow().then((function(win) {
                cancelled || (cancel = Object(_krakenjs_cross_domain_utils_src__WEBPACK_IMPORTED_MODULE_4__.onCloseWindow)(win, callback, delay, maxtime).cancel);
            }));
            return {
                cancel: cancel
            };
        }
        function getNavigationTimeOrigin() {
            if (window.performance) {
                var hrSyncPoint = window.performance.now();
                var unixSyncPoint = (new Date).getTime();
                return window.performance.timeOrigin || window.performance.timing.navigationStart || unixSyncPoint - hrSyncPoint;
            }
            throw new Error("window.performance not supported");
        }
        function getClientsideTimestamp() {
            try {
                return String((new Date).getTime());
            } catch (_unused) {
                return "invalid_timestamp";
            }
        }
    },
    "./src/props/confirmOrder.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "getConfirmOrder", (function() {
            return getConfirmOrder;
        }));
        var _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        var _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/api/index.js");
        var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/constants.js");
        var _lib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/lib/index.js");
        function getConfirmOrder(_ref, _ref2) {
            var orderID = _ref.orderID, payload = _ref.payload, partnerAttributionID = _ref.partnerAttributionID;
            var facilitatorAccessToken = _ref2.facilitatorAccessToken;
            var startTime = Date.now();
            return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__.ZalgoPromise.try((function() {
                return Object(_api__WEBPACK_IMPORTED_MODULE_3__.confirmOrderAPI)(orderID, payload, {
                    facilitatorAccessToken: facilitatorAccessToken,
                    partnerAttributionID: partnerAttributionID,
                    experiments: {}
                });
            })).catch((function(err) {
                Object(_lib__WEBPACK_IMPORTED_MODULE_5__.getLogger)().error("confirm_order_error", {
                    err: Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__.stringifyError)(err)
                });
                throw err;
            })).then((function() {
                var _getLogger$track;
                var duration = Date.now() - startTime;
                Object(_lib__WEBPACK_IMPORTED_MODULE_5__.getLogger)().track((_getLogger$track = {}, 
                _getLogger$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.STATE] = _constants__WEBPACK_IMPORTED_MODULE_4__.FPTI_STATE.BUTTON, 
                _getLogger$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_4__.FPTI_TRANSITION.CONFIRM_ORDER, 
                _getLogger$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.CONTEXT_TYPE] = _constants__WEBPACK_IMPORTED_MODULE_4__.FPTI_CONTEXT_TYPE.ORDER_ID, 
                _getLogger$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.CONTEXT_ID] = orderID, 
                _getLogger$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.TOKEN] = orderID, 
                _getLogger$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.RESPONSE_DURATION] = duration.toString(), 
                _getLogger$track)).flush();
            }));
        }
    },
    "./src/props/createBillingAgreement.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "buildXCreateBillingAgreementData", (function() {
            return buildXCreateBillingAgreementData;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXCreateBillingAgreementActions", (function() {
            return buildXCreateBillingAgreementActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getCreateBillingAgreement", (function() {
            return getCreateBillingAgreement;
        }));
        __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        function buildXCreateBillingAgreementData(_ref) {
            return {
                paymentSource: _ref.paymentSource
            };
        }
        function buildXCreateBillingAgreementActions() {
            return {};
        }
        function getCreateBillingAgreement(_ref2) {
            var createBillingAgreement = _ref2.createBillingAgreement, paymentSource = _ref2.paymentSource;
            if (createBillingAgreement) return function() {
                return createBillingAgreement(buildXCreateBillingAgreementData({
                    paymentSource: paymentSource
                }), {}).then((function(billingToken) {
                    if (!billingToken || "string" != typeof billingToken) throw new Error("Expected a billing token to be passed to createBillingAgreement");
                    return billingToken;
                }));
            };
        }
    },
    "./src/props/createOrder.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "buildXCreateOrderData", (function() {
            return buildXCreateOrderData;
        }));
        __webpack_require__.d(__webpack_exports__, "buildOrderActions", (function() {
            return buildOrderActions;
        }));
        __webpack_require__.d(__webpack_exports__, "buildPaymentActions", (function() {
            return buildPaymentActions;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXCreateOrderActions", (function() {
            return buildXCreateOrderActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getCreateOrder", (function() {
            return getCreateOrder;
        }));
        var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/extends.js");
        var _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        var _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _krakenjs_cross_domain_utils_src__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@krakenjs/cross-domain-utils/src/index.js");
        var _api__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/api/index.js");
        var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/constants.js");
        var _lib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/lib/index.js");
        var _config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/config.js");
        var _api_vault__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/api/vault.js");
        function buildXCreateOrderData(_ref) {
            return {
                paymentSource: _ref.paymentSource
            };
        }
        function buildOrderActions(_ref2) {
            var facilitatorAccessToken = _ref2.facilitatorAccessToken, intent = _ref2.intent, currency = _ref2.currency, merchantID = _ref2.merchantID, partnerAttributionID = _ref2.partnerAttributionID, experiments = _ref2.experiments;
            return {
                create: function(data) {
                    var order = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, data);
                    if (order.intent && order.intent.toLowerCase() !== intent) throw new Error("Unexpected intent: " + order.intent + " passed to order.create. Please ensure you are passing /sdk/js?" + _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.SDK_QUERY_KEYS.INTENT + "=" + order.intent.toLowerCase() + " in the paypal script tag.");
                    (order = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, order, {
                        intent: intent.toUpperCase()
                    })).purchase_units = order.purchase_units.map((function(unit) {
                        if (unit.amount.currency_code && unit.amount.currency_code !== currency) throw new Error("Unexpected currency: " + unit.amount.currency_code + " passed to order.create. Please ensure you are passing /sdk/js?" + _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.SDK_QUERY_KEYS.CURRENCY + "=" + unit.amount.currency_code + " in the paypal script tag.");
                        var payee = unit.payee;
                        if (merchantID && 1 === merchantID.length && merchantID[0]) {
                            var payeeID = merchantID[0];
                            payee = Object(_lib__WEBPACK_IMPORTED_MODULE_7__.isEmailAddress)(payeeID) ? Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, payee, {
                                email_address: payeeID
                            }) : Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, payee, {
                                merchant_id: payeeID
                            });
                        }
                        return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, unit, {
                            payee: payee,
                            amount: Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, unit.amount, {
                                currency_code: currency
                            })
                        });
                    }));
                    order.application_context = order.application_context || {};
                    return Object(_api__WEBPACK_IMPORTED_MODULE_5__.createOrderID)(order, {
                        facilitatorAccessToken: facilitatorAccessToken,
                        partnerAttributionID: partnerAttributionID,
                        forceRestAPI: !1,
                        experiments: experiments
                    });
                }
            };
        }
        function buildPaymentActions(_ref3) {
            var facilitatorAccessToken = _ref3.facilitatorAccessToken, intent = _ref3.intent, currency = _ref3.currency, merchantID = _ref3.merchantID, partnerAttributionID = _ref3.partnerAttributionID;
            return {
                create: function(data) {
                    var payment = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, data);
                    var expectedIntent = intent === _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.INTENT.CAPTURE ? "sale" : intent;
                    if (payment.intent && payment.intent !== expectedIntent) throw new Error("Unexpected intent: " + payment.intent + " passed to order.create. Expected " + expectedIntent);
                    (payment = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, payment, {
                        intent: expectedIntent
                    })).transactions = payment.transactions.map((function(transaction) {
                        if (transaction.amount.currency && transaction.amount.currency !== currency) throw new Error("Unexpected currency: " + transaction.amount.currency + " passed to order.create. Please ensure you are passing /sdk/js?" + _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.SDK_QUERY_KEYS.CURRENCY + "=" + transaction.amount.currency + " in the paypal script tag.");
                        var payee = transaction.payee;
                        if (merchantID && 1 === merchantID.length && merchantID[0]) {
                            var payeeID = merchantID[0];
                            payee = Object(_lib__WEBPACK_IMPORTED_MODULE_7__.isEmailAddress)(payeeID) ? Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, payee, {
                                email_address: payeeID
                            }) : Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, payee, {
                                merchant_id: payeeID
                            });
                        }
                        return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, transaction, {
                            payee: payee,
                            amount: Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, transaction.amount, {
                                currency: currency
                            })
                        });
                    }));
                    payment.redirect_urls = payment.redirect_urls || {};
                    payment.redirect_urls.return_url = payment.redirect_urls.return_url || Object(_krakenjs_cross_domain_utils_src__WEBPACK_IMPORTED_MODULE_4__.getDomain)() + "/checkoutnow/error";
                    payment.redirect_urls.cancel_url = payment.redirect_urls.cancel_url || Object(_krakenjs_cross_domain_utils_src__WEBPACK_IMPORTED_MODULE_4__.getDomain)() + "/checkoutnow/error";
                    payment.payer = payment.payer || {};
                    payment.payer.payment_method = payment.payer.payment_method || "paypal";
                    return Object(_api__WEBPACK_IMPORTED_MODULE_5__.createPaymentToken)(payment, {
                        facilitatorAccessToken: facilitatorAccessToken,
                        partnerAttributionID: partnerAttributionID
                    });
                }
            };
        }
        function buildXCreateOrderActions(_ref4) {
            var facilitatorAccessToken = _ref4.facilitatorAccessToken, intent = _ref4.intent, currency = _ref4.currency, merchantID = _ref4.merchantID, partnerAttributionID = _ref4.partnerAttributionID, experiments = _ref4.experiments;
            var order = buildOrderActions({
                facilitatorAccessToken: facilitatorAccessToken,
                intent: intent,
                currency: currency,
                merchantID: merchantID,
                partnerAttributionID: partnerAttributionID,
                experiments: experiments
            });
            var payment = buildPaymentActions({
                facilitatorAccessToken: facilitatorAccessToken,
                intent: intent,
                currency: currency,
                merchantID: merchantID,
                partnerAttributionID: partnerAttributionID,
                experiments: experiments
            });
            return {
                order: order,
                payment: _config__WEBPACK_IMPORTED_MODULE_8__.ENABLE_PAYMENT_API ? payment : null
            };
        }
        function getCreateOrder(_ref5, _ref6) {
            var createOrder = _ref5.createOrder, intent = _ref5.intent, currency = _ref5.currency, merchantID = _ref5.merchantID, partnerAttributionID = _ref5.partnerAttributionID, experiments = _ref5.experiments;
            var facilitatorAccessToken = _ref6.facilitatorAccessToken, createBillingAgreement = _ref6.createBillingAgreement, createSubscription = _ref6.createSubscription, createVaultSetupToken = _ref6.createVaultSetupToken, flow = _ref6.flow;
            var isVaultWithoutPurchase = "vault_without_purchase" === flow && createVaultSetupToken;
            var data = buildXCreateOrderData({
                paymentSource: _ref5.paymentSource
            });
            var actions = buildXCreateOrderActions({
                facilitatorAccessToken: facilitatorAccessToken,
                intent: intent,
                currency: currency,
                merchantID: merchantID,
                partnerAttributionID: partnerAttributionID,
                experiments: experiments
            });
            var integrationType = "server-side";
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.memoize)((function() {
                var queryOrderID = Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.getQueryParam)("orderID");
                if (queryOrderID) return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__.ZalgoPromise.resolve(queryOrderID);
                var startTime = Date.now();
                return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__.ZalgoPromise.try((function() {
                    if (isVaultWithoutPurchase) return createVaultSetupToken().then(_api_vault__WEBPACK_IMPORTED_MODULE_9__.vaultApprovalSessionIdToOrderId);
                    if (createBillingAgreement) return createBillingAgreement().then(_api__WEBPACK_IMPORTED_MODULE_5__.billingTokenToOrderID);
                    if (createSubscription) return createSubscription().then(_api__WEBPACK_IMPORTED_MODULE_5__.subscriptionIdToCartId);
                    if (createOrder) return createOrder(data, actions);
                    integrationType = "client-side";
                    return actions.order.create({
                        purchase_units: [ {
                            amount: {
                                currency_code: currency,
                                value: "0.01"
                            }
                        } ]
                    });
                })).catch((function(err) {
                    if (!isVaultWithoutPurchase) {
                        var _getLogger$error$trac;
                        Object(_lib__WEBPACK_IMPORTED_MODULE_7__.sendCountMetric)({
                            name: "pp.app.paypal_sdk.buttons.create_order.error.count",
                            dimensions: {
                                errorName: "generic",
                                flow: flow,
                                intent: intent,
                                integrationType: integrationType
                            }
                        });
                        Object(_lib__WEBPACK_IMPORTED_MODULE_7__.getLogger)().error("create_order_error", {
                            err: Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.stringifyErrorMessage)(err)
                        }).track(((_getLogger$error$trac = {})[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.STATE] = _constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_STATE.BUTTON, 
                        _getLogger$error$trac[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.ERROR_CODE] = "smart_buttons_create_order_error", 
                        _getLogger$error$trac[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.ERROR_DESC] = Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.stringifyErrorMessage)(err), 
                        _getLogger$error$trac));
                    }
                    throw err;
                })).then((function(orderID) {
                    if (!orderID || "string" != typeof orderID) {
                        var _getLogger$track;
                        Object(_lib__WEBPACK_IMPORTED_MODULE_7__.sendCountMetric)({
                            name: "pp.app.paypal_sdk.buttons.create_order.error.count",
                            dimensions: {
                                errorName: "no_order_id",
                                flow: flow,
                                intent: intent,
                                integrationType: integrationType
                            }
                        });
                        Object(_lib__WEBPACK_IMPORTED_MODULE_7__.getLogger)().track(((_getLogger$track = {})[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.STATE] = _constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_STATE.BUTTON, 
                        _getLogger$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.ERROR_CODE] = "smart_buttons_create_order_error", 
                        _getLogger$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.ERROR_DESC] = "Expected an order id to be passed", 
                        _getLogger$track));
                        throw new Error("Expected an order id to be passed");
                    }
                    if (0 === orderID.indexOf("PAY-") || 0 === orderID.indexOf("PAYID-")) {
                        var _getLogger$track2;
                        Object(_lib__WEBPACK_IMPORTED_MODULE_7__.sendCountMetric)({
                            name: "pp.app.paypal_sdk.buttons.create_order.error.count",
                            dimensions: {
                                errorName: "pay_id",
                                flow: flow,
                                intent: intent,
                                integrationType: integrationType
                            }
                        });
                        Object(_lib__WEBPACK_IMPORTED_MODULE_7__.getLogger)().track(((_getLogger$track2 = {})[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.STATE] = _constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_STATE.BUTTON, 
                        _getLogger$track2[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.ERROR_CODE] = "smart_buttons_create_order_error", 
                        _getLogger$track2[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.ERROR_DESC] = "Do not pass PAY-XXX or PAYID-XXX directly into createOrder. Pass the EC-XXX token instead", 
                        _getLogger$track2));
                        throw new Error("Do not pass PAY-XXX or PAYID-XXX directly into createOrder. Pass the EC-XXX token instead");
                    }
                    if (!isVaultWithoutPurchase) {
                        var _getLogger$addPayload;
                        var duration = Date.now() - startTime;
                        Object(_lib__WEBPACK_IMPORTED_MODULE_7__.sendCountMetric)({
                            name: "pp.app.paypal_sdk.buttons.create_order.count",
                            dimensions: {
                                flow: flow,
                                intent: intent,
                                integrationType: integrationType
                            }
                        });
                        Object(_lib__WEBPACK_IMPORTED_MODULE_7__.getLogger)().addPayloadBuilder((function() {
                            return {
                                token: orderID
                            };
                        })).addTrackingBuilder((function() {
                            var _ref7;
                            return (_ref7 = {})[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_TYPE] = _constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_CONTEXT_TYPE.ORDER_ID, 
                            _ref7[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_ID] = orderID, 
                            _ref7[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TOKEN] = orderID, 
                            _ref7;
                        })).track((_getLogger$addPayload = {}, _getLogger$addPayload[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.STATE] = _constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_STATE.BUTTON, 
                        _getLogger$addPayload[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_TRANSITION.RECEIVE_ORDER, 
                        _getLogger$addPayload[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.EVENT_NAME] = _constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_TRANSITION.RECEIVE_ORDER, 
                        _getLogger$addPayload[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_TYPE] = _constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_CONTEXT_TYPE.ORDER_ID, 
                        _getLogger$addPayload[_constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_BUTTON_KEY.BUTTON_WIDTH] = window.innerWidth, 
                        _getLogger$addPayload[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_ID] = orderID, 
                        _getLogger$addPayload[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TOKEN] = orderID, 
                        _getLogger$addPayload[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.RESPONSE_DURATION] = duration.toString(), 
                        _getLogger$addPayload.client_time = Object(_lib__WEBPACK_IMPORTED_MODULE_7__.getClientsideTimestamp)(), 
                        _getLogger$addPayload)).flush();
                    }
                    return orderID;
                }));
            }));
        }
    },
    "./src/props/createSubscription.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "buildXCreateSubscriptionData", (function() {
            return buildXCreateSubscriptionData;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXCreateSubscriptionActions", (function() {
            return buildXCreateSubscriptionActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getCreateSubscription", (function() {
            return getCreateSubscription;
        }));
        __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/api/index.js");
        var _lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/lib/index.js");
        function buildXCreateSubscriptionData(_ref) {
            return {
                paymentSource: _ref.paymentSource
            };
        }
        function buildXCreateSubscriptionActions(_ref2) {
            var facilitatorAccessToken = _ref2.facilitatorAccessToken, partnerAttributionID = _ref2.partnerAttributionID, merchantID = _ref2.merchantID, clientID = _ref2.clientID;
            return {
                subscription: {
                    create: function(data) {
                        return Object(_api__WEBPACK_IMPORTED_MODULE_1__.createSubscription)(facilitatorAccessToken, data, {
                            partnerAttributionID: partnerAttributionID,
                            merchantID: merchantID,
                            clientID: clientID
                        });
                    },
                    revise: function(subscriptionID, data) {
                        return Object(_api__WEBPACK_IMPORTED_MODULE_1__.reviseSubscription)(facilitatorAccessToken, subscriptionID, data, {
                            partnerAttributionID: partnerAttributionID,
                            merchantID: merchantID,
                            clientID: clientID
                        });
                    }
                }
            };
        }
        function getCreateSubscription(_ref3, _ref4) {
            var createSubscription = _ref3.createSubscription, partnerAttributionID = _ref3.partnerAttributionID, merchantID = _ref3.merchantID, clientID = _ref3.clientID, paymentSource = _ref3.paymentSource;
            var facilitatorAccessToken = _ref4.facilitatorAccessToken;
            if (createSubscription) {
                if (merchantID && merchantID[0]) {
                    Object(_lib__WEBPACK_IMPORTED_MODULE_2__.getLogger)().info("src_props_subscriptions_recreate_access_token_cache");
                    Object(_api__WEBPACK_IMPORTED_MODULE_1__.createAccessToken)(clientID, {
                        targetSubject: merchantID[0]
                    });
                }
                return function() {
                    return createSubscription(buildXCreateSubscriptionData({
                        paymentSource: paymentSource
                    }), buildXCreateSubscriptionActions({
                        facilitatorAccessToken: facilitatorAccessToken,
                        partnerAttributionID: partnerAttributionID,
                        merchantID: merchantID,
                        clientID: clientID
                    })).then((function(subscriptionID) {
                        if (!subscriptionID || "string" != typeof subscriptionID) throw new Error("Expected an subscription id to be passed to createSubscription");
                        return subscriptionID;
                    }));
                };
            }
        }
    },
    "./src/props/createVaultSetupToken.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "buildXCreateVaultSetupTokenData", (function() {
            return buildXCreateVaultSetupTokenData;
        }));
        __webpack_require__.d(__webpack_exports__, "getCreateVaultSetupToken", (function() {
            return getCreateVaultSetupToken;
        }));
        var _krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/constants.js");
        var _lib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/lib/index.js");
        function buildXCreateVaultSetupTokenData(_ref) {
            return {
                paymentSource: _ref.paymentSource
            };
        }
        var getCreateVaultSetupToken = function(_ref2) {
            var createVaultSetupToken = _ref2.createVaultSetupToken;
            var data = buildXCreateVaultSetupTokenData({
                paymentSource: _ref2.paymentSource
            });
            var startTime = Date.now();
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_0__.memoize)((function() {
                if (!createVaultSetupToken) throw new Error("createVaultSetupToken undefined");
                return createVaultSetupToken(data).then((function(vaultSetupToken) {
                    var _getLogger$addTrackin;
                    if (!vaultSetupToken || "string" != typeof vaultSetupToken) {
                        var _getLogger$error$trac;
                        var errString = "Expected a vault setup token to be returned from createVaultSetupToken";
                        Object(_lib__WEBPACK_IMPORTED_MODULE_4__.sendCountMetric)({
                            name: "pp.app.paypal_sdk.buttons.create_vault_setup_token.count",
                            event: "error",
                            dimensions: {
                                errorName: "no_setup_token"
                            }
                        });
                        Object(_lib__WEBPACK_IMPORTED_MODULE_4__.getLogger)().error("create_vault_setup_token", {
                            err: errString
                        }).track(((_getLogger$error$trac = {})[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.STATE] = _constants__WEBPACK_IMPORTED_MODULE_3__.FPTI_STATE.BUTTON, 
                        _getLogger$error$trac[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.ERROR_CODE] = "smart_buttons_create_vault_setup_token", 
                        _getLogger$error$trac[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.ERROR_DESC] = errString, 
                        _getLogger$error$trac));
                        throw new Error(errString);
                    }
                    Object(_lib__WEBPACK_IMPORTED_MODULE_4__.sendCountMetric)({
                        name: "pp.app.paypal_sdk.buttons.create_vault_setup_token.count",
                        event: "success",
                        dimensions: {
                            errorName: "no_vault_setup_token"
                        }
                    });
                    Object(_lib__WEBPACK_IMPORTED_MODULE_4__.getLogger)().addTrackingBuilder((function() {
                        var _ref3;
                        return (_ref3 = {})[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.CONTEXT_TYPE] = _constants__WEBPACK_IMPORTED_MODULE_3__.FPTI_CONTEXT_TYPE.VAULT_SETUP_TOKEN, 
                        _ref3[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.CONTEXT_ID] = vaultSetupToken, 
                        _ref3;
                    })).track(((_getLogger$addTrackin = {})[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.STATE] = _constants__WEBPACK_IMPORTED_MODULE_3__.FPTI_STATE.BUTTON, 
                    _getLogger$addTrackin[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_3__.FPTI_TRANSITION.RECEIVE_VAULT_SETUP_TOKEN, 
                    _getLogger$addTrackin[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.EVENT_NAME] = _constants__WEBPACK_IMPORTED_MODULE_3__.FPTI_TRANSITION.RECEIVE_VAULT_SETUP_TOKEN, 
                    _getLogger$addTrackin[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.RESPONSE_DURATION] = (Date.now() - startTime).toString(), 
                    _getLogger$addTrackin.client_time = Object(_lib__WEBPACK_IMPORTED_MODULE_4__.getClientsideTimestamp)(), 
                    _getLogger$addTrackin));
                    return vaultSetupToken;
                })).catch((function(err) {
                    var _getLogger$error$trac2;
                    Object(_lib__WEBPACK_IMPORTED_MODULE_4__.sendCountMetric)({
                        name: "pp.app.paypal_sdk.buttons.create_vault_setup_token.count",
                        event: "error",
                        dimensions: {
                            errorName: "generic"
                        }
                    });
                    Object(_lib__WEBPACK_IMPORTED_MODULE_4__.getLogger)().error("create_vault_setup_token_error", {
                        err: Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_0__.stringifyErrorMessage)(err)
                    }).track((_getLogger$error$trac2 = {}, _getLogger$error$trac2[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.STATE] = _constants__WEBPACK_IMPORTED_MODULE_3__.FPTI_STATE.BUTTON, 
                    _getLogger$error$trac2[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.ERROR_CODE] = "smart_buttons_create_vault_setup_token_error", 
                    _getLogger$error$trac2[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.ERROR_DESC] = Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_0__.stringifyErrorMessage)(err), 
                    _getLogger$error$trac2)).flush();
                    throw err;
                }));
            }));
        };
    },
    "./src/props/getPageUrl.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "getGetPageUrl", (function() {
            return getGetPageUrl;
        }));
        __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        function getGetPageUrl(_ref) {
            return _ref.getPageUrl;
        }
    },
    "./src/props/getPopupBridge.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "POPUP_BRIDGE_OPTYPE", (function() {
            return POPUP_BRIDGE_OPTYPE;
        }));
        __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var POPUP_BRIDGE_OPTYPE = {
            PAYMENT: "payment",
            CANCEL: "cancel"
        };
    },
    "./src/props/getQueriedEligibleFunding.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
    },
    "./src/props/index.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var _props__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/props/props.js");
        __webpack_require__.d(__webpack_exports__, "TYPES", (function() {
            return _props__WEBPACK_IMPORTED_MODULE_0__.TYPES;
        }));
        __webpack_require__.d(__webpack_exports__, "getProps", (function() {
            return _props__WEBPACK_IMPORTED_MODULE_0__.getProps;
        }));
        var _createOrder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/props/createOrder.js");
        __webpack_require__.d(__webpack_exports__, "buildXCreateOrderData", (function() {
            return _createOrder__WEBPACK_IMPORTED_MODULE_1__.buildXCreateOrderData;
        }));
        __webpack_require__.d(__webpack_exports__, "buildOrderActions", (function() {
            return _createOrder__WEBPACK_IMPORTED_MODULE_1__.buildOrderActions;
        }));
        __webpack_require__.d(__webpack_exports__, "buildPaymentActions", (function() {
            return _createOrder__WEBPACK_IMPORTED_MODULE_1__.buildPaymentActions;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXCreateOrderActions", (function() {
            return _createOrder__WEBPACK_IMPORTED_MODULE_1__.buildXCreateOrderActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getCreateOrder", (function() {
            return _createOrder__WEBPACK_IMPORTED_MODULE_1__.getCreateOrder;
        }));
        var _confirmOrder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/props/confirmOrder.js");
        __webpack_require__.d(__webpack_exports__, "getConfirmOrder", (function() {
            return _confirmOrder__WEBPACK_IMPORTED_MODULE_2__.getConfirmOrder;
        }));
        var _createBillingAgreement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/props/createBillingAgreement.js");
        __webpack_require__.d(__webpack_exports__, "buildXCreateBillingAgreementData", (function() {
            return _createBillingAgreement__WEBPACK_IMPORTED_MODULE_3__.buildXCreateBillingAgreementData;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXCreateBillingAgreementActions", (function() {
            return _createBillingAgreement__WEBPACK_IMPORTED_MODULE_3__.buildXCreateBillingAgreementActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getCreateBillingAgreement", (function() {
            return _createBillingAgreement__WEBPACK_IMPORTED_MODULE_3__.getCreateBillingAgreement;
        }));
        var _createSubscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/props/createSubscription.js");
        __webpack_require__.d(__webpack_exports__, "buildXCreateSubscriptionData", (function() {
            return _createSubscription__WEBPACK_IMPORTED_MODULE_4__.buildXCreateSubscriptionData;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXCreateSubscriptionActions", (function() {
            return _createSubscription__WEBPACK_IMPORTED_MODULE_4__.buildXCreateSubscriptionActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getCreateSubscription", (function() {
            return _createSubscription__WEBPACK_IMPORTED_MODULE_4__.getCreateSubscription;
        }));
        var _createVaultSetupToken__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/props/createVaultSetupToken.js");
        __webpack_require__.d(__webpack_exports__, "buildXCreateVaultSetupTokenData", (function() {
            return _createVaultSetupToken__WEBPACK_IMPORTED_MODULE_5__.buildXCreateVaultSetupTokenData;
        }));
        __webpack_require__.d(__webpack_exports__, "getCreateVaultSetupToken", (function() {
            return _createVaultSetupToken__WEBPACK_IMPORTED_MODULE_5__.getCreateVaultSetupToken;
        }));
        var _onApprove__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/props/onApprove.js");
        __webpack_require__.d(__webpack_exports__, "getOnApproveOrder", (function() {
            return _onApprove__WEBPACK_IMPORTED_MODULE_6__.getOnApproveOrder;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnApproveBilling", (function() {
            return _onApprove__WEBPACK_IMPORTED_MODULE_6__.getOnApproveBilling;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnApproveTokenize", (function() {
            return _onApprove__WEBPACK_IMPORTED_MODULE_6__.getOnApproveTokenize;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnApproveSubscription", (function() {
            return _onApprove__WEBPACK_IMPORTED_MODULE_6__.getOnApproveSubscription;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnApproveVaultWithoutPurchase", (function() {
            return _onApprove__WEBPACK_IMPORTED_MODULE_6__.getOnApproveVaultWithoutPurchase;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnApprove", (function() {
            return _onApprove__WEBPACK_IMPORTED_MODULE_6__.getOnApprove;
        }));
        var _onComplete__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/props/onComplete.js");
        __webpack_require__.d(__webpack_exports__, "getOnComplete", (function() {
            return _onComplete__WEBPACK_IMPORTED_MODULE_7__.getOnComplete;
        }));
        var _onInit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/props/onInit.js");
        __webpack_require__.d(__webpack_exports__, "buildXOnInitActions", (function() {
            return _onInit__WEBPACK_IMPORTED_MODULE_8__.buildXOnInitActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnInit", (function() {
            return _onInit__WEBPACK_IMPORTED_MODULE_8__.getOnInit;
        }));
        var _onCancel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/props/onCancel.js");
        __webpack_require__.d(__webpack_exports__, "buildXOnCancelData", (function() {
            return _onCancel__WEBPACK_IMPORTED_MODULE_9__.buildXOnCancelData;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXOnCancelActions", (function() {
            return _onCancel__WEBPACK_IMPORTED_MODULE_9__.buildXOnCancelActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnCancel", (function() {
            return _onCancel__WEBPACK_IMPORTED_MODULE_9__.getOnCancel;
        }));
        var _onShippingChange__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./src/props/onShippingChange.js");
        __webpack_require__.d(__webpack_exports__, "ON_SHIPPING_CHANGE_PATHS", (function() {
            return _onShippingChange__WEBPACK_IMPORTED_MODULE_10__.ON_SHIPPING_CHANGE_PATHS;
        }));
        __webpack_require__.d(__webpack_exports__, "SHIPPING_ADDRESS_ERROR_MESSAGES", (function() {
            return _onShippingChange__WEBPACK_IMPORTED_MODULE_10__.SHIPPING_ADDRESS_ERROR_MESSAGES;
        }));
        __webpack_require__.d(__webpack_exports__, "SHIPPING_OPTIONS_ERROR_MESSAGES", (function() {
            return _onShippingChange__WEBPACK_IMPORTED_MODULE_10__.SHIPPING_OPTIONS_ERROR_MESSAGES;
        }));
        __webpack_require__.d(__webpack_exports__, "GENERIC_REJECT_ADDRESS_MESSAGE", (function() {
            return _onShippingChange__WEBPACK_IMPORTED_MODULE_10__.GENERIC_REJECT_ADDRESS_MESSAGE;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXOnShippingChangeData", (function() {
            return _onShippingChange__WEBPACK_IMPORTED_MODULE_10__.buildXOnShippingChangeData;
        }));
        __webpack_require__.d(__webpack_exports__, "sanitizePatch", (function() {
            return _onShippingChange__WEBPACK_IMPORTED_MODULE_10__.sanitizePatch;
        }));
        __webpack_require__.d(__webpack_exports__, "isWeasley", (function() {
            return _onShippingChange__WEBPACK_IMPORTED_MODULE_10__.isWeasley;
        }));
        __webpack_require__.d(__webpack_exports__, "logInvalidShippingChangePatches", (function() {
            return _onShippingChange__WEBPACK_IMPORTED_MODULE_10__.logInvalidShippingChangePatches;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXShippingChangeActions", (function() {
            return _onShippingChange__WEBPACK_IMPORTED_MODULE_10__.buildXShippingChangeActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnShippingChange", (function() {
            return _onShippingChange__WEBPACK_IMPORTED_MODULE_10__.getOnShippingChange;
        }));
        var _onShippingAddressChange__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./src/props/onShippingAddressChange.js");
        __webpack_require__.d(__webpack_exports__, "buildXOnShippingAddressChangeData", (function() {
            return _onShippingAddressChange__WEBPACK_IMPORTED_MODULE_11__.buildXOnShippingAddressChangeData;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXOnShippingAddressChangeActions", (function() {
            return _onShippingAddressChange__WEBPACK_IMPORTED_MODULE_11__.buildXOnShippingAddressChangeActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnShippingAddressChange", (function() {
            return _onShippingAddressChange__WEBPACK_IMPORTED_MODULE_11__.getOnShippingAddressChange;
        }));
        var _onShippingOptionsChange__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./src/props/onShippingOptionsChange.js");
        __webpack_require__.d(__webpack_exports__, "buildXOnShippingOptionsChangeData", (function() {
            return _onShippingOptionsChange__WEBPACK_IMPORTED_MODULE_12__.buildXOnShippingOptionsChangeData;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXOnShippingOptionsChangeActions", (function() {
            return _onShippingOptionsChange__WEBPACK_IMPORTED_MODULE_12__.buildXOnShippingOptionsChangeActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnShippingOptionsChange", (function() {
            return _onShippingOptionsChange__WEBPACK_IMPORTED_MODULE_12__.getOnShippingOptionsChange;
        }));
        var _onClick__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./src/props/onClick.js");
        __webpack_require__.d(__webpack_exports__, "CLICK_VALID", (function() {
            return _onClick__WEBPACK_IMPORTED_MODULE_13__.CLICK_VALID;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXOnClickData", (function() {
            return _onClick__WEBPACK_IMPORTED_MODULE_13__.buildXOnClickData;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXOnClickActions", (function() {
            return _onClick__WEBPACK_IMPORTED_MODULE_13__.buildXOnClickActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnClick", (function() {
            return _onClick__WEBPACK_IMPORTED_MODULE_13__.getOnClick;
        }));
        var _onError__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./src/props/onError.js");
        __webpack_require__.d(__webpack_exports__, "getOnError", (function() {
            return _onError__WEBPACK_IMPORTED_MODULE_14__.getOnError;
        }));
        var _getPopupBridge__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./src/props/getPopupBridge.js");
        __webpack_require__.d(__webpack_exports__, "POPUP_BRIDGE_OPTYPE", (function() {
            return _getPopupBridge__WEBPACK_IMPORTED_MODULE_15__.POPUP_BRIDGE_OPTYPE;
        }));
        var _rememberFunding__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./src/props/rememberFunding.js");
        __webpack_require__.d(__webpack_exports__, "getRememberFunding", (function() {
            return _rememberFunding__WEBPACK_IMPORTED_MODULE_16__.getRememberFunding;
        }));
        var _getPageUrl__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./src/props/getPageUrl.js");
        __webpack_require__.d(__webpack_exports__, "getGetPageUrl", (function() {
            return _getPageUrl__WEBPACK_IMPORTED_MODULE_17__.getGetPageUrl;
        }));
        var _onAuth__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./src/props/onAuth.js");
        __webpack_require__.d(__webpack_exports__, "getOnAuth", (function() {
            return _onAuth__WEBPACK_IMPORTED_MODULE_18__.getOnAuth;
        }));
        __webpack_require__("./src/props/getQueriedEligibleFunding.js");
        var _paymentRequest__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./src/props/paymentRequest.js");
        for (var __WEBPACK_IMPORT_KEY__ in _paymentRequest__WEBPACK_IMPORTED_MODULE_20__) [ "default", "TYPES", "getProps", "buildXCreateOrderData", "buildOrderActions", "buildPaymentActions", "buildXCreateOrderActions", "getCreateOrder", "getConfirmOrder", "buildXCreateBillingAgreementData", "buildXCreateBillingAgreementActions", "getCreateBillingAgreement", "buildXCreateSubscriptionData", "buildXCreateSubscriptionActions", "getCreateSubscription", "buildXCreateVaultSetupTokenData", "getCreateVaultSetupToken", "getOnApproveOrder", "getOnApproveBilling", "getOnApproveTokenize", "getOnApproveSubscription", "getOnApproveVaultWithoutPurchase", "getOnApprove", "getOnComplete", "buildXOnInitActions", "getOnInit", "buildXOnCancelData", "buildXOnCancelActions", "getOnCancel", "ON_SHIPPING_CHANGE_PATHS", "SHIPPING_ADDRESS_ERROR_MESSAGES", "SHIPPING_OPTIONS_ERROR_MESSAGES", "GENERIC_REJECT_ADDRESS_MESSAGE", "buildXOnShippingChangeData", "sanitizePatch", "isWeasley", "logInvalidShippingChangePatches", "buildXShippingChangeActions", "getOnShippingChange", "buildXOnShippingAddressChangeData", "buildXOnShippingAddressChangeActions", "getOnShippingAddressChange", "buildXOnShippingOptionsChangeData", "buildXOnShippingOptionsChangeActions", "getOnShippingOptionsChange", "CLICK_VALID", "buildXOnClickData", "buildXOnClickActions", "getOnClick", "getOnError", "POPUP_BRIDGE_OPTYPE", "getRememberFunding", "getGetPageUrl", "getOnAuth" ].indexOf(__WEBPACK_IMPORT_KEY__) < 0 && function(key) {
            __webpack_require__.d(__webpack_exports__, key, (function() {
                return _paymentRequest__WEBPACK_IMPORTED_MODULE_20__[key];
            }));
        }(__WEBPACK_IMPORT_KEY__);
    },
    "./src/props/onApprove.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "getOnApproveOrder", (function() {
            return getOnApproveOrder;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnApproveBilling", (function() {
            return getOnApproveBilling;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnApproveTokenize", (function() {
            return getOnApproveTokenize;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnApproveSubscription", (function() {
            return getOnApproveSubscription;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnApproveVaultWithoutPurchase", (function() {
            return getOnApproveVaultWithoutPurchase;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnApprove", (function() {
            return getOnApprove;
        }));
        var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/extends.js");
        var _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        var _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/api/index.js");
        var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/constants.js");
        var _lib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/lib/index.js");
        var _config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/config.js");
        var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/props/utils.js");
        var redirect = function(url) {
            if (!url) throw new Error("Expected redirect url");
            if (-1 === url.indexOf("://")) {
                Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().warn("redir_url_non_scheme", {
                    url: url
                }).flush();
                throw new Error("Invalid redirect url: " + url + " - must be fully qualified url");
            }
            url.match(/^https?:\/\//) || Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().warn("redir_url_non_http", {
                url: url
            }).flush();
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.redirect)(url, window.top);
        };
        var handleProcessorError = function(err, restart, onError) {
            if (Object(_api__WEBPACK_IMPORTED_MODULE_4__.isUnprocessableEntityError)(err)) {
                err && err.response && (err.message = JSON.stringify(err.response) || err.message);
                return onError(err).then(_lib__WEBPACK_IMPORTED_MODULE_6__.unresolvedPromise);
            }
            if (Object(_api__WEBPACK_IMPORTED_MODULE_4__.isProcessorDeclineError)(err)) return restart().then(_lib__WEBPACK_IMPORTED_MODULE_6__.unresolvedPromise);
            throw err;
        };
        function getOnApproveOrder(_ref7) {
            var intent = _ref7.intent, _ref7$onApprove = _ref7.onApprove, onApprove = void 0 === _ref7$onApprove ? function(intent) {
                return function(data, actions) {
                    if (intent === _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.INTENT.CAPTURE) return actions.order.capture().then(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.noop);
                    if (intent === _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.INTENT.AUTHORIZE) return actions.order.authorize().then(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.noop);
                    throw new Error("Unsupported intent for auto-capture: " + intent);
                };
            }(intent) : _ref7$onApprove, partnerAttributionID = _ref7.partnerAttributionID, onError = _ref7.onError, clientAccessToken = _ref7.clientAccessToken, vault = _ref7.vault, facilitatorAccessToken = _ref7.facilitatorAccessToken, branded = _ref7.branded, createOrder = _ref7.createOrder, paymentSource = _ref7.paymentSource, featureFlags = _ref7.featureFlags, experiments = _ref7.experiments, beforeOnApprove = _ref7.beforeOnApprove;
            if (!onApprove) throw new Error("Expected onApprove");
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.memoize)((function(_ref8, _ref9) {
                var payerID = _ref8.payerID, paymentID = _ref8.paymentID, billingToken = _ref8.billingToken, buyerAccessToken = _ref8.buyerAccessToken, authCode = _ref8.authCode, _ref8$forceRestAPI = _ref8.forceRestAPI, forceRestAPI = void 0 === _ref8$forceRestAPI ? featureFlags.isLsatUpgradable : _ref8$forceRestAPI;
                var restart = _ref9.restart;
                return createOrder().then((function(orderID) {
                    var _getLogger$info$track;
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().info("button_approve").track((_getLogger$info$track = {}, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.STATE] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_STATE.BUTTON, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_TRANSITION.CHECKOUT_APPROVE, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_TYPE] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_CONTEXT_TYPE.ORDER_ID, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TOKEN] = orderID, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_ID] = orderID, 
                    _getLogger$info$track)).flush();
                    billingToken || clientAccessToken || vault || !payerID && branded && Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().warn("onapprove_payerid_not_present_for_branded_standalone_button", {
                        orderID: orderID
                    }).flush();
                    return Object(_api__WEBPACK_IMPORTED_MODULE_4__.getSupplementalOrderInfo)(orderID).then((function(supplementalData) {
                        billingToken = billingToken || supplementalData && supplementalData.checkoutSession && supplementalData.checkoutSession.cart && supplementalData.checkoutSession.cart.billingToken;
                        paymentID = paymentID || supplementalData && supplementalData.checkoutSession && supplementalData.checkoutSession.cart && supplementalData.checkoutSession.cart.paymentId;
                        !experiments.btSdkOrdersV2Migration || paymentID || billingToken || (paymentID = orderID.replace(/EC-/, ""));
                        var data = {
                            orderID: orderID,
                            payerID: payerID,
                            paymentID: paymentID,
                            billingToken: billingToken,
                            facilitatorAccessToken: facilitatorAccessToken,
                            authCode: authCode,
                            paymentSource: paymentSource
                        };
                        var actions = function(_ref3) {
                            var intent = _ref3.intent, orderID = _ref3.orderID, paymentID = _ref3.paymentID, payerID = _ref3.payerID, restart = _ref3.restart, facilitatorAccessToken = _ref3.facilitatorAccessToken, buyerAccessToken = _ref3.buyerAccessToken, partnerAttributionID = _ref3.partnerAttributionID, forceRestAPI = _ref3.forceRestAPI, onError = _ref3.onError;
                            var order = function(_ref) {
                                var intent = _ref.intent, orderID = _ref.orderID, restart = _ref.restart, facilitatorAccessToken = _ref.facilitatorAccessToken, buyerAccessToken = _ref.buyerAccessToken, partnerAttributionID = _ref.partnerAttributionID, forceRestAPI = _ref.forceRestAPI, onError = _ref.onError, experiments = _ref.experiments, paymentSource = _ref.paymentSource;
                                var get = Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.memoize)((function() {
                                    var isUlsatNotRequired = Object(_utils__WEBPACK_IMPORTED_MODULE_8__.checkUlsatNotRequired)(paymentSource, buyerAccessToken);
                                    return null != experiments && experiments.upgradeLSATWithIgnoreCache && !isUlsatNotRequired ? Object(_api__WEBPACK_IMPORTED_MODULE_4__.upgradeFacilitatorAccessTokenWithIgnoreCache)(facilitatorAccessToken, buyerAccessToken, orderID).then((function(upgradedFacilitatorAccessToken) {
                                        return Object(_api__WEBPACK_IMPORTED_MODULE_4__.getOrder)(orderID, {
                                            facilitatorAccessToken: upgradedFacilitatorAccessToken,
                                            buyerAccessToken: buyerAccessToken,
                                            partnerAttributionID: partnerAttributionID,
                                            forceRestAPI: forceRestAPI,
                                            experiments: experiments
                                        });
                                    })) : Object(_api__WEBPACK_IMPORTED_MODULE_4__.getOrder)(orderID, {
                                        facilitatorAccessToken: facilitatorAccessToken,
                                        buyerAccessToken: buyerAccessToken,
                                        partnerAttributionID: partnerAttributionID,
                                        forceRestAPI: forceRestAPI,
                                        experiments: experiments
                                    });
                                }));
                                var capture = Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.memoize)((function() {
                                    if (intent !== _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.INTENT.CAPTURE) throw new Error("Use " + _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.SDK_QUERY_KEYS.INTENT + "=" + _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.INTENT.CAPTURE + " to use client-side capture");
                                    var isUlsatNotRequired = Object(_utils__WEBPACK_IMPORTED_MODULE_8__.checkUlsatNotRequired)(paymentSource, buyerAccessToken);
                                    return null != experiments && experiments.upgradeLSATWithIgnoreCache && !isUlsatNotRequired ? Object(_api__WEBPACK_IMPORTED_MODULE_4__.upgradeFacilitatorAccessTokenWithIgnoreCache)(facilitatorAccessToken, buyerAccessToken, orderID).then((function(upgradedFacilitatorAccessToken) {
                                        return Object(_api__WEBPACK_IMPORTED_MODULE_4__.captureOrder)(orderID, {
                                            facilitatorAccessToken: upgradedFacilitatorAccessToken,
                                            buyerAccessToken: buyerAccessToken,
                                            partnerAttributionID: partnerAttributionID,
                                            forceRestAPI: forceRestAPI,
                                            experiments: experiments
                                        }).finally(get.reset).finally(capture.reset).catch((function(err) {
                                            return handleProcessorError(err, restart, onError);
                                        }));
                                    })) : Object(_api__WEBPACK_IMPORTED_MODULE_4__.captureOrder)(orderID, {
                                        facilitatorAccessToken: facilitatorAccessToken,
                                        buyerAccessToken: buyerAccessToken,
                                        partnerAttributionID: partnerAttributionID,
                                        forceRestAPI: forceRestAPI,
                                        experiments: experiments
                                    }).finally(get.reset).finally(capture.reset).catch((function(err) {
                                        return handleProcessorError(err, restart, onError);
                                    }));
                                }));
                                var authorize = Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.memoize)((function() {
                                    if (intent !== _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.INTENT.AUTHORIZE) throw new Error("Use " + _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.SDK_QUERY_KEYS.INTENT + "=" + _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.INTENT.AUTHORIZE + " to use client-side authorize");
                                    var isUlsatNotRequired = Object(_utils__WEBPACK_IMPORTED_MODULE_8__.checkUlsatNotRequired)(paymentSource, buyerAccessToken);
                                    return null != experiments && experiments.upgradeLSATWithIgnoreCache && !isUlsatNotRequired ? Object(_api__WEBPACK_IMPORTED_MODULE_4__.upgradeFacilitatorAccessTokenWithIgnoreCache)(facilitatorAccessToken, buyerAccessToken, orderID).then((function(upgradedFacilitatorAccessToken) {
                                        return Object(_api__WEBPACK_IMPORTED_MODULE_4__.authorizeOrder)(orderID, {
                                            facilitatorAccessToken: upgradedFacilitatorAccessToken,
                                            buyerAccessToken: buyerAccessToken,
                                            partnerAttributionID: partnerAttributionID,
                                            forceRestAPI: forceRestAPI,
                                            experiments: experiments
                                        }).finally(get.reset).finally(authorize.reset).catch((function(err) {
                                            return handleProcessorError(err, restart, onError);
                                        }));
                                    })) : Object(_api__WEBPACK_IMPORTED_MODULE_4__.authorizeOrder)(orderID, {
                                        facilitatorAccessToken: facilitatorAccessToken,
                                        buyerAccessToken: buyerAccessToken,
                                        partnerAttributionID: partnerAttributionID,
                                        forceRestAPI: forceRestAPI,
                                        experiments: experiments
                                    }).finally(get.reset).finally(authorize.reset).catch((function(err) {
                                        return handleProcessorError(err, restart, onError);
                                    }));
                                }));
                                return {
                                    capture: capture,
                                    authorize: authorize,
                                    patch: function(data) {
                                        void 0 === data && (data = {});
                                        var isUlsatNotRequired = Object(_utils__WEBPACK_IMPORTED_MODULE_8__.checkUlsatNotRequired)(paymentSource, buyerAccessToken);
                                        return null != experiments && experiments.upgradeLSATWithIgnoreCache && !isUlsatNotRequired ? Object(_api__WEBPACK_IMPORTED_MODULE_4__.upgradeFacilitatorAccessTokenWithIgnoreCache)(facilitatorAccessToken, buyerAccessToken, orderID).then((function(upgradedFacilitatorAccessToken) {
                                            return Object(_api__WEBPACK_IMPORTED_MODULE_4__.patchOrder)(orderID, data, {
                                                facilitatorAccessToken: upgradedFacilitatorAccessToken,
                                                buyerAccessToken: buyerAccessToken,
                                                partnerAttributionID: partnerAttributionID,
                                                forceRestAPI: forceRestAPI,
                                                experiments: experiments
                                            }).catch((function() {
                                                throw new Error("Order could not be patched");
                                            }));
                                        })) : Object(_api__WEBPACK_IMPORTED_MODULE_4__.patchOrder)(orderID, data, {
                                            facilitatorAccessToken: facilitatorAccessToken,
                                            buyerAccessToken: buyerAccessToken,
                                            partnerAttributionID: partnerAttributionID,
                                            forceRestAPI: forceRestAPI,
                                            experiments: experiments
                                        }).catch((function() {
                                            throw new Error("Order could not be patched");
                                        }));
                                    },
                                    get: get
                                };
                            }({
                                intent: intent,
                                orderID: orderID,
                                paymentID: paymentID,
                                payerID: payerID,
                                restart: restart,
                                facilitatorAccessToken: facilitatorAccessToken,
                                buyerAccessToken: buyerAccessToken,
                                partnerAttributionID: partnerAttributionID,
                                forceRestAPI: forceRestAPI,
                                onError: onError,
                                experiments: _ref3.experiments,
                                paymentSource: _ref3.paymentSource
                            });
                            var payment = function(_ref2) {
                                var intent = _ref2.intent, paymentID = _ref2.paymentID, payerID = _ref2.payerID, restart = _ref2.restart, facilitatorAccessToken = _ref2.facilitatorAccessToken, buyerAccessToken = _ref2.buyerAccessToken, partnerAttributionID = _ref2.partnerAttributionID, onError = _ref2.onError;
                                if (paymentID) {
                                    var get = Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.memoize)((function() {
                                        return Object(_api__WEBPACK_IMPORTED_MODULE_4__.getPayment)(paymentID, {
                                            facilitatorAccessToken: facilitatorAccessToken,
                                            buyerAccessToken: buyerAccessToken,
                                            partnerAttributionID: partnerAttributionID
                                        });
                                    }));
                                    var execute = Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.memoize)((function() {
                                        if (!payerID) throw new Error("payerID required for payment execute");
                                        if (intent !== _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.INTENT.CAPTURE) throw new Error("Use " + _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.SDK_QUERY_KEYS.INTENT + "=" + _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.INTENT.CAPTURE + " to use client-side capture");
                                        return Object(_api__WEBPACK_IMPORTED_MODULE_4__.executePayment)(paymentID, payerID, {
                                            facilitatorAccessToken: facilitatorAccessToken,
                                            buyerAccessToken: buyerAccessToken,
                                            partnerAttributionID: partnerAttributionID
                                        }).finally(get.reset).finally(execute.reset).catch((function(err) {
                                            return handleProcessorError(err, restart, onError);
                                        }));
                                    }));
                                    return {
                                        execute: execute,
                                        patch: function(data) {
                                            void 0 === data && (data = {});
                                            return Object(_api__WEBPACK_IMPORTED_MODULE_4__.patchPayment)(paymentID, data, {
                                                facilitatorAccessToken: facilitatorAccessToken,
                                                buyerAccessToken: buyerAccessToken,
                                                partnerAttributionID: partnerAttributionID
                                            }).catch((function() {
                                                throw new Error("Order could not be patched");
                                            }));
                                        },
                                        get: get
                                    };
                                }
                            }({
                                intent: intent,
                                orderID: orderID,
                                paymentID: paymentID,
                                payerID: payerID,
                                restart: restart,
                                facilitatorAccessToken: facilitatorAccessToken,
                                buyerAccessToken: buyerAccessToken,
                                partnerAttributionID: partnerAttributionID,
                                forceRestAPI: forceRestAPI,
                                onError: onError
                            });
                            return {
                                order: order,
                                payment: _config__WEBPACK_IMPORTED_MODULE_7__.ENABLE_PAYMENT_API ? payment : null,
                                restart: restart,
                                redirect: redirect
                            };
                        }({
                            orderID: orderID,
                            paymentID: paymentID,
                            payerID: payerID,
                            intent: intent,
                            restart: restart,
                            facilitatorAccessToken: facilitatorAccessToken,
                            buyerAccessToken: buyerAccessToken,
                            partnerAttributionID: partnerAttributionID,
                            onError: onError,
                            forceRestAPI: forceRestAPI,
                            experiments: experiments,
                            paymentSource: paymentSource
                        });
                        beforeOnApprove();
                        return onApprove(data, actions).catch((function(err) {
                            return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__.ZalgoPromise.try((function() {
                                return onError(err);
                            })).then((function() {
                                throw err;
                            }));
                        }));
                    }));
                }));
            }));
        }
        function getOnApproveBilling(_ref10) {
            var _ref10$onApprove = _ref10.onApprove, onApprove = void 0 === _ref10$onApprove ? function() {
                throw new Error("Expected onApprove");
            } : _ref10$onApprove, onError = _ref10.onError, facilitatorAccessToken = _ref10.facilitatorAccessToken, createOrder = _ref10.createOrder, paymentSource = _ref10.paymentSource, beforeOnApprove = _ref10.beforeOnApprove;
            if (!onApprove) throw new Error("Expected onApprove");
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.memoize)((function(_ref11, _ref12) {
                var payerID = _ref11.payerID, paymentID = _ref11.paymentID, billingToken = _ref11.billingToken;
                var restart = _ref12.restart;
                return createOrder().then((function(orderID) {
                    var _getLogger$info$track2;
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().info("button_approve").track((_getLogger$info$track2 = {}, 
                    _getLogger$info$track2[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_TRANSITION.CHECKOUT_APPROVE, 
                    _getLogger$info$track2[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_TYPE] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_CONTEXT_TYPE.ORDER_ID, 
                    _getLogger$info$track2[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TOKEN] = orderID, 
                    _getLogger$info$track2[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_ID] = orderID, 
                    _getLogger$info$track2)).flush();
                    return Object(_api__WEBPACK_IMPORTED_MODULE_4__.getSupplementalOrderInfo)(orderID).then((function(supplementalData) {
                        var data = {
                            orderID: orderID,
                            payerID: payerID,
                            paymentID: paymentID = paymentID || supplementalData && supplementalData.checkoutSession && supplementalData.checkoutSession.cart && supplementalData.checkoutSession.cart.paymentId,
                            billingToken: billingToken = billingToken || supplementalData && supplementalData.checkoutSession && supplementalData.checkoutSession.cart && supplementalData.checkoutSession.cart.billingToken,
                            facilitatorAccessToken: facilitatorAccessToken,
                            paymentSource: paymentSource
                        };
                        var actions = {
                            restart: restart,
                            redirect: redirect
                        };
                        beforeOnApprove();
                        return onApprove(data, actions).catch((function(err) {
                            return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__.ZalgoPromise.try((function() {
                                return onError(err);
                            })).then((function() {
                                throw err;
                            }));
                        }));
                    }));
                }));
            }));
        }
        function getOnApproveTokenize(_ref13) {
            var _ref13$onApprove = _ref13.onApprove, onApprove = void 0 === _ref13$onApprove ? function() {
                throw new Error("Expected onApprove");
            } : _ref13$onApprove, onError = _ref13.onError, facilitatorAccessToken = _ref13.facilitatorAccessToken, paymentSource = _ref13.paymentSource, beforeOnApprove = _ref13.beforeOnApprove;
            if (!onApprove) throw new Error("Expected onApprove");
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.memoize)((function(_ref14, _ref15) {
                var _getLogger$info$track3;
                var paymentMethodToken = _ref14.paymentMethodToken;
                var restart = _ref15.restart;
                if (!paymentMethodToken) throw new Error("Payment method token required for tokenize onApprove");
                Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().info("button_approve").track((_getLogger$info$track3 = {}, 
                _getLogger$info$track3[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_TRANSITION.TOKENIZE_APPROVE, 
                _getLogger$info$track3)).flush();
                var data = {
                    facilitatorAccessToken: facilitatorAccessToken,
                    paymentMethodToken: paymentMethodToken,
                    paymentSource: paymentSource
                };
                var actions = {
                    restart: restart,
                    redirect: redirect
                };
                beforeOnApprove();
                return onApprove(data, actions).catch((function(err) {
                    return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__.ZalgoPromise.try((function() {
                        return onError(err);
                    })).then((function() {
                        throw err;
                    }));
                }));
            }));
        }
        function getOnApproveSubscription(_ref16) {
            var _ref16$onApprove = _ref16.onApprove, onApprove = void 0 === _ref16$onApprove ? function() {
                throw new Error("Expected onApprove");
            } : _ref16$onApprove, onError = _ref16.onError, facilitatorAccessToken = _ref16.facilitatorAccessToken, createOrder = _ref16.createOrder, paymentSource = _ref16.paymentSource, beforeOnApprove = _ref16.beforeOnApprove;
            if (!onApprove) throw new Error("Expected onApprove");
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.memoize)((function(_ref17, _ref18) {
                var payerID = _ref17.payerID, subscriptionID = _ref17.subscriptionID, buyerAccessToken = _ref17.buyerAccessToken;
                var restart = _ref18.restart;
                if (!subscriptionID) throw new Error("Expected subscriptionID");
                return createOrder().then((function(orderID) {
                    var _getLogger$info$track4;
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().info("button_approve").track((_getLogger$info$track4 = {}, 
                    _getLogger$info$track4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_TRANSITION.CHECKOUT_APPROVE, 
                    _getLogger$info$track4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.EVENT_NAME] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_TRANSITION.CHECKOUT_APPROVE, 
                    _getLogger$info$track4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_TYPE] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_CONTEXT_TYPE.ORDER_ID, 
                    _getLogger$info$track4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TOKEN] = orderID, 
                    _getLogger$info$track4[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_ID] = orderID, 
                    _getLogger$info$track4)).flush();
                    var data = {
                        orderID: orderID,
                        payerID: payerID,
                        subscriptionID: subscriptionID,
                        facilitatorAccessToken: facilitatorAccessToken,
                        paymentSource: paymentSource
                    };
                    var actions = function(_ref6) {
                        var restart = _ref6.restart, subscriptionID = _ref6.subscriptionID, buyerAccessToken = _ref6.buyerAccessToken;
                        return {
                            subscription: {
                                get: Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.memoize)((function() {
                                    if (!subscriptionID) throw new Error("No subscription ID present");
                                    return Object(_api__WEBPACK_IMPORTED_MODULE_4__.getSubscription)(subscriptionID, {
                                        buyerAccessToken: buyerAccessToken
                                    });
                                })),
                                activate: Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.memoize)((function() {
                                    if (!subscriptionID) throw new Error("No subscription ID present");
                                    return Object(_api__WEBPACK_IMPORTED_MODULE_4__.activateSubscription)(subscriptionID, {
                                        buyerAccessToken: buyerAccessToken
                                    });
                                }))
                            },
                            restart: restart,
                            redirect: redirect
                        };
                    }({
                        restart: restart,
                        subscriptionID: subscriptionID,
                        buyerAccessToken: buyerAccessToken
                    });
                    beforeOnApprove();
                    return onApprove(data, actions).catch((function(err) {
                        return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__.ZalgoPromise.try((function() {
                            return onError(err);
                        })).then((function() {
                            throw err;
                        }));
                    }));
                }));
            }));
        }
        function getOnApproveVaultWithoutPurchase(_ref19) {
            var onApprove = _ref19.onApprove, onError = _ref19.onError, facilitatorAccessToken = _ref19.facilitatorAccessToken, createOrder = _ref19.createOrder, paymentSource = _ref19.paymentSource, createVaultSetupToken = _ref19.createVaultSetupToken, beforeOnApprove = _ref19.beforeOnApprove;
            if (!onApprove) throw new Error("Expected onApprove");
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.memoize)((function(_ref20) {
                var payerID = _ref20.payerID;
                return createOrder().then((function(orderID) {
                    var _getLogger$info$track5;
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().info("button_approve").track((_getLogger$info$track5 = {}, 
                    _getLogger$info$track5[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_TRANSITION.CHECKOUT_APPROVE, 
                    _getLogger$info$track5[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.EVENT_NAME] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_TRANSITION.CHECKOUT_APPROVE, 
                    _getLogger$info$track5[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_TYPE] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_CONTEXT_TYPE.ORDER_ID, 
                    _getLogger$info$track5[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TOKEN] = orderID, 
                    _getLogger$info$track5[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_ID] = orderID, 
                    _getLogger$info$track5)).flush();
                    return createVaultSetupToken().then((function(vaultSetupToken) {
                        var data = {
                            payerID: payerID,
                            facilitatorAccessToken: facilitatorAccessToken,
                            paymentSource: paymentSource,
                            vaultSetupToken: vaultSetupToken
                        };
                        beforeOnApprove();
                        return onApprove(data).then((function(res) {
                            var _getLogger$track;
                            Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().track((_getLogger$track = {}, 
                            _getLogger$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_TRANSITION.CHECKOUT_APPROVE, 
                            _getLogger$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_TYPE] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_CONTEXT_TYPE.VAULT_SETUP_TOKEN, 
                            _getLogger$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TOKEN] = vaultSetupToken, 
                            _getLogger$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_ID] = vaultSetupToken, 
                            _getLogger$track)).flush();
                            return res;
                        })).catch((function(err) {
                            return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__.ZalgoPromise.try((function() {
                                return onError(err);
                            })).then((function() {
                                throw err;
                            }));
                        }));
                    }));
                }));
            }));
        }
        function getOnApprove(_ref21) {
            var intent = _ref21.intent, createBillingAgreement = _ref21.createBillingAgreement, createSubscription = _ref21.createSubscription, onApprove = _ref21.onApprove, partnerAttributionID = _ref21.partnerAttributionID, onError = _ref21.onError, clientAccessToken = _ref21.clientAccessToken, vault = _ref21.vault, clientID = _ref21.clientID, facilitatorAccessToken = _ref21.facilitatorAccessToken, branded = _ref21.branded, createOrder = _ref21.createOrder, paymentSource = _ref21.paymentSource, featureFlags = _ref21.featureFlags, createVaultSetupToken = _ref21.createVaultSetupToken, flow = _ref21.flow, experiments = _ref21.experiments;
            var beforeOnApprove = function() {
                Object(_lib__WEBPACK_IMPORTED_MODULE_6__.sendCountMetric)({
                    name: "pp.app.paypal_sdk.buttons.click.success.count",
                    dimensions: Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({
                        spbPaymentFlow: flow
                    }, experiments)
                });
            };
            if (flow && "vault_without_purchase" === flow && createVaultSetupToken) return getOnApproveVaultWithoutPurchase({
                onApprove: onApprove,
                onError: onError,
                facilitatorAccessToken: facilitatorAccessToken,
                createOrder: createOrder,
                paymentSource: paymentSource,
                createVaultSetupToken: createVaultSetupToken,
                beforeOnApprove: beforeOnApprove
            });
            if (createBillingAgreement) return getOnApproveBilling({
                onApprove: onApprove,
                onError: onError,
                facilitatorAccessToken: facilitatorAccessToken,
                createOrder: createOrder,
                paymentSource: paymentSource,
                beforeOnApprove: beforeOnApprove
            });
            if (intent === _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.INTENT.SUBSCRIPTION || createSubscription) return getOnApproveSubscription({
                clientID: clientID,
                onApprove: onApprove,
                onError: onError,
                facilitatorAccessToken: facilitatorAccessToken,
                createOrder: createOrder,
                paymentSource: paymentSource,
                beforeOnApprove: beforeOnApprove
            });
            if (intent === _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.INTENT.CAPTURE || intent === _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.INTENT.AUTHORIZE || intent === _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.INTENT.ORDER) return getOnApproveOrder({
                intent: intent,
                onApprove: onApprove,
                partnerAttributionID: partnerAttributionID,
                onError: onError,
                clientAccessToken: clientAccessToken,
                vault: vault,
                facilitatorAccessToken: facilitatorAccessToken,
                branded: branded,
                createOrder: createOrder,
                paymentSource: paymentSource,
                featureFlags: featureFlags,
                experiments: experiments,
                beforeOnApprove: beforeOnApprove
            });
            if (intent === _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.INTENT.TOKENIZE) return getOnApproveTokenize({
                onApprove: onApprove,
                onError: onError,
                facilitatorAccessToken: facilitatorAccessToken,
                paymentSource: paymentSource,
                beforeOnApprove: beforeOnApprove
            });
            throw new Error("Unsupported intent: " + intent);
        }
    },
    "./src/props/onAuth.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "getOnAuth", (function() {
            return getOnAuth;
        }));
        var _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        var _api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/api/index.js");
        var _lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/lib/index.js");
        function getOnAuth(_ref) {
            var facilitatorAccessToken = _ref.facilitatorAccessToken, createOrder = _ref.createOrder, createSubscription = _ref.createSubscription, featureFlags = _ref.featureFlags, experiments = _ref.experiments;
            return function(_ref2) {
                var accessToken = _ref2.accessToken;
                Object(_lib__WEBPACK_IMPORTED_MODULE_3__.getLogger)().info("spb_onauth_access_token_" + (accessToken ? "present" : "not_present"));
                var isInIgnoreCacheExperiment = null == experiments ? void 0 : experiments.upgradeLSATWithIgnoreCache;
                return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__.ZalgoPromise.try((function() {
                    if (accessToken) {
                        if (createSubscription || isInIgnoreCacheExperiment) {
                            Object(_lib__WEBPACK_IMPORTED_MODULE_3__.setBuyerAccessToken)(accessToken);
                            Object(_lib__WEBPACK_IMPORTED_MODULE_3__.getLogger)().info("ignore_lsat_upgrade", {
                                createSubscription: Boolean(createSubscription),
                                upgradeLSATWithIgnoreCache: isInIgnoreCacheExperiment,
                                isLsatUpgradable: featureFlags.isLsatUpgradable,
                                accessToken: Boolean(accessToken)
                            });
                            return accessToken;
                        }
                        return featureFlags.isLsatUpgradable ? createOrder().then((function(orderID) {
                            return Object(_api__WEBPACK_IMPORTED_MODULE_2__.upgradeFacilitatorAccessToken)(facilitatorAccessToken, {
                                buyerAccessToken: accessToken,
                                orderID: orderID
                            });
                        })).then((function() {
                            Object(_lib__WEBPACK_IMPORTED_MODULE_3__.getLogger)().info("upgrade_lsat_success");
                            return accessToken;
                        })).catch((function(err) {
                            Object(_lib__WEBPACK_IMPORTED_MODULE_3__.getLogger)().warn("upgrade_lsat_failure", {
                                error: Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__.stringifyError)(err)
                            });
                            return accessToken;
                        })) : accessToken;
                    }
                }));
            };
        }
    },
    "./src/props/onCancel.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "buildXOnCancelData", (function() {
            return buildXOnCancelData;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXOnCancelActions", (function() {
            return buildXOnCancelActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnCancel", (function() {
            return getOnCancel;
        }));
        var _krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/lib/index.js");
        var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/constants.js");
        function buildXOnCancelData(_ref) {
            return {
                orderID: _ref.orderID
            };
        }
        function buildXOnCancelActions() {
            return {
                redirect: function(url) {
                    if (!url) throw new Error("Expected redirect url");
                    if (-1 === url.indexOf("://")) {
                        Object(_lib__WEBPACK_IMPORTED_MODULE_3__.getLogger)().warn("redir_url_non_scheme", {
                            url: url
                        }).flush();
                        throw new Error("Invalid redirect url: " + url + " - must be fully qualified url");
                    }
                    url.match(/^https?:\/\//) || Object(_lib__WEBPACK_IMPORTED_MODULE_3__.getLogger)().warn("redir_url_non_http", {
                        url: url
                    }).flush();
                    return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_0__.redirect)(url, window.top);
                }
            };
        }
        function getOnCancel(_ref2, _ref3) {
            var _ref2$onCancel = _ref2.onCancel, onCancel = void 0 === _ref2$onCancel ? _lib__WEBPACK_IMPORTED_MODULE_3__.promiseNoop : _ref2$onCancel, onError = _ref2.onError;
            var createOrder = _ref3.createOrder;
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_0__.memoize)((function() {
                return createOrder().then((function(orderID) {
                    var _getLogger$info$track;
                    Object(_lib__WEBPACK_IMPORTED_MODULE_3__.getLogger)().info("button_cancel").track((_getLogger$info$track = {}, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_4__.FPTI_TRANSITION.CHECKOUT_CANCEL, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.EVENT_NAME] = _constants__WEBPACK_IMPORTED_MODULE_4__.FPTI_TRANSITION.CHECKOUT_CANCEL, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.CONTEXT_TYPE] = _constants__WEBPACK_IMPORTED_MODULE_4__.FPTI_CONTEXT_TYPE.ORDER_ID, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.TOKEN] = orderID, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.CONTEXT_ID] = orderID, 
                    _getLogger$info$track)).flush();
                    return onCancel(buildXOnCancelData({
                        orderID: orderID
                    }), buildXOnCancelActions());
                })).catch((function(err) {
                    return onError(err);
                }));
            }));
        }
    },
    "./src/props/onClick.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "CLICK_VALID", (function() {
            return CLICK_VALID;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXOnClickData", (function() {
            return buildXOnClickData;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXOnClickActions", (function() {
            return buildXOnClickActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnClick", (function() {
            return getOnClick;
        }));
        var _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        var CLICK_VALID = {
            VALID: !0,
            INVALID: !1
        };
        function buildXOnClickData(_ref) {
            return {
                fundingSource: _ref.fundingSource
            };
        }
        function buildXOnClickActions() {
            return {
                resolve: function() {
                    return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__.ZalgoPromise.try((function() {
                        return CLICK_VALID.VALID;
                    }));
                },
                reject: function() {
                    return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__.ZalgoPromise.try((function() {
                        return CLICK_VALID.INVALID;
                    }));
                }
            };
        }
        function getOnClick(_ref2) {
            var onClick = _ref2.onClick;
            if (onClick) return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_2__.memoize)((function(_ref3) {
                return onClick(buildXOnClickData({
                    fundingSource: _ref3.fundingSource
                }), buildXOnClickActions()).then((function(valid) {
                    return valid !== CLICK_VALID.INVALID;
                }));
            }));
        }
    },
    "./src/props/onComplete.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "getOnComplete", (function() {
            return getOnComplete;
        }));
        var _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        var _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/lib/index.js");
        var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/constants.js");
        var _api__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/api/index.js");
        var redirect = function(url) {
            if (!url) throw new Error("Expected redirect url");
            if (-1 === url.indexOf("://")) {
                Object(_lib__WEBPACK_IMPORTED_MODULE_3__.getLogger)().warn("redir_url_non_scheme", {
                    url: url
                }).flush();
                throw new Error("Invalid redirect url: " + url + " - must be fully qualified url");
            }
            url.match(/^https?:\/\//) || Object(_lib__WEBPACK_IMPORTED_MODULE_3__.getLogger)().warn("redir_url_non_http", {
                url: url
            }).flush();
            return Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__.redirect)(url, window.top);
        };
        function getOnComplete(_ref2) {
            var intent = _ref2.intent, onComplete = _ref2.onComplete, partnerAttributionID = _ref2.partnerAttributionID, onError = _ref2.onError, facilitatorAccessToken = _ref2.facilitatorAccessToken, createOrder = _ref2.createOrder, featureFlags = _ref2.featureFlags, experiments = _ref2.experiments;
            return onComplete ? Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__.memoize)((function(_ref3) {
                var buyerAccessToken = _ref3.buyerAccessToken, _ref3$forceRestAPI = _ref3.forceRestAPI, forceRestAPI = void 0 === _ref3$forceRestAPI ? featureFlags.isLsatUpgradable : _ref3$forceRestAPI;
                return createOrder().then((function(orderID) {
                    var _getLogger$info$track;
                    Object(_lib__WEBPACK_IMPORTED_MODULE_3__.getLogger)().info("button_complete").track((_getLogger$info$track = {}, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_4__.FPTI_TRANSITION.CHECKOUT_COMPLETE, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.EVENT_NAME] = _constants__WEBPACK_IMPORTED_MODULE_4__.FPTI_TRANSITION.CHECKOUT_COMPLETE, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.CONTEXT_TYPE] = _constants__WEBPACK_IMPORTED_MODULE_4__.FPTI_CONTEXT_TYPE.ORDER_ID, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.TOKEN] = orderID, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_2__.FPTI_KEY.CONTEXT_ID] = orderID, 
                    _getLogger$info$track)).flush();
                    var actions = function(_ref) {
                        var orderID = _ref.orderID, facilitatorAccessToken = _ref.facilitatorAccessToken, buyerAccessToken = _ref.buyerAccessToken, partnerAttributionID = _ref.partnerAttributionID, forceRestAPI = _ref.forceRestAPI, experiments = _ref.experiments;
                        var get = Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__.memoize)((function() {
                            return Object(_api__WEBPACK_IMPORTED_MODULE_5__.getOrder)(orderID, {
                                facilitatorAccessToken: facilitatorAccessToken,
                                buyerAccessToken: buyerAccessToken,
                                partnerAttributionID: partnerAttributionID,
                                forceRestAPI: forceRestAPI,
                                experiments: experiments
                            }).finally(get.reset);
                        }));
                        return {
                            order: {
                                get: get
                            },
                            redirect: redirect
                        };
                    }({
                        orderID: orderID,
                        facilitatorAccessToken: facilitatorAccessToken,
                        buyerAccessToken: buyerAccessToken,
                        partnerAttributionID: partnerAttributionID,
                        onError: onError,
                        forceRestAPI: forceRestAPI,
                        experiments: experiments
                    });
                    return onComplete({
                        orderID: orderID,
                        intent: intent
                    }, actions).catch((function(err) {
                        return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__.ZalgoPromise.try((function() {
                            return onError(err);
                        })).then((function() {
                            throw err;
                        }));
                    }));
                }));
            })) : _lib__WEBPACK_IMPORTED_MODULE_3__.promiseNoop;
        }
    },
    "./src/props/onError.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "getOnError", (function() {
            return getOnError;
        }));
        var _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@krakenjs/belter/src/index.js");
        function getOnError(_ref) {
            var onError = _ref.onError;
            var onErrorHandler = onError ? Object(_krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__.dedupeErrors)(onError) : _krakenjs_belter_src__WEBPACK_IMPORTED_MODULE_1__.noop;
            return function(err) {
                return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__.ZalgoPromise.try((function() {
                    return onErrorHandler(err);
                }));
            };
        }
    },
    "./src/props/onInit.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "buildXOnInitActions", (function() {
            return buildXOnInitActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnInit", (function() {
            return getOnInit;
        }));
        var _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        function buildXOnInitActions(set) {
            return {
                enable: function() {
                    return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__.ZalgoPromise.try((function() {
                        return set(!0);
                    }));
                },
                disable: function() {
                    return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__.ZalgoPromise.try((function() {
                        return set(!1);
                    }));
                }
            };
        }
        function getOnInit(_ref) {
            var onInit = _ref.onInit;
            return function(data) {
                var enabled = !0;
                return {
                    initPromise: _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_0__.ZalgoPromise.try((function() {
                        if (onInit) return onInit(data, buildXOnInitActions((function(val) {
                            enabled = val;
                        })));
                    })),
                    isEnabled: function() {
                        return enabled;
                    }
                };
            };
        }
    },
    "./src/props/onShippingAddressChange.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "buildXOnShippingAddressChangeData", (function() {
            return buildXOnShippingAddressChangeData;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXOnShippingAddressChangeActions", (function() {
            return buildXOnShippingAddressChangeActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnShippingAddressChange", (function() {
            return getOnShippingAddressChange;
        }));
        var _babel_runtime_helpers_esm_objectDestructuringEmpty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js");
        var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/extends.js");
        var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
        __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _api__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/api/index.js");
        var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/constants.js");
        var _lib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/lib/index.js");
        var _onShippingChange__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/props/onShippingChange.js");
        var _shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/props/shippingChangeUtils.js");
        var _excluded = [ "amount", "buyerAccessToken", "event", "forceRestAPI", "shippingAddress" ];
        function buildXOnShippingAddressChangeData(data) {
            var shippingAddress = data.shippingAddress, rest = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_2__.default)(data, _excluded);
            return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__.default)({
                errors: _onShippingChange__WEBPACK_IMPORTED_MODULE_8__.SHIPPING_ADDRESS_ERROR_MESSAGES,
                shippingAddress: shippingAddress
            }, rest);
        }
        function buildXOnShippingAddressChangeActions(_ref) {
            var _data$amount;
            var data = _ref.data, passedActions = _ref.actions, orderID = _ref.orderID;
            var patchQueries = {};
            var breakdown = null != (_data$amount = data.amount) && _data$amount.breakdown ? Object(_shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__.breakdownKeyChanges)(data.amount.breakdown) : {};
            if (0 === Object.keys(breakdown).length) throw new Error("Must pass amount with breakdown into data attribute for onShippingAddressChange callback.");
            return {
                reject: passedActions.reject ? function(message) {
                    return -1 === Object.values(_onShippingChange__WEBPACK_IMPORTED_MODULE_8__.SHIPPING_ADDRESS_ERROR_MESSAGES).indexOf(message) ? passedActions.reject(_onShippingChange__WEBPACK_IMPORTED_MODULE_8__.GENERIC_REJECT_ADDRESS_MESSAGE) : passedActions.reject(message);
                } : function() {
                    throw new Error("Missing reject action callback");
                },
                buildOrderPatchPayload: function(_temp) {
                    var _selectedShippingOpti, _selectedShippingOpti2;
                    var _ref2 = void 0 === _temp ? {} : _temp, discount = _ref2.discount, handling = _ref2.handling, insurance = _ref2.insurance, itemTotal = _ref2.itemTotal, shippingOptions = _ref2.shippingOptions, shippingDiscount = _ref2.shippingDiscount, taxTotal = _ref2.taxTotal;
                    var selectedShippingOption = null == shippingOptions ? void 0 : shippingOptions.find((function(option) {
                        return !0 === option.selected;
                    }));
                    var selectedShippingOptionAmount = null != (_selectedShippingOpti = null == selectedShippingOption || null == (_selectedShippingOpti2 = selectedShippingOption.amount) ? void 0 : _selectedShippingOpti2.value) ? _selectedShippingOpti : "0.00";
                    var updatedAmounts = {};
                    discount && (updatedAmounts.discount = discount);
                    handling && (updatedAmounts.handling = handling);
                    insurance && (updatedAmounts.insurance = insurance);
                    itemTotal && (updatedAmounts.item_total = itemTotal);
                    selectedShippingOption && (updatedAmounts.shipping = selectedShippingOptionAmount);
                    shippingDiscount && (updatedAmounts.shipping_discount = shippingDiscount);
                    taxTotal && (updatedAmounts.tax_total = taxTotal);
                    breakdown = Object(_shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__.buildBreakdown)({
                        breakdown: breakdown,
                        updatedAmounts: updatedAmounts
                    });
                    var newAmount = Object(_shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__.calculateTotalFromShippingBreakdownAmounts)({
                        breakdown: breakdown,
                        updatedAmounts: updatedAmounts
                    });
                    if (Object.keys(updatedAmounts).length) {
                        var _data$amount2;
                        patchQueries[_onShippingChange__WEBPACK_IMPORTED_MODULE_8__.ON_SHIPPING_CHANGE_PATHS.AMOUNT] = {
                            op: "replace",
                            path: _onShippingChange__WEBPACK_IMPORTED_MODULE_8__.ON_SHIPPING_CHANGE_PATHS.AMOUNT,
                            value: {
                                value: "" + newAmount,
                                currency_code: null == data || null == (_data$amount2 = data.amount) ? void 0 : _data$amount2.currencyCode,
                                breakdown: breakdown
                            }
                        };
                    }
                    return Object(_api__WEBPACK_IMPORTED_MODULE_5__.getShippingOrderInfo)(orderID).then((function(sessionData) {
                        var _sessionData$checkout;
                        var shippingMethods = (null == sessionData || null == (_sessionData$checkout = sessionData.checkoutSession) || null == (_sessionData$checkout = _sessionData$checkout.cart) ? void 0 : _sessionData$checkout.shippingMethods) || [];
                        var hasShippingMethods = Boolean(shippingMethods.length > 0);
                        if (null != shippingOptions && shippingOptions.length) {
                            var ordersV2Options = Object(_shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__.optionsKeyChanges)(shippingOptions);
                            patchQueries[_onShippingChange__WEBPACK_IMPORTED_MODULE_8__.ON_SHIPPING_CHANGE_PATHS.OPTIONS] = {
                                op: hasShippingMethods ? "replace" : "add",
                                path: _onShippingChange__WEBPACK_IMPORTED_MODULE_8__.ON_SHIPPING_CHANGE_PATHS.OPTIONS,
                                value: ordersV2Options
                            };
                        }
                        return hasShippingMethods ? Object(_shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__.updateOperationForShippingOptions)({
                            queries: patchQueries
                        }) : Object(_shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__.convertQueriesToArray)({
                            queries: patchQueries
                        });
                    }));
                }
            };
        }
        function getOnShippingAddressChange(_ref3, _ref4) {
            var onShippingAddressChange = _ref3.onShippingAddressChange;
            var createOrder = _ref4.createOrder;
            if (onShippingAddressChange) return function(_ref5, actions) {
                var data = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__.default)({}, (Object(_babel_runtime_helpers_esm_objectDestructuringEmpty__WEBPACK_IMPORTED_MODULE_0__.default)(_ref5), 
                _ref5));
                return createOrder().then((function(orderID) {
                    var _getLogger$info$track;
                    Object(_lib__WEBPACK_IMPORTED_MODULE_7__.getLogger)().info("button_shipping_address_change").track((_getLogger$info$track = {}, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_4__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_TRANSITION.CHECKOUT_SHIPPING_ADDRESS_CHANGE, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_4__.FPTI_KEY.EVENT_NAME] = _constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_TRANSITION.CHECKOUT_SHIPPING_ADDRESS_CHANGE, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_4__.FPTI_KEY.CONTEXT_TYPE] = _constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_CONTEXT_TYPE.ORDER_ID, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_4__.FPTI_KEY.TOKEN] = orderID, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_4__.FPTI_KEY.CONTEXT_ID] = orderID, 
                    _getLogger$info$track[_constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_CUSTOM_KEY.SHIPPING_CALLBACK_INVOKED] = "1", 
                    _getLogger$info$track)).flush();
                    return onShippingAddressChange(buildXOnShippingAddressChangeData(data), buildXOnShippingAddressChangeActions({
                        data: data,
                        actions: actions,
                        orderID: orderID
                    }));
                }));
            };
        }
    },
    "./src/props/onShippingChange.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "ON_SHIPPING_CHANGE_PATHS", (function() {
            return ON_SHIPPING_CHANGE_PATHS;
        }));
        __webpack_require__.d(__webpack_exports__, "SHIPPING_ADDRESS_ERROR_MESSAGES", (function() {
            return SHIPPING_ADDRESS_ERROR_MESSAGES;
        }));
        __webpack_require__.d(__webpack_exports__, "SHIPPING_OPTIONS_ERROR_MESSAGES", (function() {
            return SHIPPING_OPTIONS_ERROR_MESSAGES;
        }));
        __webpack_require__.d(__webpack_exports__, "GENERIC_REJECT_ADDRESS_MESSAGE", (function() {
            return GENERIC_REJECT_ADDRESS_MESSAGE;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXOnShippingChangeData", (function() {
            return buildXOnShippingChangeData;
        }));
        __webpack_require__.d(__webpack_exports__, "sanitizePatch", (function() {
            return sanitizePatch;
        }));
        __webpack_require__.d(__webpack_exports__, "isWeasley", (function() {
            return isWeasley;
        }));
        __webpack_require__.d(__webpack_exports__, "logInvalidShippingChangePatches", (function() {
            return logInvalidShippingChangePatches;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXShippingChangeActions", (function() {
            return buildXShippingChangeActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnShippingChange", (function() {
            return getOnShippingChange;
        }));
        var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
        var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/extends.js");
        var _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/api/index.js");
        var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/constants.js");
        var _lib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/lib/index.js");
        var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/props/utils.js");
        var _excluded = [ "buyerAccessToken", "forceRestAPI", "appName" ];
        var ON_SHIPPING_CHANGE_PATHS = {
            AMOUNT: "/purchase_units/@reference_id=='default'/amount",
            OPTIONS: "/purchase_units/@reference_id=='default'/shipping/options"
        };
        var SHIPPING_ADDRESS_ERROR_MESSAGES = {
            ADDRESS_ERROR: "Your order can't be shipped to this address.",
            COUNTRY_ERROR: "Your order can't be shipped to this country.",
            STATE_ERROR: "Your order can't be shipped to this state.",
            ZIP_ERROR: "Your order can't be shipped to this zip."
        };
        var SHIPPING_OPTIONS_ERROR_MESSAGES = {
            METHOD_UNAVAILABLE: "The shipping method you chose is unavailable. To continue, choose another way to get your order.",
            STORE_UNAVAILABLE: "Part of your order isn't available at this store."
        };
        var GENERIC_REJECT_ADDRESS_MESSAGE = "Unable to update address. Please try again.";
        function buildXOnShippingChangeData(data) {
            return data;
        }
        var pathPattern = new RegExp(/^\/purchase_units\/@reference_id=='(?:\w|-)*'\/(?:amount|shipping\/(?:options|address|name))$/);
        var sanitizePatch = function(rejected, patch) {
            var path = patch.path;
            pathPattern.test(path) || rejected.push(path);
            return rejected;
        };
        var isWeasley = function(appName) {
            return "weasley" === appName;
        };
        var logInvalidShippingChangePatches = function(_ref) {
            var appName = _ref.appName, data = _ref.data, shouldUsePatchShipping = _ref.shouldUsePatchShipping;
            var payload = {
                appName: appName,
                hasBuyerAccessToken: String(Boolean(_ref.buyerAccessToken)),
                shouldUsePatchShipping: String(shouldUsePatchShipping)
            };
            try {
                if (Array.isArray(data)) {
                    var rejected = data.reduce(sanitizePatch, []);
                    rejected.length > 0 && Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().info("button_shipping_change_patch_data_has_invalid_path_" + appName, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__.default)({}, payload, {
                        rejected: JSON.stringify(rejected)
                    }));
                } else Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().info("button_shipping_change_patch_data_is_object", payload);
            } catch (err) {
                Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().error("button_shipping_change_patch_data_logging_failed", Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__.default)({}, payload, {
                    errMessage: JSON.stringify(err)
                }));
            }
        };
        function buildXShippingChangeActions(_ref2) {
            var orderID = _ref2.orderID, facilitatorAccessToken = _ref2.facilitatorAccessToken, buyerAccessToken = _ref2.buyerAccessToken, partnerAttributionID = _ref2.partnerAttributionID, forceRestAPI = _ref2.forceRestAPI, clientID = _ref2.clientID, experiments = _ref2.experiments, appName = _ref2.appName, paymentSource = _ref2.paymentSource;
            var useShippingChangeCallbackMutation = experiments.useShippingChangeCallbackMutation;
            return {
                resolve: function() {
                    return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_2__.ZalgoPromise.resolve();
                },
                reject: _ref2.actions.reject || function() {
                    throw new Error("Missing reject action callback");
                },
                order: {
                    patch: function(data) {
                        void 0 === data && (data = {});
                        var shouldUsePatchShipping = Boolean(useShippingChangeCallbackMutation && !buyerAccessToken && isWeasley(appName));
                        logInvalidShippingChangePatches({
                            appName: appName,
                            buyerAccessToken: buyerAccessToken,
                            data: data,
                            shouldUsePatchShipping: shouldUsePatchShipping
                        });
                        if (shouldUsePatchShipping) return Object(_api__WEBPACK_IMPORTED_MODULE_4__.patchShipping)({
                            clientID: clientID,
                            data: data,
                            orderID: orderID
                        }).catch((function() {
                            throw new Error("Order could not be patched");
                        }));
                        var isUlsatNotRequired = Object(_utils__WEBPACK_IMPORTED_MODULE_7__.checkUlsatNotRequired)(paymentSource, buyerAccessToken);
                        return null != experiments && experiments.upgradeLSATWithIgnoreCache && !isUlsatNotRequired ? Object(_api__WEBPACK_IMPORTED_MODULE_4__.upgradeFacilitatorAccessTokenWithIgnoreCache)(facilitatorAccessToken, buyerAccessToken, orderID).then((function(upgradedFacilitatorAccessToken) {
                            return Object(_api__WEBPACK_IMPORTED_MODULE_4__.patchOrder)(orderID, data, {
                                facilitatorAccessToken: upgradedFacilitatorAccessToken,
                                buyerAccessToken: buyerAccessToken,
                                partnerAttributionID: partnerAttributionID,
                                forceRestAPI: forceRestAPI,
                                experiments: experiments
                            }).catch((function() {
                                throw new Error("Order could not be patched");
                            }));
                        })) : Object(_api__WEBPACK_IMPORTED_MODULE_4__.patchOrder)(orderID, data, {
                            facilitatorAccessToken: facilitatorAccessToken,
                            buyerAccessToken: buyerAccessToken,
                            partnerAttributionID: partnerAttributionID,
                            forceRestAPI: forceRestAPI,
                            experiments: experiments
                        }).catch((function() {
                            throw new Error("Order could not be patched");
                        }));
                    }
                }
            };
        }
        function getOnShippingChange(_ref3, _ref4) {
            var onShippingChange = _ref3.onShippingChange, partnerAttributionID = _ref3.partnerAttributionID, featureFlags = _ref3.featureFlags, experiments = _ref3.experiments, clientID = _ref3.clientID, paymentSource = _ref3.paymentSource;
            var facilitatorAccessToken = _ref4.facilitatorAccessToken, createOrder = _ref4.createOrder;
            if (onShippingChange) return function(_ref5, actions) {
                var buyerAccessToken = _ref5.buyerAccessToken, _ref5$forceRestAPI = _ref5.forceRestAPI, forceRestAPI = void 0 === _ref5$forceRestAPI ? featureFlags.isLsatUpgradable : _ref5$forceRestAPI, _ref5$appName = _ref5.appName, appName = void 0 === _ref5$appName ? "not_available" : _ref5$appName, data = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__.default)(_ref5, _excluded);
                return createOrder().then((function(orderID) {
                    var _getLogger$info$track;
                    Object(_lib__WEBPACK_IMPORTED_MODULE_6__.getLogger)().info("button_shipping_change").track((_getLogger$info$track = {}, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_TRANSITION.CHECKOUT_SHIPPING_CHANGE, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.EVENT_NAME] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_TRANSITION.CHECKOUT_SHIPPING_CHANGE, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_TYPE] = _constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_CONTEXT_TYPE.ORDER_ID, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.TOKEN] = orderID, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_3__.FPTI_KEY.CONTEXT_ID] = orderID, 
                    _getLogger$info$track[_constants__WEBPACK_IMPORTED_MODULE_5__.FPTI_CUSTOM_KEY.SHIPPING_CALLBACK_INVOKED] = "1", 
                    _getLogger$info$track)).flush();
                    if (experiments.btSdkOrdersV2Migration && !data.paymentID) {
                        var _data$orderID;
                        data.paymentID = null == (_data$orderID = data.orderID) ? void 0 : _data$orderID.replace("EC-", "");
                        data.paymentId = data.paymentID;
                    }
                    return onShippingChange(data, buildXShippingChangeActions({
                        orderID: orderID,
                        facilitatorAccessToken: facilitatorAccessToken,
                        buyerAccessToken: buyerAccessToken,
                        actions: actions,
                        partnerAttributionID: partnerAttributionID,
                        forceRestAPI: forceRestAPI,
                        clientID: clientID,
                        experiments: experiments,
                        appName: appName,
                        paymentSource: paymentSource
                    }));
                }));
            };
        }
    },
    "./src/props/onShippingOptionsChange.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "buildXOnShippingOptionsChangeData", (function() {
            return buildXOnShippingOptionsChangeData;
        }));
        __webpack_require__.d(__webpack_exports__, "buildXOnShippingOptionsChangeActions", (function() {
            return buildXOnShippingOptionsChangeActions;
        }));
        __webpack_require__.d(__webpack_exports__, "getOnShippingOptionsChange", (function() {
            return getOnShippingOptionsChange;
        }));
        var _babel_runtime_helpers_esm_objectDestructuringEmpty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js");
        var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/extends.js");
        var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
        __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _api__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/api/index.js");
        var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/constants.js");
        var _lib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/lib/index.js");
        var _onShippingChange__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/props/onShippingChange.js");
        var _shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/props/shippingChangeUtils.js");
        var _excluded = [ "amount", "buyerAccessToken", "event", "forceRestAPI", "options", "selectedShippingOption" ];
        function buildXOnShippingOptionsChangeData(data) {
            var selectedShippingOption = data.selectedShippingOption, rest = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_2__.default)(data, _excluded);
            return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__.default)({
                errors: _onShippingChange__WEBPACK_IMPORTED_MODULE_8__.SHIPPING_OPTIONS_ERROR_MESSAGES,
                selectedShippingOption: selectedShippingOption
            }, rest);
        }
        function buildXOnShippingOptionsChangeActions(_ref) {
            var _data$amount;
            var data = _ref.data, passedActions = _ref.actions, orderID = _ref.orderID;
            var patchQueries = {};
            var breakdown = null != (_data$amount = data.amount) && _data$amount.breakdown ? Object(_shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__.breakdownKeyChanges)(data.amount.breakdown) : {};
            if (0 === Object.keys(breakdown).length) throw new Error("Must pass breakdown into data attribute for onShippingAddressChange callback.");
            return {
                reject: passedActions.reject ? function(message) {
                    return -1 === Object.values(_onShippingChange__WEBPACK_IMPORTED_MODULE_8__.SHIPPING_OPTIONS_ERROR_MESSAGES).indexOf(message) ? passedActions.reject(_onShippingChange__WEBPACK_IMPORTED_MODULE_8__.GENERIC_REJECT_ADDRESS_MESSAGE) : passedActions.reject(message);
                } : function() {
                    throw new Error("Missing reject action callback");
                },
                buildOrderPatchPayload: function(_temp) {
                    var _shippingOption$amoun;
                    var _ref2 = void 0 === _temp ? {} : _temp, discount = _ref2.discount, handling = _ref2.handling, insurance = _ref2.insurance, itemTotal = _ref2.itemTotal, shippingOption = _ref2.shippingOption, shippingDiscount = _ref2.shippingDiscount, taxTotal = _ref2.taxTotal;
                    var selectedShippingOptionAmount = null == shippingOption || null == (_shippingOption$amoun = shippingOption.amount) ? void 0 : _shippingOption$amoun.value;
                    var options = shippingOption && data.options ? Object(_shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__.optionsKeyChanges)(Object(_shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__.updateShippingOptions)({
                        option: shippingOption,
                        options: data.options
                    })) : void 0;
                    var updatedAmounts = {};
                    discount && (updatedAmounts.discount = discount);
                    handling && (updatedAmounts.handling = handling);
                    insurance && (updatedAmounts.insurance = insurance);
                    itemTotal && (updatedAmounts.item_total = itemTotal);
                    selectedShippingOptionAmount && (updatedAmounts.shipping = selectedShippingOptionAmount);
                    shippingDiscount && (updatedAmounts.shipping_discount = shippingDiscount);
                    taxTotal && (updatedAmounts.tax_total = taxTotal);
                    var newAmount = Object(_shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__.calculateTotalFromShippingBreakdownAmounts)({
                        breakdown: breakdown,
                        updatedAmounts: updatedAmounts
                    });
                    breakdown = Object(_shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__.buildBreakdown)({
                        breakdown: breakdown,
                        updatedAmounts: updatedAmounts
                    });
                    if (Object.keys(updatedAmounts).length) {
                        var _data$amount2;
                        patchQueries[_onShippingChange__WEBPACK_IMPORTED_MODULE_8__.ON_SHIPPING_CHANGE_PATHS.AMOUNT] = {
                            op: "replace",
                            path: _onShippingChange__WEBPACK_IMPORTED_MODULE_8__.ON_SHIPPING_CHANGE_PATHS.AMOUNT,
                            value: {
                                value: "" + newAmount,
                                currency_code: null == data || null == (_data$amount2 = data.amount) ? void 0 : _data$amount2.currencyCode,
                                breakdown: breakdown
                            }
                        };
                    }
                    return Object(_api__WEBPACK_IMPORTED_MODULE_5__.getShippingOrderInfo)(orderID).then((function(sessionData) {
                        var _sessionData$checkout;
                        var shippingMethods = (null == sessionData || null == (_sessionData$checkout = sessionData.checkoutSession) || null == (_sessionData$checkout = _sessionData$checkout.cart) ? void 0 : _sessionData$checkout.shippingMethods) || [];
                        var hasShippingMethods = Boolean(shippingMethods.length > 0);
                        null != options && options.length && (patchQueries[_onShippingChange__WEBPACK_IMPORTED_MODULE_8__.ON_SHIPPING_CHANGE_PATHS.OPTIONS] = {
                            op: hasShippingMethods ? "replace" : "add",
                            path: _onShippingChange__WEBPACK_IMPORTED_MODULE_8__.ON_SHIPPING_CHANGE_PATHS.OPTIONS,
                            value: options
                        });
                        return hasShippingMethods ? Object(_shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__.updateOperationForShippingOptions)({
                            queries: patchQueries
                        }) : Object(_shippingChangeUtils__WEBPACK_IMPORTED_MODULE_9__.convertQueriesToArray)({
                            queries: patchQueries
                        });
                    }));
                }
            };
        }
        function getOnShippingOptionsChange(_ref3, _ref4) {
            var onShippingOptionsChange = _ref3.onShippingOptionsChange;
            var createOrder = _ref4.createOrder;
            if (onShippingOptionsChange) return function(_ref5, actions) {
                var data = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__.default)({}, (Object(_babel_runtime_helpers_esm_objectDestructuringEmpty__WEBPACK_IMPORTED_MODULE_0__.default)(_ref5), 
                _ref5));
                return createOrder().then((function(orderID) {
                    var _getLogger$info$track;
                    Object(_lib__WEBPACK_IMPORTED_MODULE_7__.getLogger)().info("button_shipping_options_change").track((_getLogger$info$track = {}, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_4__.FPTI_KEY.TRANSITION] = _constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_TRANSITION.CHECKOUT_SHIPPING_OPTIONS_CHANGE, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_4__.FPTI_KEY.EVENT_NAME] = _constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_TRANSITION.CHECKOUT_SHIPPING_OPTIONS_CHANGE, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_4__.FPTI_KEY.CONTEXT_TYPE] = _constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_CONTEXT_TYPE.ORDER_ID, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_4__.FPTI_KEY.TOKEN] = orderID, 
                    _getLogger$info$track[_paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_4__.FPTI_KEY.CONTEXT_ID] = orderID, 
                    _getLogger$info$track[_constants__WEBPACK_IMPORTED_MODULE_6__.FPTI_CUSTOM_KEY.SHIPPING_CALLBACK_INVOKED] = "1", 
                    _getLogger$info$track)).flush();
                    return onShippingOptionsChange(buildXOnShippingOptionsChangeData(data), buildXOnShippingOptionsChangeActions({
                        data: data,
                        actions: actions,
                        orderID: orderID
                    }));
                }));
            };
        }
    },
    "./src/props/paymentRequest.js": function(module, exports) {},
    "./src/props/props.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "TYPES", (function() {
            return TYPES;
        }));
        __webpack_require__.d(__webpack_exports__, "getProps", (function() {
            return getProps;
        }));
        __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        var _lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/lib/index.js");
        var _onInit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/props/onInit.js");
        var _onClick__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/props/onClick.js");
        var _onError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/props/onError.js");
        var TYPES = !0;
        function getProps(_ref) {
            var branded = _ref.branded;
            var xprops = window.xprops;
            var uid = xprops.uid, env = xprops.env, _xprops$vault = xprops.vault, vault = void 0 !== _xprops$vault && _xprops$vault, commit = xprops.commit, locale = xprops.locale, platform = xprops.platform, sessionID = xprops.sessionID, clientID = xprops.clientID, partnerAttributionID = xprops.partnerAttributionID, merchantRequestedPopupsDisabled = xprops.merchantRequestedPopupsDisabled, clientMetadataID = xprops.clientMetadataID, sdkCorrelationID = xprops.sdkCorrelationID, getParentDomain = xprops.getParentDomain, clientAccessToken = xprops.clientAccessToken, getPopupBridge = xprops.getPopupBridge, getPrerenderDetails = xprops.getPrerenderDetails, getPageUrl = xprops.getPageUrl, enableThreeDomainSecure = xprops.enableThreeDomainSecure, enableVaultInstallments = xprops.enableVaultInstallments, _xprops$enableNativeC = xprops.enableNativeCheckout, enableNativeCheckout = void 0 !== _xprops$enableNativeC && _xprops$enableNativeC, rememberFunding = xprops.remember, stageHost = xprops.stageHost, apiStageHost = xprops.apiStageHost, getParent = xprops.getParent, fundingSource = xprops.fundingSource, currency = xprops.currency, connect = xprops.connect, intent = xprops.intent, merchantID = xprops.merchantID, amount = xprops.amount, userIDToken = xprops.userIDToken, enableFunding = xprops.enableFunding, disableFunding = xprops.disableFunding, disableCard = xprops.disableCard, disableAutocomplete = xprops.disableAutocomplete, wallet = xprops.wallet, _xprops$paymentMethod = xprops.paymentMethodToken, paymentMethodToken = void 0 === _xprops$paymentMethod ? xprops.paymentMethodNonce : _xprops$paymentMethod, _xprops$getQueriedEli = xprops.getQueriedEligibleFunding, getQueriedEligibleFunding = void 0 === _xprops$getQueriedEli ? function() {
                return _krakenjs_zalgo_promise_src__WEBPACK_IMPORTED_MODULE_1__.ZalgoPromise.resolve([]);
            } : _xprops$getQueriedEli, storageID = xprops.storageID, applePay = xprops.applePay, userExperienceFlow = xprops.userExperienceFlow, allowBillingPayments = xprops.allowBillingPayments, paymentRequest = xprops.paymentRequest, _xprops$disableSetCoo = xprops.disableSetCookie, disableSetCookie = void 0 !== _xprops$disableSetCoo && _xprops$disableSetCoo;
            var onInit = Object(_onInit__WEBPACK_IMPORTED_MODULE_3__.getOnInit)({
                onInit: xprops.onInit
            });
            var merchantDomain = "function" == typeof getParentDomain ? getParentDomain() : "unknown";
            enableFunding = enableFunding || [];
            disableFunding = disableFunding || [];
            var onClick = Object(_onClick__WEBPACK_IMPORTED_MODULE_4__.getOnClick)({
                onClick: xprops.onClick
            });
            var stickinessID = storageID && Object(_lib__WEBPACK_IMPORTED_MODULE_2__.isStorageStateFresh)() ? storageID : Object(_lib__WEBPACK_IMPORTED_MODULE_2__.getStorageID)();
            return {
                uid: uid,
                env: env,
                vault: vault,
                commit: commit,
                clientAccessToken: clientAccessToken,
                locale: locale,
                sessionID: sessionID,
                clientID: clientID,
                partnerAttributionID: partnerAttributionID,
                clientMetadataID: clientMetadataID,
                sdkCorrelationID: sdkCorrelationID,
                merchantDomain: merchantDomain,
                platform: platform,
                currency: currency,
                intent: intent,
                wallet: wallet,
                merchantRequestedPopupsDisabled: merchantRequestedPopupsDisabled,
                getPopupBridge: getPopupBridge,
                getPrerenderDetails: getPrerenderDetails,
                getPageUrl: getPageUrl,
                rememberFunding: rememberFunding,
                getParent: getParent,
                connect: connect,
                fundingSource: fundingSource,
                enableFunding: enableFunding,
                disableFunding: disableFunding,
                disableCard: disableCard,
                disableAutocomplete: disableAutocomplete,
                getQueriedEligibleFunding: getQueriedEligibleFunding,
                amount: amount,
                userIDToken: userIDToken,
                enableThreeDomainSecure: enableThreeDomainSecure,
                enableNativeCheckout: enableNativeCheckout,
                enableVaultInstallments: enableVaultInstallments,
                onClick: onClick,
                onInit: onInit,
                onError: Object(_onError__WEBPACK_IMPORTED_MODULE_5__.getOnError)({
                    onError: xprops.onError
                }),
                stageHost: stageHost,
                apiStageHost: apiStageHost,
                standaloneFundingSource: fundingSource,
                paymentMethodToken: paymentMethodToken,
                branded: branded,
                stickinessID: stickinessID,
                applePay: applePay,
                userExperienceFlow: userExperienceFlow,
                allowBillingPayments: allowBillingPayments,
                paymentRequest: paymentRequest,
                merchantID: merchantID,
                disableSetCookie: disableSetCookie
            };
        }
    },
    "./src/props/rememberFunding.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "getRememberFunding", (function() {
            return getRememberFunding;
        }));
        __webpack_require__("./node_modules/@krakenjs/zalgo-promise/src/index.js");
        __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        function getRememberFunding(_ref) {
            return _ref.remember;
        }
    },
    "./src/props/shippingChangeUtils.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "calculateTotalFromShippingBreakdownAmounts", (function() {
            return calculateTotalFromShippingBreakdownAmounts;
        }));
        __webpack_require__.d(__webpack_exports__, "optionsKeyChanges", (function() {
            return optionsKeyChanges;
        }));
        __webpack_require__.d(__webpack_exports__, "breakdownKeyChanges", (function() {
            return breakdownKeyChanges;
        }));
        __webpack_require__.d(__webpack_exports__, "buildBreakdown", (function() {
            return buildBreakdown;
        }));
        __webpack_require__.d(__webpack_exports__, "convertQueriesToArray", (function() {
            return convertQueriesToArray;
        }));
        __webpack_require__.d(__webpack_exports__, "updateShippingOptions", (function() {
            return updateShippingOptions;
        }));
        __webpack_require__.d(__webpack_exports__, "updateOperationForShippingOptions", (function() {
            return updateOperationForShippingOptions;
        }));
        var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@babel/runtime/helpers/esm/extends.js");
        var _onShippingChange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/props/onShippingChange.js");
        var calculateTotalFromShippingBreakdownAmounts = function(_ref) {
            var breakdown = _ref.breakdown, updatedAmounts = _ref.updatedAmounts;
            var newAmount = 0;
            var updatedAmountKeys = Object.keys(updatedAmounts) || [];
            var discountKeys = [ "shipping_discount", "discount" ];
            Object.keys(breakdown).forEach((function(item) {
                if (-1 !== updatedAmountKeys.indexOf(item)) discountKeys.includes(item) ? newAmount -= Math.abs(parseFloat(updatedAmounts[item])) : newAmount += parseFloat(updatedAmounts[item]); else if (discountKeys.includes(item)) {
                    var _breakdown$item;
                    newAmount -= Math.abs(parseFloat(null == (_breakdown$item = breakdown[item]) ? void 0 : _breakdown$item.value));
                } else {
                    var _breakdown$item2;
                    newAmount += parseFloat(null == (_breakdown$item2 = breakdown[item]) ? void 0 : _breakdown$item2.value);
                }
            }));
            updatedAmountKeys.forEach((function(key) {
                breakdown[key] || updatedAmounts[key] && (discountKeys.includes(key) ? newAmount -= Math.abs(parseFloat(updatedAmounts[key])) : newAmount += parseFloat(updatedAmounts[key]));
            }));
            return newAmount.toFixed(2);
        };
        var optionsKeyChanges = function(options) {
            var ordersV2Options = [];
            options.forEach((function(element) {
                var shippingOption = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, element, {
                    amount: {
                        value: element.amount.value,
                        currency_code: element.amount.currencyCode
                    }
                });
                ordersV2Options.push(shippingOption);
            }));
            return ordersV2Options;
        };
        var breakdownKeyChanges = function(breakdown) {
            return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)({}, breakdown.discount ? {
                discount: {
                    value: breakdown.discount.value,
                    currency_code: breakdown.discount.currencyCode
                }
            } : void 0, breakdown.handling ? {
                handling: {
                    value: breakdown.handling.value,
                    currency_code: breakdown.handling.currencyCode
                }
            } : void 0, breakdown.insurance ? {
                insurance: {
                    value: breakdown.insurance.value,
                    currency_code: breakdown.insurance.currencyCode
                }
            } : void 0, breakdown.itemTotal ? {
                item_total: {
                    value: breakdown.itemTotal.value,
                    currency_code: breakdown.itemTotal.currencyCode
                }
            } : void 0, breakdown.shipping ? {
                shipping: {
                    value: breakdown.shipping.value,
                    currency_code: breakdown.shipping.currencyCode
                }
            } : void 0, breakdown.shippingDiscount ? {
                shipping_discount: {
                    value: breakdown.shippingDiscount.value,
                    currency_code: breakdown.shippingDiscount.currencyCode
                }
            } : void 0, breakdown.taxTotal ? {
                tax_total: {
                    value: breakdown.taxTotal.value,
                    currency_code: breakdown.taxTotal.currencyCode
                }
            } : void 0);
        };
        var buildBreakdown = function(_ref2) {
            var _Object$values$;
            var _ref2$breakdown = _ref2.breakdown, breakdown = void 0 === _ref2$breakdown ? {} : _ref2$breakdown, _ref2$updatedAmounts = _ref2.updatedAmounts, updatedAmounts = void 0 === _ref2$updatedAmounts ? {} : _ref2$updatedAmounts;
            var discountKeys = [ "shipping_discount", "discount" ];
            var updatedAmountKeys = Object.keys(updatedAmounts);
            var currency_code = null == (_Object$values$ = Object.values(breakdown)[0]) ? void 0 : _Object$values$.currency_code;
            updatedAmountKeys.forEach((function(key) {
                breakdown[key] ? breakdown[key].value = updatedAmounts[key] : updatedAmounts[key] && (breakdown[key] = {
                    currency_code: currency_code,
                    value: updatedAmounts[key] && discountKeys.includes(key) ? Math.abs(parseFloat(updatedAmounts[key])).toFixed(2) : updatedAmounts[key]
                });
            }));
            return breakdown;
        };
        var convertQueriesToArray = function(_ref3) {
            return Object.values(_ref3.queries) || [];
        };
        var updateShippingOptions = function(_ref4) {
            var option = _ref4.option;
            var updatedOptions = [];
            _ref4.options.forEach((function(opt) {
                if (!opt.id) throw new Error("Must provide an id with each shipping option.");
                if (opt.id === option.id) {
                    option.selected = !0;
                    updatedOptions.push(option);
                } else {
                    opt.selected = !1;
                    updatedOptions.push(opt);
                }
            }));
            return updatedOptions;
        };
        var updateOperationForShippingOptions = function(_ref5) {
            var queries = _ref5.queries;
            queries[_onShippingChange__WEBPACK_IMPORTED_MODULE_1__.ON_SHIPPING_CHANGE_PATHS.OPTIONS] && (queries[_onShippingChange__WEBPACK_IMPORTED_MODULE_1__.ON_SHIPPING_CHANGE_PATHS.OPTIONS].op = "replace");
            return convertQueriesToArray({
                queries: queries
            });
        };
    },
    "./src/props/utils.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "checkUlsatNotRequired", (function() {
            return checkUlsatNotRequired;
        }));
        var _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@paypal/sdk-constants/src/index.js");
        var checkUlsatNotRequired = function(paymentSource, buyerAccessToken) {
            return paymentSource === _paypal_sdk_constants_src__WEBPACK_IMPORTED_MODULE_0__.FUNDING.VENMO && !buyerAccessToken;
        };
    }
});